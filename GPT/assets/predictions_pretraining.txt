
----------------------------------------------------------------------------------------------------
iteration = 500
----------------------------------------------------------------------------------------------------
<INPUT>
: ==1:
		continue
	vis[i] = 1
	j=inp[i]-1
	count = 1
	while vis[j]!=1:
		count+=1
		vis[j]=1
		j = inp[j]-1
	siz.append(count)
siz.sort(reverse = True)
if len(siz)==1:
	print(siz[0]**2)
else:
	ans = (siz[0]+siz[1])**2
	for i in range(2, len(siz)):
		ans+= siz[i]*siz[i]
	print(ans)
from collections import defaultdict as dd
g=dd(list)
def addE(u,v):
	g[u].append(v)
	g[v].append(u)
n=int(input())
l=[int(x) for x in input().split()]
for i in range(n):
	addE(i+1,l[i])
visited=[False]*(n+1)
def dfs(v,count):
	visited[v]=True
	stack=[v]
	while len(stack)!=0:
		cur=stack.pop()
		for ch in g[cur]:
			if visited[ch]:
				continue
			visited[ch]=True
			count+=1
			stack.append(ch)
	return count

ans=[]
for i in range(1,n+1):
	if not visited[i]:
		ans.append(dfs(i,1))

ans=sorted(ans,reverse=True)
if  len(ans) ==1:
	print(ans[0]*ans[0])
else:
	ans[1]+=ans[0]
	ans.pop(0)
	print(sum(x*x for x in ans))



def AP(seq):
	d = seq[1]-seq[0]
	for i in range(1, len(seq)-1):
		if seq[
<PREDICTION>
: 


			
		:i]
 0
		]0.[i]1]		( 0
		 i[i]
=0]
			(1
			appendi]1
			] 0 range[i]1]		[[append(i[
	[[append()int= 0

	 i(n[[
0,
		(n[[i]
(,
	:
		 = 01[ =i]1[[i]
(,		 i in range(n,1(n[[

			 =1[[i]
n[[i]
		(n =
	[
 0(( n
	[0 =n(
	 __([n, input)
		[i]append(int)
		[i]append(n,
	,0,int())
	[0,int)
 i in range().split()

	 i in range(n,
		([int]1]0[i]
	append[0

nint,1]
	 __p(int]0[
		:[i,1
		.0)
		 i(n.:0]
			 =0.append()
			 i in range[i=
				 i[i[
					
				_[i[1
				 =1]				.append(n[
		 0[		 =0
	 i in range(n]input,1]
		 i in[i]
			 =append(nn[n]input]
		 =0[(n =0()0

	 i (int =
 0,
		(n =i]
n =i]
	:
		 =i]
1 =i]
		 =append()n]
		(n(n)n, i in range

		 __[n =
		[ 0[i]1 =i]
		 i in range(n]input(n =1]
			 i[i
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 1000
----------------------------------------------------------------------------------------------------
<INPUT>
: a_1, a_2, \dots, a_n$. The array can contain both positive and negative integers, but Kolya doesn't like $0$, so the array doesn't contain any zeros.

Kolya doesn't like that the sum of some subsegments of his array can be $0$. The subsegment is some consecutive segment of elements of the array. 

You have to help Kolya and change his array in such a way that it doesn't contain any subsegments with the sum $0$. To reach this goal, you can insert any integers between any pair of adjacent elements of the array (integers can be really any: positive, negative, $0$, any by absolute value, even such a huge that they can't be represented in most standard programming languages).

Your task is to find the minimum number of integers you have to insert into Kolya's array in such a way that the resulting array doesn't contain any subsegments with the sum $0$.


-----Input-----

The first line of the input contains one integer $n$ ($2 \le n \le 200\,000$) — the number of elements in Kolya's array.

The second line of the input contains $n$ integers $a_1, a_2, \dots, a_n$ ($-10^{9} \le a_i \le 10^{9}, a_i \neq 0$) — the description of Kolya's array.


-----Output-----

Print the minimum number of integers you have to insert into Kolya's array in such a way that the resulting array doesn't contain any subsegments with the sum $0$.


-----Examples-----
Input
4
1 -5 3 2

Output
1

Input
5
4 -2 3 -9 2

Output
0

Input
9
-1 1 -1 1 -1 1 1 -1 -1

Output
6

Input
8
16 -5 -11 -15 10 5 4 -4

Output
3



-----Note-----

Consider the first example. There is only one subsegment with the sum $0$. It starts in the second element and ends in the fourth element. It's enough to insert one element so the array doesn't contain any subsegments with
<PREDICTION>
: ,a, x_i, xle1_ a_a,
 first of be $ $ integer $ $ $ and $___'t be $a, $ $ first.'t be the $_.


$,_'t be $ the first of the integer_ the, the first. be thea,
 first of the. $ integer $ of the of the first of



 the the the to, of_ the $ first of the:_. the.'t be the of_ the, the first ofn,
 the the number. the to be the of $ the of. the to of the first.1.. be the the $
 integer the. thea, $ $ the be. the $ line_{ to the to be be the. the integer be..


 the. the the the first number of the $ to the the the the and._ be. the:_{. the first $. be be the ofi the. the first ofn,



-----


 first line of the first of the integer $n$ and1$leq$leq$n $$ and
 the first of the of the$ of_ be of


 first line of the first contains an$ and $n_i$ a_i$ $le_, $_i$ and11$n,$leq_i$leq^n$ $_i$lei_ \ and
 the first of the_ of_ $ of



-----


 the first line of the $ to the the the the_ of_ be of the:_. the first $ of be be the $_ the, the first ofn$



-----

-----



1




-----

1





1

1












1

1

1


1
1


-----



-----



1
1
1



1


-----





-----


 the first line,
 is the $ of of the the the first of1,
 to of the first line. the. the first $.
. the of the the of. $ first. be be the of of the. the
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 1500
----------------------------------------------------------------------------------------------------
<INPUT>
: 		x[b:ym] = [xm] * (ym - b)
			ym = b
		ans -= x[b] - 2
print(ans)def f_simplified_reversi():
	N, Q = [int(i) for i in input().split()]
	Queries = [[int(i) for i in input().split()] for j in range(Q)]

	a, b = [N] * N, [N] * N  # editorial に準じる
	black_stone = (N - 2)**2
	row, col = N, N

	for type, x in Queries:
		if type == 1:
			if x < col:
				for i in range(x, col):
					b[i] = row
				col = x
			black_stone -= b[x] - 2
		else:
			if x < row:
				for i in range(x, row):
					a[i] = col
				row = x
			black_stone -= a[x] - 2
	return black_stone

print(f_simplified_reversi())from collections import defaultdict
n, k = list(map(int, input().split()))
a = list(map(int, input().split()))
d = defaultdict(int)
sa = [0] * (n + 1)
# d[0] = 1
# if k == 1:
#	 print(0)
#	 return
for i in range(n):
	sa[i + 1] = sa[i] + a[i]
	sa[i + 1] %= k
ans = 0
for i in range(n + 1):
	v = sa[i] - i
	v %= k
	ans += d[v]
	d[v] += 1
	if 0 <= i - k + 1:
		vv = sa[i - k + 1] - (i - k + 1)
		vv %= k
		d[
<PREDICTION>
: 		 =x]
[ = 01,] * (x[ x)
				 = [
			 = 1
x]
 x
	(ans)
 main(point_()::pointverss(
		 = m = mapint(input) for i in input().split()]
	for = = [0(i) for i in input().split()]
 i in range(N)]
	for, b = listint for * (
 bint)] * ( +
 a
�����
	for =list_ [N - 1)
9
	for = d = [
 0
	for i in v in enumer::
		if x[ 0:
			if x < y:
				if x in range(N, y):
				ifif[i] = ([					[ (
				 =x_ 1
i]
 x
			:
				 x[ y_
				if x in range(N, y_
				ifif[i] = ([				if[ (
				 =x_ 1[i]
 x
		 ans
list_
def(ans)point)_)pointversed_
 collections import defaultdict
from =std = map(map(int, input().split()))

 = [(map(int, input().split()))

 = [dict(int,
for = [0] * nN + 1)
forprintp0] = [
forprint n == 0:
#print for(1)
#printfor [# i in range(n):
	for =i] 1] = 0[i]
 1[i]
	for[i] 1] == 2
	 = 0
for i in range(N): 1):
	for[ 0[i]
 1
	for[= MOD
	for += 1
i]
	for[i] = 1
	for d: n:1: 1:
		for[ 0[i] 1] 1]
 1A - 1) 1)
		if == MOD
		if[i
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 2000
----------------------------------------------------------------------------------------------------
<INPUT>
: [i]:
		j -= 1
	ans = max(ans, i + j)
print(ans)def main(N, M, K, A, B):
	#print(f'K: {K}, A: {A}, B: {B}')

	Ai = [0]
	for i in range(N):
		Ai.append(Ai[i]+A[i])
	#print(f'Ai: {Ai}')

	Bj = [0]
	for j in range(M):
		Bj.append(Bj[j]+B[j])
	#print(f'Bj: {Bj}')

	ans = 0
	# len(A) = N+1, len(B) = M+1
	best_i = 0
	for j in range(M+1):
		tmp = 0
		for i in range(best_i, N+1):
			#print(f'i: {N-i}, j: {j}')
			#if Ai[N-i] + Bj[M-j] <= K:
			if Ai[N-i] + Bj[j] <= K:
				#tmp = N - i + M - j
				tmp = N - i + j
				best_i = i
				break
		#print(f'tmp: {tmp}')
		if tmp > ans:
			ans = tmp

	return ans
			

def __starting_point():
	N, M, K = list(map(int, input().split()))
	A = list(map(int, input().split()))
	B = list(map(int, input().split()))
	print((main(N, M, K, A, B)))


__starting_point()n, m, k = list(map(int, input().split()))
a = [0] + list(map(int, input().split()))
b = [0] + list(map(int, input().split()))

for i in range(1, n +
<PREDICTION>
: i]
			 = 1
		 += 0(ans, ans) 1)
	(ans)
 main():int): M): M: M: A:
	A A(A(A, Ai} K[ AN} A: AA} {
	# =, AA, *	for i in range(N):
		if[ =append(A[)i],A[i])
	A A(A(A[)ii[: {
	# = = 00] *	for i in range(N):
		if[ =append(A[)j],A[j])
		print(A(#[)ii}:".
	# = 0
	forprint(A)
 0
1
 A(A)
 1
1
	# =ans = 0
	for i in range(N):1):
		if_ max
		if j in range(N_i+ -+1):
			ifprint(i(A,ii}1} 0,ii} {
				print i_i]1] == 1[i-1] == K:
				 K[i-1] == K[i] == K[
				#print = min[ M
 1
 M
				#_ i
 M
 1
				#_i = i
				#
			print(ans___ii_".
		# ans_ 0:
			print = max_		 ans





		 __starting_point():
	main = M = M = map(map(int, input().split()))
	A = [(map(int, input().split()))
	A = [(map(int, input().split()))
	A(A(A, M)) M)) M)) M))

defstarting_point()import, M = m = map(map(int, input().split()))

 = listint] * [(map(int, input().split()))

 = [0] * [(map(int, input().split()))

for i in range(N, n): 1
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 2500
----------------------------------------------------------------------------------------------------
<INPUT>
: [i]["min"] = min(num, buckets[i]["min"])
				 buckets[i]["max"] = max(num, buckets[i]["max"])
		 max_diff = 0
		 max_prev = buckets[0]["max"]
		 for i in range(1, n):
			 if buckets[i]["min"] is not None:
				 max_diff = max(max_diff, buckets[i]["min"]-max_prev)
				 max_prev = buckets[i]["max"]
		 #print(buckets)
		 return max_diffclass Solution:
	def maxSum(self, nums1: List[int], nums2: List[int]) -> int:
		a = 0; b = 0
		i = 0; j = 0
		
		while i < len(nums1) and j < len(nums2):
			if nums1[i] < nums2[j]: a += nums1[i]; i+=1
			elif nums1[i] > nums2[j]: b += nums2[j]; j+=1
			else:
				a = b = max(a, b) + nums1[i] # they are equal when numbers are equal
				i+=1; j+=1

		while i < len(nums1): a += nums1[i]; i+=1
		while j < len(nums2): b += nums2[j]; j+=1
		return max(a, b) % 1_000_000_007
class Solution:
	def maxSum(self, nums1: List[int], nums2: List[int]) -> int:
		n1,n2 = nums1,nums2
		s,t,sum1,sum2 = len(n1)-1,len(n2)-1,0,0
		li = []
		ans = 0
		while s >= 0 and t >= 0:
			if n1[s] > n2
<PREDICTION>
: i]j][(
 "(max[ num[i][0])()
					[i][j][( = max(max[ i[i][imax()
			_max = max
		for_diff = max[i][0max(
		for i in range(len,len):
			max i[i][0][_ ==_ None:
				max_diff = max(max_diff, i[i][0max_)i_diff[
				 max_diff = max[i][0max_
			 print(maxer[
			 max_min
 Solution:
	def maxDays(self, nums:: List[int], ms2: int[int], -> int:
		n = [

 = 0;		for = 0

 = 0;		while		while i < len(n):2): and num < n(nums2):
			if nums[[i][ == nums2[j]:
[ 1s2[j]
 += num;				if nums2[i] < nums2[j]:
 = nums2[j] b+=1
				:
				if[ num
 b(a, b)
 nums2[j]
print are no to the of the to				if +=1

 =1
			 i < len(nums2)
 = nums2[j] j+=1;			 num < n(nums2)
 = nums2[j] d+=1
			 max(n, b,class (classdiff
max
y
	 Solution:
	def maxDays(self, nums1: List[int], nums2: List[int], -> int:
		n = = n2 = lens2[ num22 =		n2n2n = =sum2 = 0(nums)1, num(nums)1
0
0
		for2 max
		for = 0
		for n2 n: num2 n:
			if num > <=n2 < num::
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 3000
----------------------------------------------------------------------------------------------------
<INPUT>
: 798793, 655740377, 967221124, 25251458, 75754374, 645445336, 936336001, 136406838, 409220514, 950536169, 851608493, 979358500, 938075486, 114879014, 344637042, 236429328, 709287984, 843939852, 531819542, 378273156, 134819461, 683312753, 49938245, 108754425, 326263275, 16928684, 50786052, 961975591, 885926759, 331027703, 993083109, 981381277, 944143817, 542792054, 628376155, 82414817, 247244451, 151102496, 453307488, 662658106, 987974311, 598603636, 795810901, 162540136, 487620408, 388553819, 165661450, 12659333, 37977999, 443972547, 331917634, 958437012, 875311022, 382843065, 148529188, 167077427, 501232281, 976648787, 929946347, 360228512, 80685529, 942103925, 826311761, 876690365, 630071081, 752632735, 257898191, 334611056, 3833161, 850976260, 552928766, 663965290, 991895863, 282269401, 846808203, 881592836, 644778494, 509566393, 528699172, 397150974, 191452915, 714590977, 143772917, 50816827, 152450481, 55416008, 166248024, 388787286, 166361851, 681197955, 43593851, 687588891, 62766659, 783961140, 351883406, 916376723, 749130155, 413965678, 241897027, 924317645, 772952921, 258638360, 7759150
<PREDICTION>
: ,
 57x,,, 655537,,, 94444,, 924,, 97444,, 97444,,, 945,,, 9442464, 97444,, 94444,, 99444,, 92444,, 97544,, 948,,, 948,,, 9487,,, 96448,, 94848,, 948,, 91844,, 94874,, 94894, 948,,, 944,, 944,, 97544,, 94824, 975,,, 918,, 91894,, 95018,, 91899,,, 945,,, 94464,, 94474,, 924,, 944,,, 924,,, 924,,, 924,,, 91824,,, 92418,, 99824,, 92422,, 918,,, 964,,, 924,, 944,, 918,,, 91874,, 92445,, 99464,,, 91824,, 97422,, 89444,, 818,,, 99422,, 994,,, 976,33, 976,,, 97618,,, 974,,,, 97418,, 9747,, 945,,, 97424,, 946,,, 97885, 974,,, 977,,, 918,,, 968,,, 97868,, 287464,, 946,,, 94618,, 94624,, 94645,, 518,,, 994,,, 97474,,, 91824,, 97547,, 9947494, 82418,, 518,,, 824,, 824,,, 97424,, 57418,, 54648,,, 6578889, 66918,, 66648,, 69474,,, 9186668,, 937,,, 6182445, 618,,, 918,,, 99418,, 99418,,
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 3500
----------------------------------------------------------------------------------------------------
<INPUT>
: ==1:
		t=None
		ans=None
		if y>=0:
			t=abs(y)-abs(x)
		else:
			t=abs(y+1)-abs(x)
		if t>=0:
			if y>=0:
				ans=2*abs(y)+1
			else:
				ans=2*abs(y)-1
		else:
			ans=2*abs(x)
		print(ans)
	elif r==3:
		t=None
		ans=None
		if x>=0:
			t=abs(x)-abs(y)
		else:
			t=abs(x+1)-abs(y)
		if t>=0:
			if x>=0:
				ans=2*abs(x)+1
			else:
				ans=2*abs(x)-1
		else:
			ans=2*abs(y)
		print(ans)
	else:
		ans=2*max(abs(x),abs(y))
		if x==y and x!=0:
			ans+=1
		print(ans)
for _ in range(int(input())):
	ax, ay, bx, by, cx, cy = list(map(int, input().split()))

	x = min(ax, bx, cx)
	y = min(ay, by, cy)

	if [x, y] not in [[ax, ay], [bx, by], [cx, cy]]:
	  x = 2*x + 1
	  y = 2*y + 1
	elif [x+1, y] not in [[ax, ay], [bx, by], [cx, cy]]:
		x *= 2
		y = 2*y + 1
	elif [x, y+1] not in [[ax, ay], [bx, by], [cx, cy
<PREDICTION>
: 1:
			 =1
		for=max
		for t===0:
			ans=0(x-abs(y-
		else:
			t=abs(y)1)abs(y-
			 t>=0:
			t t>=0:
				ans=t
t(y-abs
			else:
				ans=2*abs(y-abs
			:
			ans=2*abs(y-
			(ans)
	elseif t>0:
		ans=min
	elsefor=1
		for t===0:
			ans=t(x-abs(y)-
		else:
			t=abs(x)-1)abs(y-
			 t>=0:
			t t>=0:
				t=2*abs(y-1
			else:
				t=2*abs(x-1
			:
			t=2*abs(x-
			(ans)
		:
		t=1*abs(x(x)+2(x)+
			 x>0: y<=0:
			ans=1
		else(ans)
	 _ in range(int(input())):
	n,ax, ay =, b = c, by, map(map(int, input().split()))
	if = abs(ax, bx) b)
	if = min(ax, b, b)
	if xa == y, == in [0,ax, ayax,, by, [bx, by]]:
		  = min *(
 1
	  y = 2*y + 1
	 if [x,1, y+ == in [ax, ay, [555x, ay, [bx, cy]]:
	   == 2*	 y * 2*x + 1
	 if [x+ y,1, not in [ax, ay, [555x, ay, [bx, by]
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 4000
----------------------------------------------------------------------------------------------------
<INPUT>
: line().strip()
	n,a,b=list(map(int,finput().split()))
	h=[int(finput()) for _ in range(n)]
	gs=lambda a,b:a//b+(a%b>0)
	def enough(t):
		s=sum([gs(max(x-t*b,0),a-b) for x in h])
		if s<=t:
			return True
		else:
			return False
	l=max(h)//b+1
	t=0
	while l>0:
		t=t+l//2
		if enough(t):
			t=t-l//2
			l=l//2
		else:
			t+=1
			l=l-l//2
	print(t)

def __starting_point():
	main()


__starting_point()import numpy as np

N, A, B = list(map(int, input().split()))
H = np.zeros(shape=N, dtype='int64')
for _ in range(N):
	h = int(input())
	H[_] = h


def calc(num, a):
	a -= num * B
	a = (a - 1)//(A - B) + 1
	if sum(a[a > 0]) <= num:
		return True
	else:
		return False


start = 0
end = 10 ** 10

while end - start > 1:
	mid = (start + end) // 2
	if calc(mid, H.copy()):
		end = mid
	else:
		start = mid

print(end)
import math


def check(k, A, B, H):
	return sum([max([0, math.ceil((h - B * k) / (A - B))]) for h in H]) <= k


def main():
	N, A, B = list(map(int, input().split(' ')))
	H = [int(input()) for _ in range(N)]
<PREDICTION>
: ().split()))		 = m,b =list(map(int,input().().split()))
	if=int(i)()) for f in range(n)]
	for=[[[::b:map,b
b-b)b)
	print d(a):
		if=0(((t(a))a,a))a))max*b)) for t in range])
		if t===h:
			return 0
		return:
			return False
		=0(x)
2
1
	return=max
	for l<0:
		if+=0+1
2
		if t(t):
			t=t+1
2
			t=t//2
			:
			t=1
			t+=r//1//2
		(t)
	def __starting_point():
	main()

__starting_point()import sysumpy as np

n, M, B = list(map(int, input().split()))

, int.arrayos(H(np) nptype=int')')

 i in range(N):
	x, H(input())
	if[A = int

for main(x): a,
	if, 1
 2
	b -= anum + a) //BA - 1)
 a
	b a(a)0] 0] + a:
		return False
	else:
		return False

def = 0
while = 0** 9
forfor start < start < 0:
	if = endend + end) // 2
	if sum(num, a)index()):
		start = mid
		:
		end = mid
	print(start)
import n

def main(n): a): B): B):
	if sum(((k] 0.ceil(k + k) B + // Bk - k) for

 k in range,

 k

def solve():
	n, K, B = list(map(int, input().split() ')))
	A = intint(x()) for _ in range(N)]

----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 4500
----------------------------------------------------------------------------------------------------
<INPUT>
:  L[i][0] < R[j][0]:
				arr[k] = L[i]
				i += 1
			else:
				arr[k] = R[j]
				j += 1
		k += 1
	while i < n1:
		arr[k] = L[i]
		i += 1
		k += 1
	while j < n2:
		arr[k] = R[j]
		j += 1
		k += 1
def mergesort1(arr,l,r):
	if l < r:
		m = (l+(r-1))//2
		mergesort1(arr, l, m)
		mergesort1(arr, m+1, r)
		merge1(arr, l, m, r)
def merge2(arr, l, m, r):
	n1 = m - l + 1
	n2 = r- m
	L = [0 for i in range(n1)]
	R = [0 for i in range(n2)]
	for i in range(0 , n1):
		L[i] = arr[l + i]
	for j in range(0 , n2):
		R[j] = arr[m + 1 + j]
	i,j,k=0,0,l
	while i < n1 and j < n2 :
		if L[i][0] > R[j][0]:
			arr[k] = L[i]
			i += 1
		else:
			arr[k] = R[j]
			j += 1
		k += 1
	while i < n1:
		arr[k] = L[i]
		i += 1
		k += 1
	while j < n2:
		arr[k] = R[j]
		j += 1
		k += 1
def mergesort2(arr,l,r):
	if l < r:
		m = (l+(r
<PREDICTION>
: [i]j]
 l[i][0]:
					[i][ = arr[i][
				if += 1
				:
				i[k] = L[i]
				i += 1
			 = 1
		 k < R::
		if[i] = arr[i]
		i += 1
		j += 1
		 k < n1:
		if[j] = L[j]
		k += 1
		k += 1
	 checkges(((arr, k,r):
	if l == r:
		return = 0l +l-l)//2
		ifgeort2(arr,l,r)
		mgesort2(arr, l)1,l)
		mges1(arr, m, r) m)
	 __((arr, l, r): r):
	if = = l
 l
 1
	m2 = m -1
	if = m0] i in range(n2)]
	L = [0 for i in range(n2)]
	L i in range(n, l2):
		L[i] = L[i] 1]
		 i in range(0, n2):
		L[i] = R[j] j] j]
	for = j =k =0,0
0+	while j < n2: L < m2:
		L L[i]j] == L[i][0]:
			L[i] = R[i][
			i += 1
		j:
			j[k] = R[i]
			j += 1
		j += 1
		 j < n2 and
		if[i] = R[i]
		i += 1
		j += 1
		 j < n2:
		if[k] = L[j]
		i += 1
		j += 1
	 findgesort((arr,l,r):
	if l < r:
		return = ll +r-
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 5000
----------------------------------------------------------------------------------------------------
<INPUT>
:  j 
						elif k2 < neededK:
							total += c1[k1]*c2[k2]*c2[neededK]
						print(k1,k2,neededK,total)
			return total
		
		return doit(counts1,counts2) + doit(counts2,counts1)class Solution:
	def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:
		ct=0
		d={}
		for j in range(len(nums2)):
			for k in range(j+1,len(nums2)):
				if nums2[j]*nums2[k] in d:
					d[nums2[j]*nums2[k]]=d[nums2[j]*nums2[k]]+1
				else:
					d[nums2[j]*nums2[k]]=1
		dd={}
		for j in range(len(nums1)):
			for k in range(j+1,len(nums1)):
				if nums1[j]*nums1[k] in dd:
					dd[nums1[j]*nums1[k]]=dd[nums1[j]*nums1[k]]+1
				else:
					dd[nums1[j]*nums1[k]]=1
		
		ct=0	   
		for i in range(len(nums1)):
			x=nums1[i]*nums1[i]
			if x in d:
				ct=ct+d[x]
			
		for i in range(len(nums2)):
			x=nums2[i]*nums2[i]

<PREDICTION>
:  in
							if j == == i::
								 += 1nt
j1]
c2[k2]
c2[kK]
							(total1, total2)total)) total)
				 total
		
		return totalclass(n)), count)2)
 countit(counts1,counts2)
 Solution:
	def countTriplets(self, nums1: List[int], nums2: List[int]) -> int:
		n =0
		for=}
		for i in range(len(nums1)):
			if k in range(len):1,len(nums2)):
				if nums1[k] innums2[k] in d:
					ct[nums1[j]]].=ums2[k]+=1[nums2[j]]][nums2[k]
1
				else:
					d[nums2[j]]*nums2[k]]=d
			=}
		for i in range(len(nums1)):
			for k in range(j+1,len(nums2)):
				if nums1[j] innums2[k] in d:
					d[nums1[j]]*nums2[k]]=d[nums1[j]*nums1[k]]
1
				else:
					d[nums1[j]*nums1[k]]=d
					return=0
	   		for i in range(len(nums1)):
			for=0ums1[i]*nums1[i]
			if x in d:
				ct+=0
1[x]
						return i in range(len(nums1)):
			for=nums1[i]*nums1[i]
	
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 5500
----------------------------------------------------------------------------------------------------
<INPUT>
: ]=2*nb+min(a0,a2)
	elif na==a-2:
	  A[0]=min(a0,a1,a2)
	  A[1]=nb+min(a0,a1,a2)
	  A[2]=2*nb+min(a1,a2)
	elif na==a+1:
	  A[0]=min(a0,a2)
	  A[1]=nb+min(a0,a1)
	  A[2]=2*nb+min(a0,a1,a2)
	elif na==a+2:
	  A[0]=min(a0,a1)
	  A[1]=nb+min(a0,a1,a2)
	  A[2]=2*nb+min(a0,a1,a2)
	else:
	  A[0]=min(a0,a1,a2)
	  A[1]=nb+min(a0,a1,a2)
	  A[2]=2*nb+min(a0,a1,a2)
 
  print(min(A))
# prime power always 0
# two prime powers?
#
# == 1 prime factor
#   trivial
# == 2 prime factors
#   p^a q^b
#   if a + b > 2: then fine
#   p*q
#   (remaining with p)
#   p*p*q
#   (remaining with q)
# >= 3 prime factors is fine
#   what ordering?
#   p*q*r
#   (all left with p)
#   p*q
#   (all left with q)
#   q*r
#   (all left with r)

from collections import defaultdict as dd, deque

def factor(n):
	factors = dd(int)
	d = 2
	while d*d <= n:
		while n%d == 0:
			factors[d] += 1
			n //
<PREDICTION>
: 

(
1(n,- b1)
		if a==111:
		 a1i]=1(A0,A1)a2)
	el A[0]=min+min(a0,a2,a2)
	else A[1]=min*nb+min(a0,a2,
	 ifna==a-2:
	  A[0]=min(A0,A1,
	  A[0]=min+min(a0,a2)
	  A[2]=min*nb+min(a0,a2)a2)
	 ifna==a+1:
	  A[0]=min(a0,a1,
	  A[1]=min+min(a0,a1)a2)
	el A[2]=min*nb+min(a0,a1)a2)
	el:
	  A[0]=min(a0,a1,a2)
	  A[1]=min+min(a0,a1,a2)
	  A[2]=min*nb+min(a0,a1,a2)
	 print
(A(A[
  cook factor of be
# prime-
 of
# prime#
 prime
 numberization#

 
#  1
 factor
#    =i prime
p
#    p prime p <= b:
 p =#	  ^b^#   pain) a)
#   *qqp
#   ppaining) p)
#  n
 factor
 prime
#  
 is a
#   *q =q
#   rem prime with p)
#   *q*#   pp left with p)
#   *p*#   p left with q)
## collections import Counterdict
 dd
 deque

def findizationn):
	ifors = default(n)
	for = default
	for d*d <= n:
		fact n %d == 0:
			factors[n] += 1
			n //=
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 6000
----------------------------------------------------------------------------------------------------
<INPUT>
: 1]=0
	
	qu=deque([(x1,y1)])
	qup=qu.popleft
	qua=qu.append
	
	d=((-1,0),(1,0),(0,-1),(0,1))
	
	while(len(qu)>0):
		v=qup()
		for di in d:
			for i in range(1,K+1):
				nvh=v[0]+i*di[0]
				nvw=v[1]+i*di[1]
				if nvh<0 or nvh>=H or nvw<0 or nvw>=W or mas[nvh][nvw]=="@":
					break
				if dist[nvh][nvw]!=-1 and dist[nvh][nvw]<=dist[v[0]][v[1]]:
					break
				if dist[nvh][nvw]==-1:
					dist[nvh][nvw]=dist[v[0]][v[1]]+1
					qua((nvh,nvw))
	print(dist[x2][y2])
	
def __starting_point():
	main()
__starting_point()def ii():return int(input())
def iim():return list(map(int,input().split()))
def iil():return list(map(int,input().split()))
from collections import deque


def bfs(xg,yg):
	queue = deque([(xs,ys,0)])
	while queue:
		x,y,dep = queue.popleft()
		l = []
		f1 = True
		f2 = True
		f3 = True
		f4 = True
		for i in range(1,k+1):
			if f1:
				if cord[y][x+i] == '.':
					l.append((x+i
<PREDICTION>
: ,m
			foreries[]que()])0,,x1,])
	
.=de.popleft()	for=[].p([	for	for=x1,0,(0,0),(0,1))(0,0,
	
	for(d(qu)):0):
		
=qu..
		if i, range:
			if i in range(len,len+1):
				if==d[i]i
(
0]
				ifh=v[1]+i*dj[1]
				if (v<<=: nvh<00: nvh<0: nvw<=H: n[nvw][nvw]==0#':
					qu
				if n(nvh][nvw]===1: dist[nvw][nvw]!distdist[nv][0]][nv[1]][
					dist
				dist dist[nvh][nvw]!dist1:
					dist[nvh][nvw]=dist[nv[0]][nv[1]
1
					dist.nvw,nvw))
		(dist[-][][y2])
			 __starting_point():
	main()

starting_point()import main():
 int(input())
def ii():(): return [(map(int, input().split()))
def iim( return int(map(int,input().split()))
def collections import defaultque

def mainfs(x,,x,
	if = deque([xxgy),0,])
	while queue:
		v =y =c = queue.popopleft()
		if = len
		for = = x
		for2 = True
		for2 = True
		for3 = True
		for i in range(1,len+1):
			if i1:
				if l[i][x]1] == -@:
					f.append(x+i,
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 6500
----------------------------------------------------------------------------------------------------
<INPUT>
: _end = arr[i]
			length[new_end - new_start + 1] = length.get(new_end - new_start + 1, 0) + 1
			startwith[new_start] = new_end
			endwith[new_end] = new_start
			if m in length and length[m] > 0: ans = i+1
		return ans

class Solution:
	def findLatestStep(self, arr: List[int], m: int) -> int:
		n = len(arr)
		if m == n: return m
		length = [0] *(n + 2)
		res = -1
		for i, a in enumerate(arr):
			left, right = length[a-1], length[a+1]
			if left == m or right == m:
				res = i
			length[a-left] = length[a+right] = left + right + 1
		return res
				
					
		
class Solution:
	def findLatestStep(self, arr: List[int], m: int) -> int:
		n = len(arr)
		if m==n: return m
		res = -1
		length = [0 for _ in range(n+2)]
		
		for i,val in enumerate(arr):
			left, right = length[val-1], length[val+1]
			if left==m or right==m:
				res = i
			length[val-left] = length[val+right] = left+right+1
		return res   class Solution:
	def findLatestStep(self, arr: List[int], m: int) -> int:
		from collections import Counter
		n = len(arr)
		mem = [0] * n
		counter = Counter()
		res = -1
		for j, v in enumerate(arr):
			i = v - 1
			mem[i]
<PREDICTION>
: y = 0[i]
				 =i_length] 1_end] 1] = 1[get(new_end) 1_end + 1, new) + 1
				 =_new_end] = new_end
			if =[new_end] = new_end
			if i == length: m[m] == 0:
 = max
1
			 ans
	class Solution:
	def getLengthStep(self, arr: List[int], m: int) -> int:
		if = len(arr)
		arr m == 1:
 m
		
 = [0] * (n + 1)
		for = 01
		for i in n in enumerate(arr):
			if = right = 0[i -1], length[a-1]
			if left == m: right == m: return				res = i+			if[a]1] = length[a-1]
 length
 1
 1
			 res
									

				 Solution:
	def findLatestStep(self, arr: List[int], m: int) -> int:
		
 = len(arr)
		arr m ==1: return m
		
 = -1
		for = [0] _ in range(n)]1)]
		for		for i in a in enumerate(arr):
			if,right = val[i]1], length[i-1]
			if left==m: right==m:
				res = i+			length[a]left] = length[val+1] = length
1+1
			 res



 Solution:
	def findLatestStep(self, arr: List[int], m: int) -> int:
		
 collections import default
		def = len(arr)
		arro {}0 for * (
		def = [()
		for = -1
		for i in val in enumerate(arr):
			if, j
 1
			while[v] =
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 7000
----------------------------------------------------------------------------------------------------
<INPUT>
: _square = a*b
				potential_c = math.floor(math.sqrt(c_square))
				#print(f\"{potential_c}**2 = {c_square}\")
				#print(f\"{a}{b}{potential_c}\")
				if potential_c**2 == (c_square):
					if potential_c in freq_dict_2:
						answer += freq_dict_2[potential_c]
		return answer
					
					
			
		
		
	def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:
		final_answer = 0
		final_answer += self.f(nums1,nums2)
		final_answer += self.f(nums2,nums1)
		return final_answer
		
	   
class Solution:
	def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:
		
		from collections import Counter
		c1 = Counter(nums1)
		c2 = Counter(nums2)
		
		ans = 0
		for j in range(len(nums2)):
			for k in range(j+1, len(nums2)):
				if math.sqrt(nums2[j]*nums2[k]) in c1:
					ans += c1[math.sqrt(nums2[j]*nums2[k])]
		
		for j in range(len(nums1)):
			for k in range(j+1, len(nums1)):
				if math.sqrt(nums1[j]*nums1[k]) in c2:
					ans += c2[math.sqrt(nums1[j]*nums1[k])]

<PREDICTION>
: length_ 0_b
					_ =squarent 0.ce(b.sqrt(b))square))
				ifprint(i'{i}_c}{ is\ = {},_square}")
				#print(f\"{com:b}b__c}\")
					 f_cnt2 == 0c_square-
					return c_c** gq:square:dict:
						if = freq_dict_2[(est_c]
			 answer
class										
									
		 get_plets(self, nums1: List[int], nums2: List[int], -> int:
		
_sum = 0
		for_answer = num.num\"nums1, numums2)
		
_answer += self.f(nums1,nums2)
		return final_answer
		
	def


	 Solution:
	def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:
		n		n collections import default
		
1 = Counter(nums1)
		c2 = Counter(nums2)
		
		c = 0
		
 i in range(len(cums1)):
			
 i in range(len+1,len(nums1)):
				if num.sqrt(nums1[j]*nums2[k] <= c1:
					ans += c1[n.sqrt(nums2[j]*nums2[k])]
					return k in range(len(nums1)):
			for k in range(j+1, len(nums2)):
				if math.sqrt(nums1[j]*nums2[k]) in c2:
					ans += c1[math.sqrt(nums1[j]*nums1[k])]
	
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 7500
----------------------------------------------------------------------------------------------------
<INPUT>
: print(max(0, m[i + 1] + 1 - a[i]), end=" ")
print(0)3

prev = dict()

def dfs(a, b):
	if a > b:
		return
	if 2 * a not in prev:
		prev[2 * a] = a
		dfs(2 * a, b)
	if 10 * a + 1 not in prev:
		prev[10 * a + 1] = a
		dfs(10 * a + 1, b)



a, b = list(map(int, input().split()))
dfs(a, b)

if b not in prev:
	print("NO")
else:
	print("YES")
	path = []
	while b != a:
		path.append(b)
		b = prev[b]
	path.append(a)
	path.reverse()
	print(len(path))
	print(*path)
a, b = [int(x) for x in input().split()]
ans = [b]
while b > a:
	if b % 2 == 1 and str(b)[-1] != '1':
		print("NO")
		break
	if b % 2 == 1 and str(b)[-1] == '1':
		b = b // 10
		ans.append(b)
		continue
	if b % 2 == 0:
		b = b // 2
		ans.append(b)
		continue
else:
	if b != a:
		print("NO")
	else:
		print("YES")
		print(len(ans))
		for i in range(len(ans)):
			print(ans[len(ans) - i - 1], end = " ")from math import sqrt,ceil;
def main():
	n,a,b = [int(i) for i in input().split()]
	swaped = 0
	if (a > b):
		a,b = b,a
		swaped = 1
	if (a*b >=
<PREDICTION>
: (ans(ans, max -0] 1] - 1, max[i + max = ")
	(max,


# = 0()

for mainfs(i, b):
	if a == 0:
		return
	if a * a in in prev:
		return[a * a] = d
		prevs(a * a, b)
		 2 * b not b < in prev:
		prev[2 * a] 1] = prev
		dfs(2 * a, 1, b)

defn, b = list(map(int, input().split()))

s(a, b)

print b == in prev:
	print("YES")
else:
	print("YES")
	print = [
	for b: 0:
		path.append(b)
		b = b[b]
		.append(a)
	path.append()
	path(len(path))
	print("path)
	, b = listint(x) for x in input().split()]

 = 00]
for b != 0:
	ans b % 2 == 0: b(b %21] == str0':
		ans('NO")
		return
	else b % 2 == 1: str(b)[-1] != '1':
		ans = b
 2
		ans.append(b)
	elseans
	else b % 2 == 1 and
		ans = b // 10
		ans.append(b)
		ans
	:
	print b % b:
		ans("YES")
		:
		print("YES")
		print(*len(ans))
		print i in ans(len(ans)):
			print(ans[i(ans[ - 1]) 1]) end=" " ")
 sys import *rt
 sqil

a main():
	a, m,b = mapint(x) for i in input().split()]
	a = = [
	for aa% b):
		sw =b = a,a
	ifswith = 0
	if (a ==b) a
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 8000
----------------------------------------------------------------------------------------------------
<INPUT>
: 
-----Output-----

If Lee can survive the dinner then print ALIVE (case insensitive), otherwise print DEAD (case insensitive).

Also, if he can survive the dinner, print the order Lee should call friends. If there are multiple valid orders, print any of them.


-----Examples-----
Input
3 3
1 2 1
1 2
2 3
1 3

Output
ALIVE
3 2 1 

Input
3 2
1 1 0
1 2
1 3

Output
ALIVE
2 1 

Input
4 4
1 2 0 1
1 3
1 2
2 3
2 4

Output
ALIVE
1 3 2 4 

Input
5 5
1 1 1 2 1
3 4
1 2
2 3
4 5
4 5

Output
ALIVE
5 4 1 3 2 

Input
4 10
2 4 1 4
3 2
4 2
4 1
3 1
4 1
1 3
3 2
2 1
3 1
2 4

Output
DEAD



-----Note-----

In the first example, any of the following orders of friends are correct : $[1, 3, 2]$, $[3, 1, 2]$, $[2, 3, 1]$, $[3, 2, 1]$.

In the second example, Lee should call the second friend first (the friend will eat a plate of food $1$) and then call the first friend (the friend will eat a plate of food $2$). If he calls the first friend sooner than the second one, then the first friend will eat one plate of food $1$ and food $2$ and there will be no food left for the second friend to eat.Student Andrey has been skipping physical education lessons for the whole term, and now he must somehow get a passing grade on this subject. Obviously, it is impossible to do this by legal means, but Andrey doesn't give up. Having obtained an empty certificate from a local hospital, he is going to use his knowledge of local doctor's handwriting to make a counterfeit certificate of illness. However, after writing most of the certificate, Andrey suddenly discovered that doctor's signature is impossible to forge. Or is it?

For simplicity, the signature is represented as an $n\times m$ grid, where
<PREDICTION>
: 	Con-----

In the is be, first is the the,.without,), print, ".case such),

-----, print the is't the number. he the number of. be the.
 he are no solutions solutions, print any of them.

-----Input-----
Input
3

1 2


 2

 2

 2
1Output
1







Input
3 4
1 2 1
1 2

 2

Output
YESF

 2 

Input
4 3
1 2


1 2
1 4
1 3

 3

Output
ALAN

 1   

Input
4 4
1 2 1 1

1 4
1 4
1 4

 4

 6

Output
ALAN
1 1 2   

Input
4 5
1 2
 1
1 4
3 4
4 4
4 4
4 4
4 2

 4

 3
3 2
3 3
3Output
AL());



-----Note-----

In the first example, the of the two two are the are:, "[1, 2, 4,$. $[1, 4, 2]$, $[1, 2] 2]$, $[3, 1, 2]$,

In the second example, the can be the answer example because friend3 first will be the new $ the is3$). and $ the the second friend willthe friend will become a obj of food $1$)
 the can the second friend will, the second friend of the the friend friend will be the of of food $1$ and then $1$ and food are be $ other $. the friend friend will the the
 $ the $ $ a $... the first friend. and the he will have to to new the of the problem.
, he is the to choose the game the. that he he the the't have him the
 has the array number of the new number. he has to to have the own. the the. money. the the new.. the. The, he the the the the following is he he to, that the is current is to to make the
 the the is

The example, the number is the as a integern$t m$ and. each the
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 8500
----------------------------------------------------------------------------------------------------
<INPUT>
: Beginners_Easy009_B_Collecting-Balls-(Easy-Version)_28-August-2020.py"""

N = int(input())
K = int(input())
x = list(map(int, input().split()))

s = 0
for i in range(N):
	if x[i] < K/2:
		s += 2*x[i]
	else:
		s += 2*(K-x[i])
print(s)

# ABC074

N = int(input())
K = int(input())
X = list(map(int, input().split()))

ans = 0
for x in X:
	ans += min(x, K-x)*2
print(ans)
N = int(input())
K = int(input())
X = list(map(int, input().split()))
ans = 0
for x in X:
	ans += min(x, abs(K-x))*2
print(ans)
n=int(input())
k=int(input())
x=list(map(int,input().split()))
ans=0
for xi in x:
	ans+=2*min(xi,k-xi)
print(ans)
# あなたは、電車とバスを乗り継いで旅行をする計画を立てました。
# 電車は旅程に沿って通常のきっぷを買うと A 円かかり、乗り放題きっぷを買うと B 円かかります。
# バスは旅程に沿って通常のきっぷを買うと C 円かかり、乗り放題きっぷを買うと D 円かかります。 
# 電車およびバスについて通常の切符を
<PREDICTION>
: ,.to(.with_B__
_-B_B-
B
B_B-0-
	def, int(input())
A = int(input())

 = list(map(int, input().split()))

if = 0
for i in range(N):
	s x[i] == x:2:
		s += 1
([i]
		:
		s += 2*xK-2[i])
print(s)nnnprint07B

import = int(input())
A = int(input())

 = list(map(int, input().split()))

# = 0
for i in X:
	if += x(x, K)x)min
print(ans)
n = int(input())
A = int(input())
X = list(map(int, input().split()))

 = 0
for x in X:
	ans += min(x, K(x-x))
2
print(ans)
n =int(input())
k=int(input())
x=list(map(int, input().split()))
ans=0
for x in in x:
	ans+=min*x(x-k-x)
print(ans)
n!/�����う琢しなット
�す
��し

����る
���
��いたてと
# ���に�衽��屡�たい�っ�ん�
て��叨��

[��をらら��り笻し��を
た�を買�。 A 冲からり�る。
# �ー�タ�程が政って�圸のきいぷを買う。 B 冲からり��に放題きった�を買�とし円からり�る。

# ��劊は�と�た�にスを�いて、�圸の��鶡に�
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 9000
----------------------------------------------------------------------------------------------------
<INPUT>
: , names: List[str]) -> List[str]:
		wordmap = ddict(int)
		arr = [\"\"]*len(names)
		
		for ind, word in enumerate(names):
			if word not in wordmap:
				arr[ind] = word
				wordmap[word]+=1
			else:
				cnt = wordmap[word]
				while word+\"({0})\".format(cnt) in wordmap:
					cnt+=1
				arr[ind] = word+\"({0})\".format(cnt)
				wordmap[word]=cnt+1
				wordmap[word+\"({0})\".format(cnt)]+=1
		return arrfrom collections import defaultdict
class Solution:
	
	def getFolderNames(self, names: List[str]) -> List[str]:
		used, hashmap = set(), defaultdict(int)
		result = []
		for name in names:
			k = hashmap[name]
			current = name
			while current in used:
				k += 1
				current = '%s(%d)' % (name, k)  # alternative to current = name+'('+str(k)+')'
			hashmap[name] = k
			result.append(current)
			used.add(current)
		return result
from typing import List



class Solution:
	def getFolderNames(self, names: List[str]) -> List[str]:
		exists = {} # maps a name to its count.
		res = [] 
		for name in names:
			if name not in exists:
				res.append(name)
				exists[name] = 1
			else:
				
				newName = '{}({})'.format(name, exists[name])
				exists[name] += 1

<PREDICTION>
:  9 = List[str]) -> List[str]:
		
 = = {}ic()dict)
		d = [0\"\"*len(word)
		for		for word inword in enumerate(word):
			if word in in wordmap:
				word[ind] = word
			elseindmap[word] =1
				:
				arr = = 0
[word]
				if c in1<word}\"".format(wordnt,
 wordmap:
					cnt +=1
					[ind] = word
\"\"0}\".format(cnt)
				cmap[word+wordnt
1
				cmap[word]\"\"0})\".format(cnt)=1
			 wordclass collections import Counterdict
class Solution:
	def	def wordStrNames(self, names: List[str]) -> List[str]:
		d = ansmap = {(), defaultdict(list)
		for = []
		for i in names:
			if = namemap.name]
			if_ 0.			for current != hash:
				if = 1
				if = name{s'ks)
 (len) k)

 current to the
 '
'
+')(k))'

				map[k] = current
			result.append(current)
		returnresult.add(current)
			 result
	 collections import List

classclass Solution:
	def getStrongNames(self, names: List[str]) -> List[str]:
		dists = {}
 default to dictionary to make name to
		for = []
 #		for name in names:
			if name not in res:
				res.append(name)
				resists[name] = []
			else:
				ex				ex_ = ['.}
''.format(new, new)name])
				newists[name] = 1
	
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 9500
----------------------------------------------------------------------------------------------------
<INPUT>
:  (len(x)%2!=0) and (i==len(x)//2) == (l-1-i) ):
				x[i]='a'
				#x[l-1-i]='a'
			elif( (x[i]=='.') and (x[l-1-i] != '.') ):
				x[i]=x[l-1-i]
				#midcheck=2
			elif( (x[i]!='.') and (x[l-1-i] == '.') ):
				x[l-1-i]=x[i]
				#midcheck=2
			elif((x[i]=='.') and (x[l-1-i] == '.')):
				x[i]='a'
				x[l-1-i]='a'
	
				
		elif( (x[i] == x[(l-1)-i])  ):
			flag=1
		else:
			flag=-1
			break
	
	
	if(flag==-1):
		print('-1')

	else:
		print( (''.join(x) ) )
		
		
t=int( input() )

for i in range(t):
	val=str(input())
	calres(val)
	



	
	
	
	
	   # cook your dish here
for _ in range(int(input())):
	n=int(input())
	s=input()
	c=0
	count01=[[0,0] for _ in range(n)]
	for i in range(n-2,-1,-1):
		if s[i+1]=='1':
			count01[i][1]=count01[i+1][1]+1
			count01[i][0]=count01[i+1][0]
		else:
			count
<PREDICTION>
: i(s)):2===0): and (x+0(x)%2): and (len):1):1)://
					 =i] =0'
				xprint[i]1]1]='b'
				if xxx[i]=='b) and (x[i-1]i]== '.') and
				x[l]x[l-1-i]='				#y
=True
				if(xx[l]==='.') and (x[l-1-i] != '.')):
				x[l-1-i]x[l-
				#midcheck=2
				if(x[i]=='.') and (x[l-1-i] != '.')):
				x[l]=='a'
				#[l-1-i]=='b'
				returnel
			if(xx[l]== '[ll-1-i] and and
			x=1
			:
			flag=1
			

			if	if(flag==01):
		print('YES1')

else:
		print('x'.join(x))) for

		
		
	 =int(input()) )
forfor _ in range(t):
	n=input(input())
	
==val)





	
	
	
	



 cook your dish here
import _ in range(int(input())):
	n=int(input())
	a=input()
	s=0
	for==00 for0]] for i in range(n)]
	for i in range(n):1):1,-1):
		if s[i]1][==s.'':
			count01[i+0]=count01[i+1][0]1
			count01[i+0]=count01[i+1][1]
			:
			count01
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 10000
----------------------------------------------------------------------------------------------------
<INPUT>
: ])-1 if costs[s][t] != inf else -1)import sys
import array

from operator import itemgetter

def main():



	input = sys.stdin.readline


	md = 998244353
	n = int(input())
	tl=n+1
	
	ft=[0]*tl

	xy = [[0]*2 for _ in range(n)]
	for i in range(n):
		xy[i] = [int(item) for item in input().split()]
	xy.sort(key=itemgetter(0))
	yxi = [y for x, y in xy]

	*YS, = set(yxi)
	YS.sort()
	yxi= list(map({e: i for i, e in enumerate(YS)}.__getitem__, yxi))

	ct=[0]*(n+1)
	ct[0]=1
	for i in range(1,n+1):
		ct[i]=ct[i-1]*2%md

	cnt=tuple(ct)

	def upd(i):
		i+=1
		while(i<=n):
			ft[i]+=1
			i+=i&-i

	def get(i):
		i+=1
		ret=0
		while(i!=0):
			ret+=ft[i]
			i-=i&-i
		return ret

	def calc(get,upd):
		for i, y in enumerate(yxi):
			v = get(y); upd(y)
			p1 = cnt[v]; p0 = cnt[y - v]
			q1 = cnt[i - v]; q0 = cnt[(n - y - 1) - (i - v)]
			yield (p0 + p1 + q0 + q1 - (p0 + q1) * (p1 + q0)) % md


	print(((sum(calc(get,upd))+n*cnt[n
<PREDICTION>
: 
1
 i[i[j]== 0 else -1

 sys

 math

def collections import itemgetter

def input():
	

n = sys.stdin.readline

		n = 1098244353
	n = int(input())
	a =[]
1
	for	for =0]*n
	for = []]*tl for i in range(n)]
	for i in range(n):
		a[i][ = listint(x) for item in input().split()]
		[sort(key=lambdagetter(0))
	ft = = 00 for y, y in xy]
	forpi = [(mapi)
	*isort(

	
i[[[(range(x: i for i, e in enumerate(xy) ifitemsgetitem__, e))))
	for =0]*nn+1)
	for[0]=1
	ct i in range(1,n+1):
		ct[i]ct[i-1]+
(
md
	fornt=0[(ct[
	for find(x):
		if=1
		while ii>nn):
			if[i] =ft
			i+=1&(-i
		 query(i):
		while+=1
		while =0
		while(i>=n):
			while+=1[i]
			i-=1&-i
		return ret

		 get(i_t,):
		if i inval in enumerate(get):):
			ret = get(i) v(i);
			if = = getnt[v] p2 = cnt[v]; 1];
			if = = cnt[v]; v] p1 = cnt[vv - v) v) % vn - 1)
			p = (p1, p0) p0) q0) pp1 - q1 - - (p0 + q1) % md
			((calget(mapc(i) 0d) forcal)(nt[0]
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 10500
----------------------------------------------------------------------------------------------------
<INPUT>
: 
for i in range(n):
	d={}
	v=-1
	for j in range(i,n):
		t=d.get(a[j],0)+1
		d[a[j]]=t
		if t>v or t==v and a[j]<m:
			v=t
			m=a[j]
		r[m]+=1
print(' '.join(map(str,r[1:])))def ck(p,q):
	return 1 if bpos[p]>fpos[q] else 0
n,k=map(int,input().split())
x=list(map(int,input().split()))
fpos=[-1 for i in range(100001)]
bpos=[k+5 for i in range(100001)]
for i in range(k):
	fpos[x[i]]=i
	bpos[x[k-1-i]]=k-1-i
ans=ck(n,n)
for i in range(1,n):
	ans+=ck(i,i)+ck(i,i+1)+ck(i+1,i)
print(ans)from collections import defaultdict
n,k=map(int,input().split())
lis=list(map(int,input().split()))
first={}
last=defaultdict(int)
length=len(lis)
for i in range(length):
	if lis[i] not in first:
		first[lis[i]]=i 
		
	last[lis[i]]=i 
count=0 

for i in range(1,n+1):
	if i not in first :
		if i==1 or i==n:
			count+=2
		else:
			
			count+=3 
		continue
		
	if i-1>0 and first[i] >= last[i-1]:
		count+=1 
	if i+1<=n and first[i] >= last[i+1]:
		count+=1 
print(count)
<PREDICTION>
: 	 i in range(n):
	a[}
	for=1
	for j in range(i,n):
		if=v[get(j[j],0)1
		if[a[j]]=1
		v t>=: t>1: a[j]==v:
			v=t
			break=t[j]
			=a]=+=1
	( '.join(map(str,r)))1:])))
 mainmp(a, n,
	if p if p[>0]>= else[q]: else 0

, m=map(int,input().split())
a=list(map(int,input().split()))
x==01] i in range(n1)]
forpos=[- for1 for i in range(100001)]
for i in range(n):
	forpos[i[i]-=i
forbpos[i[i]]1]]i]]=i
i
i
for=0(x,k,
for i in range(n,n):
	ans=abs(i,n)1(i,i)1)2(i,1,i+
print(ans)n collections import defaultdict

, m=map(int,input().split())
a=default(map(int,input().split()))

=}
for=0dict(int)
for=default(lis)
for i in range(length):
	if lis[i]> in first:
		first[lis[i]]=i

		length	length[lis[i]]=i


=0

forfor i in range(length,length):1):
	count l in in first:
		count first not0: i==1-
			count+=1
			:
			count			count+=1

			
	

	count count==1>= and first[i-== first[i-1]:
		count+=1 
		 count-1>nn: first[i]> last[i-1]:
		count+=1 
	(count)import
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 11000
----------------------------------------------------------------------------------------------------
<INPUT>
: 			if waiting > 0: waiting -= (waiting+people)

			curr_profit = (total_people*boardingCost) - ((count+1)*runningCost)
			count +=1
		if res < 0:
			return res
		else:
			for i,p in enumerate(profit):
				if p ==res:
					return i
class Solution:
	def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:
		d={}
		p=0
		i=0
		m=sum(customers)//4+1
		z=customers.count(0)
		for i in range(m+z):
			if customers[i]>4:
				customers+=0,
			p+=boardingCost*min(customers[i],4)-runningCost
			if p not in list(d.keys()):
				d[p]=i
			customers[i+1]+=max(customers[i]-4,0)
		if max(d)<0: return -1
		return d[max(d)]+1
			
class Solution:
	def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:
		
		leftover = 0
		dp = [0]
		
		i=0
		while i<len(customers) or leftover:
			
			if i < len(customers):
				leftover += customers[i]
				
			newCust = min(4, leftover)
			leftover -= newCust
			# if leftover>=4:
			#	 newCust = 4
			#	 leftover -= 4
			# else:
			#	 newCust = leftover
			#	 leftover = 0
			
			temp =
<PREDICTION>
: 			 (_ 0:
 = 1waiting)1)
				r =wa = curwa_profit)waCost -
 (wa-1)*boardingCost)
			if += cur
			 cur > cur:
			res -
		return:
			return i in c in enumerate(custom):
				if i> 0:
					continue res
	 Solution:
	def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:
		# =0
		for=0
		for=0
		while=0(customers)
4
4
		while=0ers[index(m)
		while i in range(len):1):
			if i[i]>=:
				pers[custom
i				+=1Cost*boarding(4ers,i],4)4Cost
			if i== in d(d.keys()):
				d[p]=p
				ers[i]=1]=+=custom(customers[p],4,4)
			 p(custom.>=:
 -1
		return -[-(d)]
min
			
	 Solution:
	def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:
		if		if = = 0
		right = [0] *		
		for =0
		
 i<len(customers): and i <
			if			if i< len(customers):
				dpover = customers[i]
				dp				_ = = 0(dp, i -
			dpover = newCust
			dp print i >00:
			#	 dCust+= min
					 d = 4
			#	:
			#	 newCust = 4 -			#	 new -= max
			#			# = 0
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 11500
----------------------------------------------------------------------------------------------------
<INPUT>
:  3411775, 3438201, 3447140, 3453811, 3471520, 3485127, 3522748, 3569412, 3575690, 3578298, 3585562, 3593337, 3624737, 3626198, 3651501, 3667524, 3674434, 3675907, 3738616, 3754186, 3765841, 3786330, 3807381, 3818043, 3829535, 3831874, 3838373, 3862508, 3910613, 3942689, 3950184, 3954465, 3978469, 3992767, 4014701, 4032219, 4033924, 4065368, 4078004, 4089606, 4101646, 4119004, 4155098, 4166329, 4176904, 4182945, 4197748, 4211593, 4218728, 4253237, 4275441, 4288635, 4298689, 4301972, 4329866, 4357640, 4392330, 4403327, 4415543, 4434657, 4454780, 4460817, 4467239, 4489541, 4518764, 4526891, 4541320, 4560957, 4568090, 4582032, 4609341, 4631837, 4683082, 4688874, 4714962, 4728230, 4733954, 4744119, 4797763, 4819301, 4823437, 4850997, 4865482, 4886981, 4907820, 4931122, 4957782, 5005971, 5014678, 5031077, 5054902, 5059300, 5088659, 5119815, 5135680, 5153376, 5210102, 5213548, 5253584]
s = [1]
for i in range(699):
	s.append(s[i]+a[i+1])

for _ in range(T):
	n = int(stdin.readline())
	# p,q = list(map(int,stdin.readline().split()))
	# a = list(map(int,stdin.readline().split()))
<PREDICTION>
: ,,, 41287, 3425529, 333,, 33923, 344733, 335,, 353501, 357735, 3577795, 353595, 353535, 357537, 3635333, 363599, 363595, 363516, 363305, 362799, 379333, 3759947, 377701, 3789333, 38907, 38935, 382853, 389230, 383816, 38716, 38753, 380135, 390195, 38734, 399501, 3955799, 4019899, 402847, 4033230, 4065368, 409807, 4001646, 4001646, 410180, 415310, 4137550, 4138098, 4139847, 417646, 41799, 4296123, 4253243, 47535, 49599, 40147, 40199, 437680, 43340198, 47780, 43847, 441698, 447780, 441647, 441689, 444735, 446716, 4401981, 4951899, 42747, 449516,, 49972, 445616, 4691690, 4635072, 4693816, 49998,, 471698, 472898, 473398, 47697795, 47707, 473337, 483538, 4850300, 48887769, 48079, 4907122, 49988089, 4907, 499,, 499,, 509900, 50807, 5059300, 5001,, 50889980, 50279982, 5271280, 51216, 53880,

olve [0,*
for i in range(1,
	s.append(s[i])s[i])1])

for i in range(int):
	n = int(inputin.readline())
	aprint =c = map(map(int, stdin.readline().split()))
	# p = list(map(int,stdin.readline().split()))

----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 12000
----------------------------------------------------------------------------------------------------
<INPUT>
: def read_input():
	n = int(input())
	s = int(input())

	return n, s


def f(b, n):
	if n < b:
		return n
	t = n // b
	m = n % b
	return f(b, t) + m


def submit():
	n, s = read_input()
	sqrtn = math.ceil(math.sqrt(n))

	if n == s:
		print(n + 1)
		return

	for i in range(2, sqrtn + 1):
		if f(i, n) == s:
			print(i)
			return

	for i in range(sqrtn - 1, 0, -1):
		p = i
		q = s - p
		sho,mod = divmod(n - q, p)
		if mod == 0:
			b = sho
		else:
			continue

		if q < b and p < b:
			if f(b, n) == s:
				print(b)
				return

	print(-1)

def __starting_point():
	submit()
__starting_point()import math
import sys
N = int(input())
S = int(input())

def tt(k, N):
	r = 0
	while N:
		N, m = divmod(N, k)
		r += m
#	print(k, r)
	return r

if N == S:
	print((N+1))
	return

for i in range(2, math.floor(N**0.5) + 2):
	if tt(i, N) == S:
		print(i)
		return

for k in range(math.floor(N**0.5), 0, -1):
	s = N//k
	f = N//(k+1) + 1
	si = k + N%k
	fi = si + (s-f)*k
	if N//(s
<PREDICTION>
:  ___int():
		, read(input())
	a = input(input())
	ans n,s


def read(n, c):
	if n == b:
		return 0,	if = 0
 b
	if = n // b
	return f(t, m)

 f

def main():
	n = k = read_input()
	s = = = int.ceil(n.sqrt(n))
	if n < 1:
		return(0) 1)
		return

	if i in range(n, intrtn): 1):
		if i(i) i) == s:
			print(i)
			return

	for i in range(2rtn, 1, -, -1):
		if = i
		while = i - i
		if = = q = divmod(p, 1, mod)
		if p == 0:
			print = (o			:
			b
		if f == s: s > b:
			print s(b, b) == s:
				print(i)
				return
		(1)


def __starting_point():
	s()

starting_point()n math

 sys
import = int(input())
S = input(input())

def f((a): s):
	if = 0
	for k >
		r -= S = (mod(N, N)
		if += m
		print(N, n)
	return r

def N == 1:
	print(N +1))
	return

if i in range(1, S.ce(N/0.5)+): 1):
	if T((i, N) == s:
		print(i)
		return

print i in range(2.floor(N/0.5)+ 2, -1):
	if = t -k
	if = 0//kk-1)
 1
	if = s
 1//(
	if = k
 msi-si)(
	if f ==fk-
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 12500
----------------------------------------------------------------------------------------------------
<INPUT>
:  = map(int, lines[0].strip().split(" "))
for t in range(T):
	(a, b, n, m) = map(int, lines[t+1].strip().split(" "))
	res = True
	if n + m > a + b: res = False
	elif m > min(a, b): res = False
	if res: print("Yes")
	else: print("No")t = int(input())
for i in range(t):
	n = int(input())
	l = list(map(int, input().split()))
	k = sorted(l)
	c = min(l)
	f = 0
	for j in range(n):
		if (l[j] % c != 0):
			if (l[j] != k[j]):
				print('NO')
				f = 1
				break
	if (f == 0):
		print('YES')
t=int(input())
for i in range(t):
	n=int(input())
	a=list(map(int, input().split()))
	b=sorted(a)
	p=b[0]
	f=False
	for j in range(n):
		if a[j]%p!=0:
			if a[j]!=b[j]:
				f=True
	if f:
		print('NO')
	else:
		print('YES')
from sys import stdin
from math import sqrt

r, d = list(map(int, stdin.readline().split()))
n = int(stdin.readline())
data = []
for i in range(0, n):
	data.append(list(map(int, stdin.readline().split())))

rs = 0
for i in range(0, n):
	D = sqrt(data[i][0] ** 2 + data[i][1] ** 2)
	rs += 1 if (r - d <= D - data[i][2] and r >= D + data[i
<PREDICTION>
:  0(int, input[i])split().split()) "))
	 i in range(q):
	xx, b) c) k) = map(int, lines[1].1].strip().split(" "))
	print = 0
	for a == m == n: b +
 = False
	ifif m == a(a, b) res = False
	else m: res("YES\
	else: print("No")
 = int(input())
for _ in range(t):
	a = int(input())
	a = list(map(int, input().split()))
	if = min(l)
	ifnt sorted(l)
	if = True
	for j in range(k):
		if ll[j] <= k == 0):
			f (l[j] % c[j]):
				f("No')
				break = 1
				break
		 ff == 0):
		print('Yes')
	 =int(input())
for i in range(t):
	n=int(input())
	a=list(map(int,input().split()))
	if=listorted(a)
	if=0+0]
	if=0
	for j in range(n):
		if ([j]!p!=0:
			if ([j]!=b[j]
				print=True
		 f:
		print('YES')
	else:
		print('YES')
	 collections import stdin,for collections import *rt
fort= c, list(map(int, stdin.readline().split()))

 = int(stdin.readline())

 = list
for i in range(n, n):
	data.append(list(map(int, stdin.readline().split())))

for = []
for i in range(0, n):
	if = datart(data[i][1] - 2 + data[i][1] ** 2)
	if += D
 Ddata == d) 0) 1[i][1] ** data - d - data[i][
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 13000
----------------------------------------------------------------------------------------------------
<INPUT>
: 
		print(' '.join(map(str,a)))
else:
	print('NO')
from bisect import bisect_left as bl
from bisect import bisect_right as br
from heapq import heappush,heappop
import math
from collections import *
from functools import reduce,cmp_to_key,lru_cache
import io, os
input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline;M = mod = 10**9 + 7 
def factors(n):return sorted(set(reduce(list.__add__, ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0))))
def inv_mod(n):return pow(n, mod - 2, mod)
def li():return [int(i) for i in input().rstrip().split()]
def st():return str(input().rstrip())[2:-1]
def val():return int(input().rstrip())
def li2():return [str(i)[2:-1] for i in input().rstrip().split()]
def li3():return [int(i) for i in st()]
graph = defaultdict(set);n, k = li();l = [];allwords = set()
for i in range(n):
	p = val();l1 = []
	for j in range(k):l1.append(st())
	allwords |= set(l1[-1]);l.append([p, l1[:]])
l.sort(key = lambda x:x[0]);l = [i[1] for i in l]
if n == k == 1:print(''.join(set(l[0][0])));return
ingraph = defaultdict(int)
def match(a, b):
	for j in range(min(len(a), len(b))):
		if a[j] == b[j]:continue
		elif b[j] in graph[a[j]]:return
		else:graph[a[j]].add(b[j]);ingraph[b[
<PREDICTION>
: 			(NOjoin(map(str, ans)))
	:
	print('-')
n collectionsect import *ect_left as bl
from collectionsect import bisect_right as br
from heapq import heappush,heappop
from math
import collections import *
from functools import reduce
cmp_to_key
 lru_cache
import sys
he
import = sys.BytesIO(os.read(0,os.fstat(0).st_size)).readline
 input = mod = 9**9+ 7

def factors(n):return sorted(set(reduce(list.__add__, ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0))))
def inv_mod(n):return pow(n, mod - 2, mod)
  li():return [int(i) for i in input().rstrip('split()]
def st():return input(input().rstrip('
:-:]1]
def val():return int(input().rstrip())[def li2():return [i(i):-:-1] for i in input().rstrip().split()]
def li3():return [int(i) for i in input()]
def = defaultdict(list)d =m = li()
 = [m = = set(
for i in range(n):
	a = li()c. = set
	for j in range(n):
1.append(val())
	forwords.= set(l1)i1])all2append(]),j1[-k)
	2sort(key= lambda x: x[1])l1 []0 for1], for i in l]
l len == 1: 1:print('NOjoin(map(l[i]1] for
return
print = = setdict(set)
for d(n, b):
	if i in range(a(len(a), len(b),+
		if a[j][ == b[i]:continue
		ifif a[j] == a[a[j]]]:continue False		else:return[a[j]]].add(a[j])aTree[a[j
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 13500
----------------------------------------------------------------------------------------------------
<INPUT>
:  testcases in range(q):
	n=int(input())
	A=list(map(int,input().split()))

	print(-(-sum(A)//n))
import bisect
n,k=list(map(int,input().split()))
r,o=list(map(int,input().split())),''
d={}
for i in range(k):
	a,b=list(map(int,input().split()))
	if [b]!=d.setdefault(a,[b]):
		d[a]+=[b]
	if [a]!=d.setdefault(b,[a]):
		d[b]+=[a]
rr=sorted(r)
for i in range(1,n+1):
	a=bisect.bisect_left(rr,r[i-1])
	if i in d:
		for j in d[i]:
			if r[j-1]<r[i-1]:
				a-=1
	o+=str(a)+' '
print(o)
from collections import Counter
def binary(x,ar):
	low=0
	high=len(ar)-1
	while low<=high:
		mid=(low+high)//2
		if ar[mid]==x:
			break
		elif ar[mid]<x:
			low=mid+1
		else:
			high=mid-1
	return mid


n,q=list(map(int,input().split()))
l=list(map(int,input().split()))
frq=dict(Counter(l))
new=sorted(set(l))
look=[frq[new[0]]]
for i in range(1,len(new)):
	look.append(look[i-1]+frq[new[i]])
d=dict()
for i in range(q):
	li,r=list(map(int,input().split()))
	li-=1
	r-=1
	if li in d:
		
<PREDICTION>
:  case, the(int):
	n,int(input())
	a=list(map(int,input().split()))
	A(sA1(A)-//2))
	 sysect
import=q=list(map(int,input().split()))
a=s=list(map(int,input().split()
list
for=}
for i in range(n):
	d,b=list(map(int,input().split()))
	d aa, in=0.getdefault(a,]),):
		d[a]==[b]
	else bb] in=d.setdefault(b,[b]):
		d[a]+=[a]
	=[]orted(list)
for i in range(k,k+1):
	if,dect.bisect_left(d,d)i])1])
	b a== r:
		d j in range[i]:
			if j[j]1]>=[j]:1]:
				r==d
		=i(a)' '+print(o)
import bis import default
from main_n):y):
	l =0
	high=len(ar)1
	while low<=high:
		mid=(low+high)//2
		if ar[mid]==x:
			low
		ifif ar[mid]>x:
			low=mid+1
		else:
			high=mid-1
	return low

n,k=list(map(int,input().split()))
a=list(map(int,input().split()))
r==list()int)l))
for=[]orted(l(l))
forup0q[i[i]]]
for i in range(1,n(l)):
	for[append(l[i][1][newq[i[i]])
for={dict()
for i in range(q):
	a,r=list(map(int,input().split()))
	if-=1
	r-=1
	d r> d:
		d
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 14000
----------------------------------------------------------------------------------------------------
<INPUT>
: rt(x*y)]
		
		for x,y in combinations(nums1, 2):
			if isPerSq(x*y):
				s += d2[math.sqrt(x*y)]
		
		return sclass Solution:
	def numTriplets(self, nums1, nums2):
		mp1, mp2 = {}, {}
		for ele in nums1:
			if ele in mp1: mp1[ele] += 1
			else: mp1[ele] = 1
		for ele in nums2:
			if ele in mp2: mp2[ele] += 1
			else: mp2[ele] = 1
		
		ans = 0
		for k1, v1 in mp1.items():
			tar = k1 ** 2
			for k2 in sorted(mp2.keys()):
				if k2 ** 2 > tar: break
				elif k2 ** 2 == tar:
					ans += v1 * mp2[k2] * (mp2[k2] - 1) // 2
				elif tar % k2 == 0 and (tar // k2) in mp2:
					ans += v1 * mp2[k2] * mp2[tar // k2]
		for k2, v2 in mp2.items():
			tar = k2 ** 2
			for k1 in sorted(mp1.keys()):
				if k1 ** 2 > tar: break
				elif k1 ** 2 == tar:
					ans += v2 * mp1[k1] * (mp1[k1] - 1) // 2
				elif tar % k1 == 0 and (tar // k1) in mp1:
					ans += v2 * mp1[k1] * mp1[tar // k1]
		return ansfrom collections import Counter
import math
class Solution:
	def f(self,nums1,
<PREDICTION>
: (a)y)
					for i, y in d(x,1, num):
			if x_morted(x*y,
				return1 1p[x.sqrt(x*y)]
					return s
 Solution:
	def numTriplets(self, nums1: nums2):
		n = = mp2 = [}, {
		for im nums1:
			if ele* mp1:
1[ele] += 1
			else: mp1[ele] = 1
		for ele in nums2:
			if ele in mp2: mp2[ele] += 1
			else: mp2[ele] = 1
		for		for = 0
		for ele in in ele in in mp1:items():
			if1 k1
 2
			if k2 in mp(mp1.items()):
				if v1 ** 2 == v:

				ansif k1 ** 2 == v:
					ans += v1 * v1[k2 **
 vv1[k2 ** * 1)
 2
				elseif k in 22 == 0: kk // k1) % mp1.
					ans += v2 * mp2[k2] * (2[k // k2]
			 k1, v2 in mp2.items():
			if = k2 ** 2
			for k2 in range(mp2.keys()):
				if k2 ** 2 > v: break
				elif k2 ** 2 ==tar:
					ans += v2 * mp2[k2] * mpmp2[k2] - 1) // 2
				elif k % k2 == 0: (tar // k2) in mp2.
					ans += v1 * mp1[k1] * mp2[k // k1]
		return ansclass collections import Counter
class math
class Solution:
	def num(self, numums1,n
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 14500
----------------------------------------------------------------------------------------------------
<INPUT>
: print("No")
			return

	print("Yes")


main()
import sys


def input():
	return sys.stdin.readline().strip()


def solve():
	N = int(input())
	inc_chunks = []
	dec_chunks = []
	for _ in range(N):
		depth = 0
		level = 0
		for c in input():
			if c == '(':
				level += 1
			else:
				level -= 1
				depth = min(depth, level)
		if level > 0:
			inc_chunks.append((depth, level))
		else:
			dec_chunks.append((depth - level, -level))

	inc_chunks.sort(reverse=True)
	dec_chunks.sort(reverse=True)
	inc_level = 0
	for depth, level in inc_chunks:
		if inc_level + depth < 0:
			return 'No'
		inc_level += level
	dec_level = 0
	for depth, level in dec_chunks:
		if dec_level + depth < 0:
			return 'No' 
		dec_level += level
	if inc_level != dec_level:
		return 'No'
	return 'Yes'


print((solve()))
def check():
	N = int(input())
	plus,minus = [],[]
	for i in range(N):
		S = input()
		now = 0
		mini = 0
		for s in S:
			if s=='(':
				now += 1
			else:
				now -= 1
				mini = min(mini,now)
		if now>=0:
			plus.append([mini,now])
		else:
			minus.append([now-mini,now])
	plus.sort(reverse=True)
	minus.sort(reverse=True)
	now = 0
	for a
<PREDICTION>
: (No")
else	returnreturn
	print("Yes")

def()
n sys

def main():
	return sys.stdin.readline().r()


def main():
	n, int(input())
	A =listars = [
	for_chots = []
	for i in range(N):
		a = int
		for = 0
		for i in input().
			if c == '':
				level += 1
			el:
				level += 1
				if += 0(level, level)
			 level == 0:
			inc_ch606.append(level, level))
		else:
			inc_cheps.append((depth, 1, level1))
	if_ch606.sort()reverse=True)
	print_chakra.sort()reverse=True)
	print_ch = 0
	for i, level in inc_ch}::
		if level_level == level < 0:
			inc "No'
		if_level += level
		_level = 0
	for level, level in inc_chosen:
		if inc_level + level < 0:
			inc 'No'

		inc_level += level
		 dec_level > 0_level:
		return 'Yes'
	return 'Yes'


print(solve()))
n main(
	n = int(input())
	A = plus = 0], []
	for i in range(N):
		s = input()
		plus = 0
		for = 0
		for j in S:
			if s =='('':
				now += 1
			else:
				now -= 1
			ifmini = min(mini,now)
		if now >00:
			plus.append(now,now])
		else:
			minus.append([mini,now,now])
	if.sort(reverse=True)
	return.sort(reverse=True)
	ans = 0
	for i in
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 15000
----------------------------------------------------------------------------------------------------
<INPUT>
: -sum(A)
 if B>0:
  if B%K==0:
   print(B//K)
  else:
   print(-1)
 else:
  print(-1)T=int(input())
for i in range(T):
 N,K,V=list(map(int,input().split()))
 A=list(map(int,input().split()))[:N]
 S=(N+K)*V
 B=S-sum(A)
 if B>0:
  if B%K==0:
   print(B//K)
  else:
   print(-1)
 else:
  print(-1)
R,C=list(map(int,input().split()))
A=[]
for i in range(R):
	p=list(map(int,input().split()))
	A.append(p)
m, n = len(A), len(A[0])
for i in range(m):
	if A[i][0] == 0: 
		for j in range(n): A[i][j] ^= 1 
		
for j in range(n): 
	cnt = sum(A[i][j] for i in range(m))
	if cnt < m - cnt: 
		for i in range(m): A[i][j] ^= 1

print(sum(int("".join(map(str, A[i])), 2) for i in range(m)))
def main():
	from sys import stdin, stdout
	rl = stdin.readline

	for _ in range(int(rl())):
		n = int(rl())
		a = [int(x) for x in rl().split()]

		dp = [[1] * 2 for _ in range(n)]

		for i in range(n - 2, -1, -1):
			if a[i] <= a[i + 1]:
				dp[i
<PREDICTION>
: 1(a[):	 sum[=:
  print A>2==0:
   print(0//K)
  else:
   print(1)
 else:
  print(1)
 =int(input())
for i in range(0):
 N,K=K=list(map(int,input().split()))
 A=list(map(int,input().split()))
::K]
 B=N+K)N
 if=list-sum(A)
 if B>0:
  print A%K==0:
   print(B//K)
  else:
   print(-1)
 else:
  print(1)
 =C=list(map(int,input().split()))

for=list
B i in range(R):
 AA,list(map(int,input().split()))
	B.append(p)
B=n= list(A), len(B[0])
if i in range(m):
	if A[i][0]% m:
		A j in range(n):[i][j] == 1
	else	
	 i in range(n):
	if = = 0(A[j][j] for i in range(m))
	if Ant > m: cnt:
		print i in range(m): A[i][j] ^= 1
	
for(A(A(".join(map(str,A))))i]))) int) for i in range(m)))
for main():
	R sys import stdin, stdout
	import = stdin.readline
	
	for _ in range(int(rl())):
		n, int(rl())
		a = listint(i) for x in rl().split()]
	
		b = [[0]* n for _ in range(n)]
	
		for i in range(n): 1): -1, -1):
			for a[i] == 0[i + 1]:
				dp[i][
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 15500
----------------------------------------------------------------------------------------------------
<INPUT>
: 			else: A.append(sign*numb); numb = 0.0; sign = 1.0
		if s and s[-1] >= b'0'[0]: A.append(sign*numb)
		return A
	def readufloat(self):
		conv = ord if py2 else lambda x:x
		s = sys.stdin.read().replace(b'\r',b'')
		A = []; numb = 0.0
		for i in range(len(s)):
			if s[i] >= b'0'[0]: numb = 10.0*numb + conv(s[i])-48.0
			else: A.append(numb); numb = 0.0
		if s and s[-1] >= b'0'[0]: A.append(numb)
		return A

class FastO(IOBase):
	def __init__(self, fd=1):
		stream = BytesIO()
		self.flush = lambda: os.write(1, stream.getvalue()) and not stream.truncate(0) and stream.seek(0)
		self.write = stream.write if py2 else lambda s: stream.write(s.encode())

sys.stdin, sys.stdout = FastI(), FastO()
input = sys.stdin.readline

big = 3E12

class segheap:
	def __init__(self,data):
		n = len(data)
		m = 1
		while m<n:m*=2
		self.n = n
		self.m = m

		self.data = [big]*(2*m)
		for i in range(n):
			self.data[i+m] = data[i]
		for i in reversed(range(m)):
			self.data[i] = min(self.data[2*i],self.data[2*i+1])

	def mini(self):
		i = 1
		while i<self.
<PREDICTION>
: 			:
[append(i)())
 = A
0

 = 0.0;			 len[ s[01] == s:0': and0]: A.append(sign*numb);
		if A
		 find(((self,
		return = 0 if ord2 else ord x: x[		return = self.stdin.readlinesplit(',int\w', '))
		return = [ sign = 0
0
		for i in range(len(s)):
			if s[i] == b'0'[0]: A += i*0
iumb + int(s[i])
b
0
			el: A.append(signumb); sign = 0.0
		return s[ s[-1] >= b'0'[0]: sign.append(signumb);
		return A
	def SolutionO(objectBase):
	def __init__(self, filed=0):
		self = BytesIO()
		self.buffer = os: os.write(1, stream.getvalue()) and not stream.truncate()0) and stream.seek(0)
		self.write = lambda.write if py2 else lambda s: stream.write(s.encode("

sys.stdin, sys.stdout = II(), FastO()
input = sys.stdin.readline

def = 2E12

class segheap:
	def __init__(self,data):
		self = len(data)
		m = 2
		while m<n:m *=2
		self.n = m
		self.m = m
	defself.data = [big]*(2*m)
		for i in range(m):
			self.data[i+m] = data[i]
		for i in range(range(m)):
			self.data[i] = min(self.data[2*i],self.data[2*i+1])

	def __(self):
		""" = 1
		while i<self.m
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 16000
----------------------------------------------------------------------------------------------------
<INPUT>
:  of tourist spots in Chefland.
Each of the he next N - 1 lines contains three space separated integers u, v, c, denoting that there is a road between tourist spot u and v which has a toll tax of c Rs.

-----Output-----
Output a single line containing the expected toll tax a tourist has to pay for visiting all the N spots after the construction of new road. Your answer will be considered correct if it has an absolute error less than or equal to 1e-2.

-----Constraints-----
- 2 ≤ N ≤ 105
- 1 ≤ u, v ≤ N
- 0 ≤ c ≤ 106

-----Example-----
Input:
3
1 2 3
1 3 2

Output:
2.333333

-----Explanation-----
Assume that the citizens construct the high class road between city 1 and 2. A tourist can visit all the places by just paying a toll tax of 2 Rs.
If the high class road is constructed between city 1 and 3. All the places then can be visited by just paying a toll tax of 3 Rs.
If the cities 2 and 3 are connected by the high class road. All the places can be visited by paying a toll tax of 2Rs. 
Hence expected Rs. that a tourist has to pay in toll tax will be (2 + 3 + 2) / 3 = 7 / 3 = 2.333333Chef Vivek is good in mathematics and likes solving problems on prime numbers. One day his friend Jatin told him about Victory numbers. Victory number can be defined as a number formed after summing up all the prime numbers till given number n. Now, chef Vivek who is very fond of solving questions on prime numbers got busy in some other tasks. Your task is to help him finding victory number.

-----Input:-----
- First line will contain $T$, number of test cases. Then the test cases follow. 
- Each test case contains of a single line of input $N$ till which sum of all prime numbers between 1 to n has to be calculated.

-----Output:-----
For each test case, output in a single line answer to the victory number.

-----Constraints-----
- $1 <= T <= 1000$
- $1 <= N <= 10^6$

-----Sample Input:-----
3
22
13
10

-----Sample Output:-----
<PREDICTION>
:  the.. the's.

 of the following wants two lines the lines contains a integers separated integers A and v and l and doting the the is no pair between the.. and v. is the road.. the..

-----Output-----
Print the single line containing the maximum number.. single. a be to each the the cities-. each i. theline.
 output will be considered correct if its is no answer or, than or equal to the..1.

-----Constraints-----
 - 1 \ N ≤ 10
- 1 ≤ c ≤ v ≤ N
- 1 ≤ c, N
------Example-----
Input:
3
1 2

1 3

1Output:
1
13333
1-----Explanation-----
Exampleume that the following is the road and,. the 1 and city.
 city is be all the following. any the the new.. city..

 the total classges between not, city 1 and 2. A cities'] by to be used to the on a single. of 2 Rs.
If the current are and 3, connected, just second class,,
 the integers then be visited by just a600 or of 2 Rs.

Ifint of to.
 the new is a be only the. by be visited1, 1 + 3 + and 2. 1. 3 = 7.
3333.f is isat a. the. he to the. the numbers. He day, friends has. has, and his.. He, of be written by a positive of by each of number to the numbers numbers. the...
 he he is the is wants to good and his this. the numbers. a and this order days.
 task is to help him to the if of

-----Input----------
- First- will contain $T$, number of testcases. Then the test cases follow. 
- Each test case contains a a single line of input,N$
 $ theming N the numbers. 1 and N. exactly be equal.

-----Output:-----
For each test case, output in a single line containing. the number number.

-----Constraints-----
- $1 \ T \ 1000$
- $1 \ N <= 1000^5$
------Sub Input:-----
1
1





-----Sample Output:-----

----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 16500
----------------------------------------------------------------------------------------------------
<INPUT>
: 	 # the numbers that can be reached by rolling i dice
		#	 for num in range(i, min(i * f, target) + 1):
		#		 for diceNum in range(1, (f + 1)):
		#			 if num - diceNum >= 1:
		#				 dp[i][num] += dp[i - 1][num - diceNum]
		#			 else:
		#				 break
		# return dp[d][target] % mod

class Solution:
	# Recursive memoized solution
	def numRollsToTarget(self, d: int, f: int, target: int) -> int:
		memo = {}
		def num_rolls_util(level, target):
			if level * f < target or target < level:
				return 0
			if level == 0:
				return 1
			
			res = 0
			for i in range(max(0, target - f), target):
				if (level-1, i) in memo:
					res += memo[(level-1, i)]
				else:
					tmp = num_rolls_util(level - 1, i)
					memo[(level-1, i)] = tmp
					res += tmp

			return res % (10 ** 9 + 7)
		
		return num_rolls_util(d, target)class Solution:
	def numRollsToTarget(self, d: int, f: int, target: int) -> int:
		dp=[[0 for _ in range(target+1)] for _ in range(d+1)]
		for i in range(1,min(f+1, target+1)):
			dp[1][i]=1
		for i in range(1, d+1):
			for j in range(2, target+1):
				for k in range(1,f+1):
		
<PREDICTION>
: 		 first of can be used the the the-
			 then	 js range(1+ j(n + 2, f + + 1):
		#		 if j in in range(1, ftarget + 1) +
		#			 if num == targetNum * f:
		#				 continuep[i][j] = dp[i - 1][num - 1Num]
		#				:
		#				 d
		#	 dp[-][target] % (class	 Solution:
	def defursive dized solution
	def numRollsToTarget(self, d: int, f: int, target: int) -> int:
		dpo = {}
		def dRollrolls(dp(n, target):
			if level == f < target: level < level:
				return 0
			if level == 0:
				return 1
			if			if = 0
			for i in range(level(0, target - level), target +
				if levellevel -i) i) in memo:
					res += memo[(level-1, i)]
				else:
					res = num_rolls_util(level- 1, i)
					ifo[(level-1, i)] = tmp
					mem += memo
			mem res % (10** 9 + 7)
		
		return num_rolls_util(0, target)class Solution:
	def numRollsToTarget(self, d: int, f: int, target: int) -> int:
		mem =[[0 for _ in range(d+1)] for _ in range(d)]1)]
		dp i in range(1,d(1+1,target+1)):
			dp[i][i]=1
			 j in range(2,d+1):
			for j in range(1, min+1):
				for k in range(1, min+1):
			
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 17000
----------------------------------------------------------------------------------------------------
<INPUT>
:  v = v, u
  H, M = h[u] - h[v], m[v] - m[u]#M * t < H
  if M > 0 : r = min(floorm(H, M), r)
  elif M < 0 : l = max(ceilp(H, M), l)
  elif H <= 0 : return -1, -1
  if l > r : return -1, -1
 return l, r
def printerval(l, r) :
 if r == 1234567890 : r = "Inf"
 print(l, r)

def doit() :
 n, h, m, a, t, al, ar = int(input()), [], [], [], [0], [], []
 for i in range(n) :
  h += [0]; m += [0]; a += [0]
 for i in range(n) :
  h[i], m[i] = list(map(int, input().split()))
 if n == 1 :
  print(1)
  print("0 Inf")
  return
 l1, r1 = calc(h, m, 1)
 l2, r2 = calc(h, m, 0)
 if l1 != -1 and l2 != -1 :
  if l1 > l2 : l1, l2, r1, r2 = l2, l1, r2, r1
  if r1 + 1 == l2 :
   print(1)
   printerval(l1, r2)
  else :
   print(2)
   printerval(l1, r1)
   printerval(l2, r2)
 elif l1 != -1 :
  print(1)
  printerval(l1, r1)
 elif l2 != -1 :
  print(1)
  printerval(l2, r2)
 else : print(0)

for cas in range(int(input())) : doit()import math
def calc(h, m, f) :
 l, r = 0, 1234567890
 for i in range(len(h) - 1) :
<PREDICTION>
:  in (
 v
	 if[ W = list,0]
 h[v] u[v] - m[u]

 = (( t
  if u < 0:
 = M(mord(u, M) u)
  ifif M < 0 : r = min(floil((H / M), l)
  elif M < M : r 01
 -1
  el M < 0 : return -1, -1
  r, r

 main((u, r, : return return l > 0456790 : return = min0"
 return(r) r)
defdef __(( :
 if, m, m = m, b = a = t, [(input()), list], [], [], [],, [0 [
 for i in range(n) :
  l, listint] m += [0]; m += [0]
  i in range(n) :
  if +=i] m[i], = list(map(int, input().split()))
  ( == 33 :
  print(0,
  return( ".")")
  return
 if = = r1, 0(l, m) n)
 l2, r2 = calc(h, m, 1)
 l l1 == r1 : r2 != -1 :
  print l1 < l2 :
1 = l2 = l1 = l2 = l2, l1, l1
 l1
  if l1 != l < -2 : l   print(0)
   return =(l1, r1)
  el :
   print(-0)
   returnval(l1, r1)
  
val(l2, r2)
 if n1 == -1 :
  if(2)
  printval(l1, r1)
 if l1 != -1 :
  print(2)
  printval(l1, r2)
 el :
(2)
 def _ in range(int(input()))) :
it()
 sys
def do(l, m, a): :
 if = r = 0, 0456790
 if i in range(n(h)): 1) :

----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 17000
----------------------------------------------------------------------------------------------------
<INPUT>
: )]


A_median = statistics.median(A)
B_median = statistics.median(B)
if N%2==0:
	print(int((B_median-A_median)*2)+1)
else:
	print(B_median-A_median+1)n = int(input())
a = [int(i) for i in input().split()]


# print(n)
# print(a)

sort_a = sorted(a, reverse=True)
# print(sort_a)

now_list = []
next_insert = []
comfort = []
# print('start')
for index, i in enumerate(sort_a):
	if len(now_list) == 0:
		now_list += [i]
		next_insert += [1]
		comfort += [i]
	else:
		if len(next_insert) >= n:
			break
		else:
			next_insert += [1, 1]
			comfort += [i, i]


# print(comfort, next_insert)
print((sum(comfort[:n-1])))
n = int(input())
a = list(map(int,input().split()))
a = sorted(a,reverse = True)
ans = 0
if n%2 == 0:
	for i in range(n//2):
		if i == 0:
			ans += a[i]
			continue
		ans += a[i]*2
else:
	for i in range(n//2+1):
		if i == 0:
			ans += a[i]
			continue
		ans += a[i]*2
if n %2== 1:
	ans -= a[i]
print(ans)def chat_in_a_circle():
	N = int(input())
	A = list(map(int,input().split()))
	A.sort()
	res = A.pop(-1)
	t = len(A) % 2 == 0
	a = 0
	for i
<PREDICTION>
: 
	def =listian = A()median(A_
B_median = (.median(B)

 A ==2 ==1:
	print(N(N_median-B_median))B))1)
else:
	print(int_median-A_median)B)
 = int(input())
a = listint(x) for i in input().split()]

defprint(a)

 print(a)
## =a = 0(a) reverse=True)

 print(sort_a)
## =sum = []
for_list = []
next = []
for print(next_
for i, i in enumerate(a_a):
	if i(i_list) < 0:
		now_list. [i]
	elsenext_insert. [i]
	elsenext. [i]
	else:
		now len(next_insert) == 1:
			break
		else:
			next_insert. [i] i]
			next += [i] 1]
	# print(now) now_insert)
#(*(next))):n]1])))
# = int(input())
a = [(map(int, input().split()))
b. sorted(a) reverse= True)
b = 0
for n%2== 0:
	ans i in range(n):2):
		if a% n:
			ans += a[i]
		elsebreak
		else += a[i]
a
	:
	for i in range(n//2):1):
		if i == n:
			ans += a[i]*			continue
		else += a[i]*2
	 n% 2 ==1:
	ans += a[n]*print(ans)
 main(input_int(b():
	n = int(input())
	A = list(map(int, input().split()))
	A.sort()
	A = 0[count()1)
	for = A(A)
 2
 1
	for = A
	for i in
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 17500
----------------------------------------------------------------------------------------------------
<INPUT>
: #F = F.tolist()
	#X = X.tolist()
	#Y = Y.tolist()
	#DX = DX.tolist()
	#DY = DY.tolist()

	LenX = len(X)
	LenY = len(Y)

	visit = [[False] * LenY for _ in range(LenX)]
	visit[x][y] = True
	area = 0
	queue = [(x, y)]

	LineX = [[False] * LenY for _ in range(LenX)]
	LineY = [[False] * LenY for _ in range(LenX)]

	for x1, x2, y in zip(A, B, C):
		for x in range(x1, x2):
			LineY[x][y] = True

	for x, y1, y2 in zip(D, E, F):
		for y in range(y1, y2):
			LineX[x][y] = True

	LenX -= 1
	LenY -= 1
	
	while queue:
		x, y = queue.pop()
		
		if x == 0 or x == LenX or y == 0 or y == LenY:
			area = 0
			break
		
		area += DX[x] * DY[y]
		
		x1 = x - 1
		if not LineX[x][y] and not visit[x1][y]:
			visit[x1][y] = True
			queue.append((x1, y))
		y1 = y - 1
		if not LineY[x][y] and not visit[x][y1]:
			visit[x][y1] = True
			queue.append((x, y1))
		x1 = x + 1
		if not LineX[x1][y] and not visit[x1][y]:
			visit[x1][y] = True
			queue.append((x1, y))
		y1
<PREDICTION>
:  print = {}.polist()
		F = [.tolist()
	#F = Y.tolist()
	#Z = X.tolist()
	#FY = XY.tolist()
	#X = len(X)
	LenY = len(Y)

	#it = setFalse] * widthY for _ in range(LenX)]
	visit[X][y] = True
	for = 0
	for = [(x, y)]
	whileX = [[False] * 201Y for _ in range(LenX)]

	areaY = [[False] *
 Y for _ in range(LenX)]

	for x,, x2, y in it(X, B): C):
		if y in range(x1, x2):
			ifX[x1y] = True

	for x in y in, y1 in zip(A, E, F):
		if x in range(y1, y2):
			LineY[x][y] = True

	forX = 1
	LenY -= 1
	area	if queue:
		x, y = he.pop()
		if		if x == y or y == 0X or y == 0 or y == 0Y or
			area = 0
			break
		
		area += area[x][

 (Y[y]

		if		if,, x1 y
		y x itX[x][y] or not visit[x][][y]:
			areait[x1][y] = True
			queue.append((x1, y))
			1 = y - 1
		if notedgeY[x][y] and not visit[x1y1]:
			visit[x1y1] = True
			queue.append((x1 y))))
			2 = x - 1
		if not LineY[x][][y] and not visit[x1][y1
			visit[x1][y1 = True
			queue.append((x1, y1
			1 =
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 18000
----------------------------------------------------------------------------------------------------
<INPUT>
: 
			self.dct[key].append((timestamp, value))
		else:
			lo, hi = 0, len(self.dct[key]) - 1
			while lo <= hi:
				mid = (lo + hi) // 2
				if arr[mid][0] < timestamp:
					lo = mid + 1
				else:
					hi = mid - 1
			arr.insert(lo, (timestamp, value))
		return
			
		

	def get(self, key: str, timestamp: int) -> str:
		if key not in self.dct:
			return \"\"
		arr = self.dct[key]
		lo, hi = 0, len(arr) - 1
		while lo <= hi:
			mid = (lo + hi) // 2
			if arr[mid][0] == timestamp:
				return arr[mid][1]
			elif arr[mid][0] > timestamp:
				hi = mid - 1
			else:
				lo = mid + 1
		return arr[hi][1] if hi != -1 else \"\"
				
		


# Your TimeMap object will be instantiated and called as such:
# obj = TimeMap()
# obj.set(key,value,timestamp)
# param_2 = obj.get(key,timestamp)class TimeMap:

	def __init__(self):
		\"\"\"
		Initialize your data structure here.
		\"\"\"
		self.store = {}

	def set(self, key: str, value: str, timestamp: int) -> None:
		if key not in self.store:
			self.store[key] = [(value, timestamp)]
		else:
			self.store[key].append((value, timestamp))
	
	def binarySearch(self, k, t):
		arr = self.store[k]
		i = 0

<PREDICTION>
: 				.parent[[self]append(selfestamp, self))
			:
			self = hi = 0, len(self.dct[key])
 1
			while lo <= hi:
				mid = (lo + hi) // 2
				if self[mid][0] < arr:
					hi = mid + 1
				else:
					hi = mid - 1
			if[append(0, hitimestamp, value))
		return arr	


		

def searchProductself, arr, str, timestamp: int) -> str:
		if key in in self.d::
			return ''\"
		
 = self.dct[key]
		
 = hi = 0, len(arr) - 1
		while lo <= hi:
			mid = (lo + hi) // 2
			if arr[mid][0] < key:
				lo arr[mid][1]
			elif arr[mid][0] < timestamp:
				hi = mid - 1
			else:
				lo = mid + 1
		return \"[lo][0]
 arr == 01 else \"\"
		


			
# Your TimeMap object will be instantiated and called as such:
# obj = TimeMap()
# obj.set(key,value,timestamp)
# param_2 = obj.get(key,timestamp)class TimeMap:

	def __init__(self):
		\"\"\"
		Initialize your data structure here.
		\"\"\"
		self.d = {}
	def set(self, key: str, value: str, timestamp: int) -> None:
		self key not in self.store:
			self.store[key] = valuevalue, value)]
		else:
			self.store[key]append((value, timestamp))

			def get((self, A: a):
		l = self.store[k]
		
 = 0
	
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 18500
----------------------------------------------------------------------------------------------------
<INPUT>
: 1 <= words[i].length, result.length <= 7
words[i], result contains only upper case English letters.
Number of different characters used on the expression is at most 10.Given an array nums and an integer target.
Return the maximum number of non-empty non-overlapping subarrays such that the sum of values in each subarray is equal to target.
 
Example 1:
Input: nums = [1,1,1,1,1], target = 2
Output: 2
Explanation: There are 2 non-overlapping subarrays [1,1,1,1,1] with sum equals to target(2).

Example 2:
Input: nums = [-1,3,5,1,4,2,-9], target = 6
Output: 2
Explanation: There are 3 subarrays with sum equal to 6.
([5,1], [4,2], [3,5,1,4,2,-9]) but only the first 2 are non-overlapping.
Example 3:
Input: nums = [-2,6,6,3,5,4,1,2,8], target = 10
Output: 3

Example 4:
Input: nums = [0,0,0], target = 0
Output: 3

 
Constraints:

1 <= nums.length <= 10^5
-10^4 <= nums[i] <= 10^4
0 <= target <= 10^6Think about Zuma Game. You have a row of balls on the table, colored red(R), yellow(Y), blue(B), green(G), and white(W). You also have several balls in your hand.

Each time, you may choose a ball in your hand, and insert it into the row (including the leftmost place and rightmost place). Then, if there is a group of 3 or more balls in the same color touching, remove these balls. Keep doing this until no more balls can be removed.

Find the minimal balls you have to insert to remove all the balls on the table. If you cannot remove all the balls, output -1.


Examples:
Input: "WRRBBW", "RB"
Output: -1
Explanation:
<PREDICTION>
: ] i[i]:length <= 1length[length <=<=len
	[i] result[<ains  ofcase English letters.

  lower letters in in the string of the most 10the letters
 a array ofs, an array k,

 the sum possible of moves-negative subsequn-emptylapping substringsays. that the sum of the of the subarr is equal to the.

Example 1:
Input: nums = [1,2,2,1,1, target = [
Output: 2
Explanation: We are no sub-emptylapping subarrays:1,2,1,1,1, and 2 2 to target.1)

Example 2:
Input: nums = [1,1,1,1,1,5],3, target = 2
Output: 2
Explanation: There are 2 nonarrays [ sum equal to target.

1,5, [5,1], [5,1,1],1],1],1],
 we sub sum sub sub the-overlapping sub

 3:
Input: nums = [1,3,1,1,1,1,5,1,2, target = 6
Output: 2
ExExample 4:
Input: nums = [1,1,0, target = 2
Output: 0
 
Constraints:

1 <= nums.length <= 10010^5
110^9 <= nums[i] <= 1010^4
1 <= num <= 10^4

 the...
 are to string of the. the grid. and, andi, and(R) blue(R) blue(R) blue blue(R)
 can have to the to the table.
TheYou row, you can assume a row with the table. and you it to a ball and1 a rowmost one). themost place).
, you you are a ball of balls, not balls in the row row, the you it balls from
, that game you more balls to't represented.

You the minimum number that can to win the the the the balls. the table.

 there can remove any the balls to return -1.


Example:

: balls1",""" "RR
Output: "1
Inputplanation:

----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 19000
----------------------------------------------------------------------------------------------------
<INPUT>
:  in self.prime_numbers:
	  if p > border: break
	  while n % p == 0: res[p] = res.get(p, 0)+1; n //= p
	  if n == 1: return res
	res[n] = 1; return res

  def prime_factorize_factorial(self, n):
	res = dict()
	for i in range(2, n+1):
	  for p, c in self.prime_factorize(i).items(): res[p] = res.get(p, 0)+c
	return res
  
  @staticmethod
  def gcd(a, b): return gcd(b, a%b) if b else abs(a)

  @staticmethod
  def lcm(a, b): return abs(a // gcd(a, b) * b)

  @staticmethod
  def find_divisors(n):
	divisors = []
	for i in range(1, int(n**.5)+1):
	  if n%i: continue
	  divisors.append(i)
	  j = n // i
	  if j != i: divisors.append(j)
	return divisors
  
  @staticmethod
  def base_convert(n, b):
	if not n: return [0]
	res = []
	while n:
	  n, r = divmod(n, b)
	  if r < 0: n += 1; r -= b
	  res.append(r)
	return res


class UnionFind():
  def __init__(self, n=10**6):
	self.root = list(range(n))
	self.height = [0] * n 
	self.size = [1] * n 
  
  def find_root(self, u):
	if self.root[u] == u: return u
	self.root[u] = self.find_root(self.root[u])
	return self.root[u]
  
  def unite(self, u, v):
	ru = self.find
<PREDICTION>
:  range.d[factumbers:
		 self self not self:

	  if p % p == 0: n.p] = res[get(p, 0)1
 n //= p
	  if n > 1: break res
	  =p] = res
 return res
  def prime_factize(factorial(self, n):
	res = []()
	for i in range(2, n+1):
	  res p in c in self.prime_nize(i).items():
[p] = res.get(p, 0)+c
	return res
  
  defstaticmethod
  def gcd(a, b): return gcd(b, a%b) if b else g(a)
  defstaticmethod
  def lcm(a, b): return g(a) gcd(a, b) * b)

  @staticmethod
  def l_primeisors(n):
	divisors = []
	for i in range(1, int(n**05)+1):
	  if n %i==

	  divisors.append(i)
	  i = i // i
	  if j != i: divisors.append(j)
	return divisors
  
  @staticmethod
  def g_divvert(n): k): return	return n n: return 00]
	return = []
	for n:
	  res // r = divmod(n, b)
	  res r == 0: res, 1
 res += 1
	  res.append(r)
	return res
 class UnionFind():
  def __init__(self, n):0**6):
	self.parent = list(range(n))
	self.size = [0] * n

	self.size = [0] * n

	 def
  def find(root(self, x):
	if self.root[u] != u:
 u
	self.root[u] = self.find_root(self.root[u])
	return self.root[u]
  
  def unite(self, u, v):
	root = self.find_
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 19500
----------------------------------------------------------------------------------------------------
<INPUT>
: 
		return s

	# i番目の要素にxを足す
	# 覆ってる区間すべてに足す
	def add(self, i, x):
		while i <= self.max:
			self.data[i] += x
			i += i & -i

	def insert(self, x):
		self.add(x, 1)

	def delete(self, x):
		self.add(x, -1)

	def count(self, x):
		return self.query_sum(x) - self.query_sum(x-1)
	
	def length(self):
		return self.query_sum(self.max)
	
	# 下からc番目(0-indexed)の数
	# O(log(N))
	def search(self, c):
		c += 1
		s = 0
		ind = 0
		l = self.max.bit_length()
		for i in reversed(range(l)):
			if ind + (1<<i) <= self.max:
				if s + self.data[ind+(1<<i)] < c:
					s += self.data[ind+(1<<i)]
					ind += (1<<i)
		if ind == self.max:
			return False
		return ind + 1
	
	def bisect_right(self, x):
		return self.query_sum(x)

	def bisect_left(self, x):
		if x == 1:
			return 0
		return self.query_sum(x-1)

	# listみたいに表示
	def display(self):
		print('inside BIT:', end=' ')
		for x in range(1, self.max+1):
			if self.count(x):
				c = self.count(x)
				for _
<PREDICTION>
: 			 ans[	defprint =�目の�要素��を樳する	# i���たいの�間にる�てのx��す
	# get(self,x, x):
		# i <= self.n_
			self.max[i] += x
			i += i & -i

	# get(self, i):
		self.data(x) 1)
	def get(self, x):
		self.add(x, -x)

	def get(self): x):
		return self.count(search(x)

 self.query_sum(self)1)

	
	def add(self):
		return self.data_sum(self.datasize

	
	def �亡のらのの�目のi)index))の��を	def (nNn))
	def query(self, x,
		# = self
		if = 0
		for = 0
		while = len.query
index_length()
		while i in range(list(l)):
			if s == ic <<i) <= c.max:
				s s == i.max[ind]1<<i) <= c:
					s += self.query[ind]1<<i)]
					ind += (1<<i)
			 s == len.max:
			return s
		return True == (
	
	# addect_left(self, x):
		while x.query_sum(x) -	def bisect_left(self, x):
		while x == self:
			return self
		return self.query_sum(x)1)
	def a�ないな、�す��す	def bis(self):
		for(Yes')') {} self=' ')
		print i in range(self, self.n):1):
			print x.query(x)
				print = self.query(x)
				if i in
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 20000
----------------------------------------------------------------------------------------------------
<INPUT>
: .

 You are a member of the “Conservative Party” and you party is trying to pass a bill. The “Reformist Party” is trying to block it.

 In order for a bill to pass, it must have a majority vote, meaning that more than half of all members must approve of a bill before it is passed . The "Conservatives" and "Reformists" always vote the same as other members of thier parties, meaning that all the members of each party will all vote yes, or all vote no .

 However, independants vote individually, and the independant vote is often the determining factor as to whether a bill gets passed or not.

 Your task is to find the minimum number of independents that have to vote for your party's (the Conservative Party's) bill so that it is passed .

 In each test case the makeup of the Parliament will be different . In some cases your party may make up the majority of parliament, and in others it may make up the minority. If your party is the majority, you may find that you do not neeed any independants to vote in favor of your bill in order for it to pass . If your party is the minority, it may be possible that there are not enough independants for your bill to be passed . If it is impossible for your bill to pass, return `-1`.

# Input/Output


 - `[input]` integer `totalMembers`

  The total number of members.


 - `[input]` integer `conservativePartyMembers`

  The number of members in the Conservative Party.


 - `[input]` integer `reformistPartyMembers`

  The number of members in the Reformist Party.

 
 - `[output]` an integer

  The minimum number of independent members that have to vote as you wish so that the bill is passed, or `-1` if you can't pass it anyway.
  
# Example

 For `n = 8, m = 3 and k = 3`, the output should be `2`.
 
 It means: 
 ```
 Conservative Party member --> 3
 Reformist Party member   --> 3
 the independent members --> 8 - 3 - 3 = 2
 If 2 independent members change their minds
 3 + 2 > 3
 the bill will be passed.
 If 1 independent members change their minds
 perhaps the bill will be failed

<PREDICTION>
: append
 have given sequence of the year�AC�” and the want. a to find the game of
 i�tedally.” and going to find all.

 this to the given you the the you is be a number of. so that the than one of the the of be. the number. the is a.
 otherI"" is "Cformist" is is. " one the.. theol.. but that you the elements should the type is be be.. but there the are more

, you the of.. that you " that of. passed present same of. the the the number is the to not.

 task is to find the minimum number of operations that you the be in the help. answeror number of). code

 is that the is impossible.


 this of case, type of the type of be given from

 each case the solution will be the to " of the. so the the.. make up the only of
 the friends is given same of you want make the the are not needig. of.. the. the. the house. the to your. be the
 you friends is the only of you is make able to you is to enough money.. the friends in pass given.
 your is the to your friends is be the you -{1`.


# Task/Output


 - `[input]` integer `[``

   number number of operations of

 - - `[output]` integer `total```

  The total of the. the type of,


 - `[output]` integer `countpred```

  The number of members in the same will of.


  - `[input]` an integer `  The number number of members operations. have to be for a will.. you answer will the. so `[1`. if you want be make the..



 - Example

 For `a = 4`, m = 6`, n = 5 and the output should be `-`.

 
 -'s that

 `
 er

 
 ` = --> -->   4
  following cases
 4
 5 - 5 - 5
  you is members --> --> result the `` 5 3 = 3
  current will be ` as

 the < members will the't
 - will type will be passed,

----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 20500
----------------------------------------------------------------------------------------------------
<INPUT>
: a[i])
		p4.append(b[i])

for p in (p1, p2, p3, p4):
	if len(set(p)) == n:
		print(' '.join(str(x) for x in p))
		return

for p in (p1, p2, p3, p4):
	if len(set(p)) == n - 1:
		distinct = 0
		dpos = 0
		for i, (x, y) in enumerate(zip(p, a)):
			if x != y:
				distinct += 1
				dpos = i
		if distinct == 1:
			unused = 1
			while unused in p:
				unused += 1
			pp = list(p)
			pp[dpos] = unused
			print(' '.join(str(x) for x in pp))
			return

assert False
#!/usr/bin/env python3
from sys import stdin, stdout

def rint():
	return list(map(int, stdin.readline().split()))
#lines = stdin.readlines()


n = int(input())

a = list(rint())
b = list(rint())

ii = []
for i in range(n):
	if a[i] != b[i]:
		ii.append(i)

if len(ii) == 2:
	if a[ii[0]] != a[ii[1]]:
		c = a[:]
	else:
		c = b[:]
	if c.count(c[ii[0]]) == 2:
		iii = ii[0]
	else:
		iii = ii[1]
else:
	c = a[:]
	iii = ii[0]


for i in range(n):
	if not i+1 in c:
		c[iii] = i+1
		print(*c)
		return

n = int(input())
a = list(map
<PREDICTION>
: [i]
			 = =append(a[i])
	for i in pp1, p2): p3): p4):
	print a(p(p)) == 1:
		print('YESjoin(p(i) for x in p))
		return

print p in pp1, p2, p3, p4):
	if len(set(p)) == n: 1:
		print = = set
		for = = set
		for i in aa, y) in enumerate(p(p1 p[):
			dist x == p:
				distinct += 1
				distpos += (
			 len == n:
			printite[ True
			break d < d:
				ifused += 1
				 = p(d.
			if.0pos] = set
			if( '.join(map(x) for x in p))
			return

for(

!/usr/bin/env python3

 collections import stdin, stdout

def rint():
	return list(map(int, stdin.readline().split()))

lines = stdin.readlines()

def, int(input())
aa = list(rint())

 = list(rint())

for = 0

 i in range(n):
	ii a[i] == 0[i]:
		ii.append(i)

for len(ii) == 1:
	print len[0[0]] != a[ii[1]:]:
		print = ii[ii
		:
		c = a[ii
	
 c ==count(c)0[0]]) == 1:
		print. c[0]
		:
		c = ii[1]

:
	print = a[ii
	if = ii[1]

for i in range(1):
	if c c in1 in ii:
		ii.ii] = c
1

elseii('c)
		break

 = int(input())
a = list(map(
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 21000
----------------------------------------------------------------------------------------------------
<INPUT>
: **9
  tmp = (min_val+max_val)//2
  prev_price = 0
  
  while 1:
	price = A*tmp + B*len(str(tmp))
	if price == prev_price:
	  print(tmp)
	  break
	
	if price < X:
	  min_val = tmp
	  tmp = (min_val+max_val)//2
	elif price > X:
	  max_val = tmp
	  tmp = (min_val+max_val)//2
	else:
	  print(tmp)
	  break
	prev_price = priceimport math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time, copy

sys.setrecursionlimit(10**7)
inf = 10**20
mod = 10**9 + 7

stdin = sys.stdin

ni = lambda: int(ns())
na = lambda: list(map(int, stdin.readline().split()))
ns = lambda: stdin.readline().rstrip()  # ignore trailing spaces

A, B, X = na()
ans = 0
for dn in range(18 + 1):
	s = X - dn * B
	tmp = s // A
	N = min(tmp, 10**9)
	if len(str(N)) == dn:
		ans = max(ans, N)
	else:
		t = 10 ** dn - 1
		if N >= t:
			ans = max(ans, t)
print(min(ans, 10 ** 9))H,W,K=map(int,input().split())
P=[]
for i in range(H):
	s=input()
	a=[]
	for j in range(W):
		a.append(s[j])
	P.append(a)
	
ans=0
for markR in range(2**H):
	for markC in range(2**W):
		black=0
		for i in range(H):
			for
<PREDICTION>
: (+	
 = 0tmp(value,tmp_val)%2
  if =val = tmp
  for
  for tmp:
	if += min[tmp
 min*tmp(A(price))
	tmp price > 0_price:
	  prev(tmp)
	  break
	else	if price == 0:
	  prev_price = price
	  min = 0min_val +max_val)//2
	 if price == X:
	  min_val = tmp
	  tmp = (max_val+max_val)//2
	 :
	  min(tmp)
	  min
	
_price = tmp
 sys
string,itertools,fractions,heapq,collections,re,array,bisect
sys,random,time, copy,#sys.setrecursionlimit(10**7)
inf = 10**20
mod = 10**9+ 7

defin = sys.stdin

ni = lambda: int(ns())
n = lambda: list(map(int, stdin.readline().split()))
na = lambda: stdin.readline().rstrip()  # ignore trailing spaces

N,B = C = na()
A = 0
for i in in range(1): 1):
	ans = 0 * dn
 (
	ans = 0 * d
	ans = min(N, N **9)
	ans tmp(s(tmp)) >= 0n:
		ans += tmp(ans, tmp)
		:
		ans = N** 9n
 1
		tmp len == d:
			ans = max(ans, t)
	(ans(ans, A** 9))
, W,A =map(int,input().split())
A=10
for i in range(H):
 p=input()
	if=s
	for j in range(W):
		if.append(int[j])
	P.append(a)


ans=0
for i in in range(1**H):
	for iL in range(2**W):
		if=0
		for i in range(H):
			if j
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 21500
----------------------------------------------------------------------------------------------------
<INPUT>
: 	if c not in p: p[c] = {}
				p = p[c]
			p['#'] = w
		self.p = [self.trie]

	def query(self, letter: str) -> bool:
		self.history+=letter
		self.p = [p[letter] for p in self.p if letter in p]
		res = any(['#' in p for p in self.p])
		self.p+=[self.trie]
		return res

# Your StreamChecker object will be instantiated and called as such:
# obj = StreamChecker(words)
# param_1 = obj.query(letter)
class StreamChecker:

	def __init__(self, words: List[str]):
		self.trie = {}
		self.waitlist = []
		for word in words:
			head = self.trie
			for char in word:
				if char not in head:
					head[char] = {}
				head = head[char]
			head['#'] = '#'

	def query(self, letter: str) -> bool:
		waitlist = []
		# if letter can be the prefix of word
		if letter in self.trie:
			waitlist.append(self.trie[letter])
		# for each possible prefix, append letter if the new substr still can be a prefix
		for item in self.waitlist:
			if letter in item:
				waitlist.append(item[letter])
				
		self.waitlist = waitlist
		return any('#' in item for item in self.waitlist)


# Your StreamChecker object will be instantiated and called as such:
# obj = StreamChecker(words)
# param_1 = obj.query(letter) 
class StreamChecker:

	def __init__(self, words: List[str]):
		self.words = set(words)
		self.query_history = \"\"
<PREDICTION>
: 	 int in d:
[c] = p
		ppp[ p[c]
				[a'] = '
			.p = pw.prie]
	def insert(self, letter: str) -> bool:
		self.p +=letter
		p.p = [self[letter] for letter in self.p] letter in p]
		return = False(self#'] in p] p in self.p])
		return.p ==[self.trie]
		return any

# Your StreamChecker object will be instantiated and called as such:
# obj = StreamChecker(words)
# param_1 = obj.query(letter)
class StreamChecker:

	def __init__(self, words: List[str]):
		self.trie = {}
		for.words = = []
		for w in words:
			node = self.trie
			for ch in word:
				if char not in head:
					head[char] = {}
				head = head[char]
			head['$'] = {}#'
	def query(self, letter: str) -> bool:
		selflist = []
		for self letter in be the prefix of the
		# letter in self.trie:
			waitlist.append(self.trie[letter])
			 for l in prefix
 append the if the current
 still can be a prefix
		# i in self.waitlist:
			if letter in item:
				waitlist.append(item[letter])
		self	
		self.waitlist =waitlist
		return any(#' in p for item in self.waitlist)

# Your StreamChecker object will be instantiated and called as such:
# obj = StreamChecker(words)
# param_1 = obj.query(letter)

class StreamChecker:

	def __init__(self, words: List[str]):
		self.t = set(words)
		self.t =word = \"\"

----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 22000
----------------------------------------------------------------------------------------------------
<INPUT>
:  - a[0]
fl = True
for i in range(2,n):
	cd = a[i] - a[i-1]
	if d != cd:
		fl = False
		break
	
if fl:
	print(a[n-1] + d)
else:
	print(a[n-1])
def weatom(s=[]):
	n=len(s)
	if(n==1):
		return s[0]
	elif(n==2):
		return (s[1] + (s[1]-s[0]))
	else:
		d=s[1]-s[0]
		for i in range(2,n):
			if((s[i]-s[i-1])==d):
				if(i==n-1):
					return (s[i] + d)
			else:
				return s[n-1]
		   

def main():
	t=input()
	t=int(t)
	s=[int(x) for x in input().strip().split()]
	print(weatom(s))
	
def __starting_point():
	main()
__starting_point()import sys
input = sys.stdin.readline

n=int(input())
E=[list(map(int,input().split())) for i in range(n-1)]

D=[0]*n

for x,y in E:
	D[x-1]+=1
	D[y-1]+=1

if 2 in D:
	print("NO")
else:
	print("YES")
n = int(input())
adj = [[] for i in range(n)]
for _ in range(n-1):
  u, v = map(int, input().split())
  adj[u-1].append(v)
  adj[v-1].append(u)

for v in adj:
  if len(v) == 2:
	print('NO')
	break
else:
  print('
<PREDICTION>
:  1[i]
	 = True
for i in range(n, n):
	if = a[i]
 a[i-1]
	ifcdp 0:
		fl = False
		break
ififif fl:
	print("0[0-1]) + 1)
else:
	print(a[n-1]
n main_(a):0):
	if =len(s)
	for sn==1):
		return s
0]
	ifif(n==2):
		return ss[0]* ss[0]1[0])))%	else:
		return=s[0]s[0]
		if i in range(2,n):
			d(d[i]d[i-1])*d):
				d(s==0-1):
					return ss[i] + ()
				:
				d ([i-1] +		return 

	n main():
	n =int()
	for=input(t)
	for=int(i) for x in input().split().split()]
	print(ans())(s))


def __starting_point():
	main()
__starting_point()import sys

 = sys.stdin.readline

n =int(input())
a=[[](map(int,input().split())) for i in range(n)]1)]

E=[0]*n
forfor i,y in E:
	D[x-1]+=1

D[y-1]+=1

D D* D:
	print(YES")
else:
	print("YES")
n = int(input())

 = [[] for i in range(n)]
for i in range(n-1):
	 a,v = map(int, input().split())
  adj[u-1].append(v-
  adj[v-1].append(u)

def i in range[
  if len(adj) == 0:
	print("NO')
 return
else:
  print('YES
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 22500
----------------------------------------------------------------------------------------------------
<INPUT>
: 19

Input
2

Output
28



-----Note-----

The first perfect integer is $19$ and the second one is $28$.Calculate the number of ways to place $n$ rooks on $n \times n$ chessboard so that both following conditions are met:

  each empty cell is under attack;  exactly $k$ pairs of rooks attack each other. 

An empty cell is under attack if there is at least one rook in the same row or at least one rook in the same column. Two rooks attack each other if they share the same row or column, and there are no other rooks between them. For example, there are only two pairs of rooks that attack each other in the following picture:

 [Image] One of the ways to place the rooks for $n = 3$ and $k = 2$ 

Two ways to place the rooks are considered different if there exists at least one cell which is empty in one of the ways but contains a rook in another way.

The answer might be large, so print it modulo $998244353$.


-----Input-----

The only line of the input contains two integers $n$ and $k$ ($1 \le n \le 200000$; $0 \le k \le \frac{n(n - 1)}{2}$).


-----Output-----

Print one integer — the number of ways to place the rooks, taken modulo $998244353$.


-----Examples-----
Input
3 2

Output
6

Input
3 3

Output
0

Input
4 0

Output
24

Input
1337 42

Output
807905441Vasya has got many devices that work on electricity. He's got n supply-line filters to plug the devices, the i-th supply-line filter has a_{i} sockets.

Overall Vasya has got m devices and k electrical sockets in his flat, he can plug the devices or supply-line filters directly. Of course, he can plug the supply-line filter to any other supply-line filter. The device (or the supply-line filter) is considered plugged to electricity if it is either plugged to one of k electrical sockets, or if it is plugged to some supply-line filter that is in turn plugged to electricity.
<PREDICTION>
: ,	def
3

Output
3


-----Note-----

In first example square in 13$, and $ number perfect is $3$
culate the number of distinct to make the3$ ins in the3$times n$ in.. that the of are: met:   $ square cell is a the.  each one1$- of movess on $ other. 

The empty cell is under attack. there is no least one cells the cell cell, the least one cells the same row.
 cellss attack each other, there are a same color or column. they they are no other cellss attack the.
 example, if are no one possible of winners with are the other, the following way:

 Image]  move the $ are place $ firsts on then$ 2$- thek = 3$ (

The the to place the kings for: different if they is a least one king in is in. the move the following. there the singles the example.

You number can be considered, so you the modulo $998244353$.


-----Input-----

The first line of the input contains a integers $n$, and $k$ ($1 \le n \le 10\$,) $1 \le k \le nmin{n}{n - 1)}{2}$)

-----Output-----

Print one integer  the number of ways to place the kings for in inulo $998244353$.


-----Examples-----
Input
3


Output
3

Input
4 3

Output
4

Input
4 3

Output
4

Input
4 4


Output
4







asya has a a different. are is the. He has got a people ofs.. the. i. the i-th of ofline of is a_{i} non.

V theya has got a pieces. he-.. the own. so is't the i. the ofline of.,
 course, he is't the following-linekeys. the of.-line map.
 i ofthe the number ofline map is is the to if the the he is possible on or the of the or or or or not it is not to one of-linemap. is either the the. the the

----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 23000
----------------------------------------------------------------------------------------------------
<INPUT>
:  ', local_len)
	is_possible = False
	diff = abs(x_d - x_l) + abs(y_d - y_l)
	if diff <= local_len and (diff + local_len) % 2 == 0:
		is_possible = True
	# print('\t', x_l, y_l, abs(x_d - x_l), abs(y_d - y_l), local_len, is_possible)
	for i in range(local_len, n):
		if is_possible:
			break
		d_old, d_new = d[s[i]], d[s[i - local_len]]
		x_l, y_l = x_l - d_old[0] + d_new[0], y_l - d_old[1] + d_new[1]
		# print('\t', x_l, y_l, abs(x_d - x_l), abs(y_d - y_l), local_len)
		diff = abs(x_d - x_l) + abs(y_d - y_l)
		if diff <= local_len and (diff + local_len) % 2 == 0:
			is_possible = True
	# print(l, r, local_len, current_sol, is_possible)
	if is_possible:
		current_sol = local_len
		r = local_len - 1
	else:
		l = local_len + 1
print(current_sol)# -*- coding: utf-8 -*-

"""
created by shhuan at 2018/11/3 11:30


search for minimum steps, consider binary search

"""

N = int(input())
ops = [x for x in input()]

X, Y = list(map(int, input().split()))

dd = abs(X) + abs(Y)
lops = len(ops)
# if dd > lops or (lops - dd) % 2 != 0:
#	 print(-1)
#
<PREDICTION>
:  '_count)
		_possible = True
	for = 0(x-p - x_d)
 abs(y_d - y_l)
	if is == 0_len: diffx <= diff_len) % 2 == 0:
		if_possible = True
	ifprint(isn') diff_l, y_l, y(x_d - x_l), abs(y_d - y_l)) abs_len) diff_possible)
	if i in range(1_len): 0):
		if i_possible:
			if
		if =l = d_old = abs_i[i] - d[s[i]] 1_len]]
		if_l, y_l = i_l, 1_old,0],
 abs_old[1] y_l - d_old[1]
 d_old[1]
		if print('xt', x_l, y_l, abs(x_d - x_l), abs(y_d - y_l), abs_len,
		if = abs(x_d - x_l) + abs(y_d - y_l)
		if diff <= local_len and (diff + local_len) % 2 == 0:
			is_possible = True
		 print('x, d, diff_len, diff_len) diff_possible)
	if is_possible:
		print_sol = abs_len
		if_ max_len
 1
		:
		if = local_len
 1
	(r_sol)
 cook*- coding: utf-8 -*-

import

 by shuuan at 2018/10/18
:30


_ _ value to the all search

"""

import = int(input())

 = [0 for x in range().]

def = Y = [(map(int, input().split()))

def = [(X-
 abs(Y)

 = = [(X)

 print dd == ddops: ddddops) dd) % 2 == 0:
#	 print("1)

	
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 23500
----------------------------------------------------------------------------------------------------
<INPUT>
: 
  "/\\",
  "\\/"
]
Output: 5
Explanation: (Recall that because \ characters are escaped, "/\\" refers to /\, and "\\/" refers to \/.)
The 2x2 grid is as follows:



Example 5:
Input:
[
  "//",
  "/ "
]
Output: 3
Explanation: The 2x2 grid is as follows:


 
Note:

1 <= grid.length == grid[0].length <= 30
grid[i][j] is either '/', '\', or ' '.There are N workers.  The i-th worker has a quality[i] and a minimum wage expectation wage[i].
Now we want to hire exactly K workers to form a paid group.  When hiring a group of K workers, we must pay them according to the following rules:

Every worker in the paid group should be paid in the ratio of their quality compared to other workers in the paid group.
Every worker in the paid group must be paid at least their minimum wage expectation.

Return the least amount of money needed to form a paid group satisfying the above conditions.
 



Example 1:
Input: quality = [10,20,5], wage = [70,50,30], K = 2
Output: 105.00000
Explanation: We pay 70 to 0-th worker and 35 to 2-th worker.


Example 2:
Input: quality = [3,1,10,10,1], wage = [4,8,2,2,7], K = 3
Output: 30.66667
Explanation: We pay 4 to 0-th worker, 13.33333 to 2-th and 3-th workers seperately. 

 
Note:

1 <= K <= N <= 10000, where N = quality.length = wage.length
1 <= quality[i] <= 10000
1 <= wage[i] <= 10000
Answers within 10^-5 of the correct answer will be considered correct.Given an equation, represented by words on left side and the result on right side.
You need to check if the equation is solvable under the following rules:

Each character is decoded as one digit (0 - 9).
Every pair of different characters they must map to different digits.
Each
<PREDICTION>
: 
"", '/|",","",
: [[
Explanation: theall that is thetext is not to and",", is, the\\")  "\\" to to /",\

 stringD3 is is [ follows:

 1 1:

: grid
\" x" " "",", 
Output: 4
Explanation:  2x2 grid is as follows:

 " :

1 <= .length <= grid[i].length <= 1000
1[i][j] = the 0' or*0 or '\join is no rows in

 number-th car is a weight ofi][  i worker of...i] 
, can to know the the-in. the a new.. 
 the is worker is the , the need take the to to the group rules:

- worker is the group group is be theed the same group the worker group. the worker group the worker group.

 worker in the worker group should be able by the one sum speed..
ReturnExample the minimum number of worker that to achieve a worker group. the given conditions.
 

ExampleExample 1:

: [ group [],,20,20, K = [10,20,7,init = 5
Output: 2
5
Explanation:  can are and form,1 worker. the- the-th worker.

Example 2:
Input: mass = [10,5,1],5],9], K = [7,1,7,7,2], K = 2
Output: 10
000007
Explanation: We pay to and 0-th worker. and- ., 0-th worker 5-th worker.ats..

 
Note:

1 <= K <= 5
 10
 0 N is 2.length = N.length =1 <= K.i] <= 10000.1 <= K[i] <= 10000
1 integer. the^99
 the i worker. be 10 to.Given an array of return by a, a and of right following of the side.
Return are to find whether you given is nots.( the following rules:
-- letter in representedoded as a of fromi, 1)

 digit of characters characters ( appear be the the..

 digit
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 24000
----------------------------------------------------------------------------------------------------
<INPUT>
: 	if n == 64 :
		return 5
	if n == 65 :
		return 5
	if n == 66 :
		return 4
	if n == 67 :
		return 5
	if n == 68 :
		return 5
	if n == 69 :
		return 5
	if n == 70 :
		return 6
	if n == 71 :
		return 5
	if n == 72 :
		return 4
	if n == 73 :
		return 4
	if n == 74 :
		return 4
	if n == 75 :
		return 4
	if n == 76 :
		return 4
	if n == 77 :
		return 4
	if n == 78 :
		return 4
	if n == 79 :
		return 4
	if n == 80 :
		return 4
	if n == 81 :
		return 5
	if n == 82 :
		return 4
	if n == 83 :
		return 4
	if n == 84 :
		return 4
	if n == 85 :
		return 5
	if n == 86 :
		return 4
	if n == 87 :
		return 4
	if n == 88 :
		return 4
	if n == 89 :
		return 4
	if n == 90 :
		return 5
	if n == 91 :
		return 4
	if n == 92 :
		return 4
	if n == 93 :
		return 4
	if n == 94 :
		return 5
	if n == 95 :
		return 5
	if n == 96 :
		return 4
	if n == 97 :
		return 4
	if n == 98 :
		return 5
	if n == 99 :
		return 5
	if n == 100 :
		return 3
	if n == 101 :
		return 4
	if n == 102 :
		return 4
	if n == 103 :
		return 4
	if n == 104 :
		return 5
	if n == 105 :
		return 4
	if n == 106 :
	
<PREDICTION>
: 	 ( == 0:
			 0
	if n == 64 :
		return 6
	if n == 65 :
		return 6
	if n == 65 :
		return 6
	if n == 66 :
		return 6
	if n == 66 :
		return 6
	if n == 69 :
		return 6
	if n == 69 :
		return 7
	if n == 69 :
		return 6
	if n == 79 :
		return 6
	if n == 79 :
		return 6
	if n == 79 :
		return 5
	if n == 79 :
		return 5
	if n == 7 :
		return 5
	if n == 79 :
		return 5
	if n == 78 :
		return 5
	if n == 79 :
		return 5
	if n == 80 :
		return 5
	if n == 79 :
		return 6
	if n == 79 :
		return 5
	if n == 89 :
		return 5
	if n == 16 :
		return 5
	if n == 85 :
		return 6
	if n == 85 :
		return 5
	if n == 85 :
		return 5
	if n == 88 :
		return 5
	if n == 8 :
		return 5
	if n == 9 :
		return 6
	if n == 93 :
		return 5
	if n == 93 :
		return 5
	if n == 93 :
		return 5
	if n == 93 :
		return 6
	if n == 93 :
		return 6
	if n == 93 :
		return 5
	if n == 97 :
		return 5
	if n == 100 :
		return 6
	if n == 99 :
		return 6
	if n == 100 :
		return 5
	if n == 101 :
		return 5
	if n == 101 :
		return 5
	if n == 101 :
		return 5
	if n == 101 :
		return 6
	if n == 105 :
		
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 24500
----------------------------------------------------------------------------------------------------
<INPUT>
: for k in reversed(list(range(K))):
			dp[k] = S / float(W)
			S += dp[k] - dp[k + W]

		return dp[0]
		
#		 # solution 2: time and space limit exceeded
#		 # dp(n, k) = 1 / W * ( sum pt in range(1, W+1) over dp(n-pt, k-pt) )
		
#		 memo = {}
#		 def dp(n, k):
#			 if (n, k) not in memo:
#				 if k <= 0:
#					 ans = int(n >= 0)
#				 else:
#					 ans = 0
#					 for pt in range(1, W+1):
#						 ans += dp(n-pt, k-pt)
#					 ans *= 1. / W
#				 memo[n, k] = ans
#			 return memo[n, k]
#		 return dp(N, K)
class Solution:
	def new21Game(self, N: int, K: int, W: int) -> float:
		if K == 0:
			return 1
		
		dp = [0]
		cur, temp = 1, 1/W
		for i in range(1, W+1):
			dp.append(cur/W)
			if i < K:
				cur += dp[-1]
			
		# print(dp)
		total = sum(dp[1:min(W+1, K)])
		left = 1
		for i in range(W+1, W+K):
			dp.append(total/W)
			total -=  dp[left]
			left += 1
			if i < K:
				total += dp[-1]
		# print(dp
<PREDICTION>
:  i in range(list(range(n))):
				[k][ = d[ ((dp[
			if = dp[k]
 dp[k] 1]
	returnreturn Sp[K]
class					 d return

 ( O O is

#		 d timep =i) k) = min
 float
 Wk( - d(1, n +1)) +)p)n,1, 1-1)

#	
#		 return = {}
#		 def dfs(n, k):
#			 if nn, k) in in memo:
#				 if n == 0:
#					 return = float(n/ 0)
#					:
#					 ans = float
#				 memo for j in range(1, n+1):
#						 ans = dp(n-pt, k-pt)
#				 memo memo +== (
0 (
#				 memo[(, k] = ans
#				 memo[n, k]
			 memo dp(n, K)
	 Solution:
	def largest21Game(self, N: int, K: int) W: int) -> float:
		
 K == 1:
			return 0
		
		dp = [{] *		
r res = 1, 1
W
		
 i in range(K, K+1):
			cur.append(cur/W)
			cur i == K:
				cur += dp[i1]
							 print(dp)
		
 = 0(dp[::])(W,1, K+])
		return = 1/		right i in range(1-1): K+1):
			left[append(cur/W)
			
 += d dp[i]
			
 += 1
			
 i < K:
				left -= dp[left1]
			 print(dp)
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 25000
----------------------------------------------------------------------------------------------------
<INPUT>
: 		  
		
		# get amount of below threshold cities
		res = Counter()
		for i, row in enumerate(matrix):
			for j, dist in enumerate(row):
				if dist <= distanceThreshold and i != j :
					res[i] += 1
		
		best = 0
		for i in range(n):
			if res[i] <= res[best]:
				best = i
		return best
		
		# check if unconnected cities
		unconnected = []
		i = 0
		while i < n:
			if res[i] == 0:
				# not conencted
				unconnected.append(i)
			i += 1
				
		if len(unconnected) == 1:
			return unconnected[0]
		elif len(unconnected) > 1:
			return max(unconnected)
			
		# all cities are connected with each other, get min value
		ans = min(res.values())
		max_city = 0
		
		# if multiple cities with same minimum neighbours, select biggest one
		for city in range(len(res)):
			if res[city] <= ans and city > max_city:
				max_city = city
				

		return max_cityclass Solution:
	def findTheCity(self, n: int, edges: List[List[int]], distanceThreshold: int) -> int:
		storage = [[30000 if i != j else 0 for i in range(n) ] for j in range(n)]
		for edge in edges:
			storage[edge[0]][edge[1]] = edge[2]
			storage[edge[1]][edge[0]] = edge[2]
		
		#FloydWarshallAPSP
		for k in range(0, n):
			for i in range(0, n):
	
<PREDICTION>
: 		  					
	 the of coins


		# = 0()
		for i in n in enumerate(A):):
			for j, v in enumerate(row):
				if dist <= thresholdThreshold: j < j:
					res[i] += res
					for = 0
		for i in range(len):
			for res[i] > 0[i]:
				best = res
		
 bestclass					
 get if thevis components are		#used = {}
		for = 0
		while i < n:
			if i[i] <= 0:
				un check connected =ate = =				unconnected.append(i)
				 += 1
		


		# i(unconnected) == 0:
			return iconnected
0]
		
if len(unconnected) == 1:
			return un(unconnected)
		else
		# check nodes are connected
 the other
 but the and
		for = 0(un.values())
		
_cost = 0
		for		for check un edges is each city city
 then a

		for city in un(n(un)):
			if res[city] <= ans: res != city_city:
				ans_city = city
				ans		# max_cityclass Solution:
	def findTheCity(self, n: int, edges: List[List[int]], distanceThreshold: int) -> int:
		graph = [[0,, i != j else 0 for j in range(n)]]] for j in range(n)]
		
 i in edges:
			u[edge[0]][edge[1]] = edge[2]
		for
[edge[1]][edge[0]] = edge[2]
		for		for printoyd_arshall
 path
		# i in range(n, n):
			for i in range(0, n):
		
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 25500
----------------------------------------------------------------------------------------------------
<INPUT>
: s2:
			if ele in mp2: mp2[ele] += 1
			else: mp2[ele] = 1
		
		ans = 0
		for k1, v1 in mp1.items():
			tar = k1 ** 2
			for k2 in sorted(mp2.keys()):
				if k2 ** 2 > tar: break
				elif k2 ** 2 == tar:
					ans += v1 * mp2[k2] * (mp2[k2] - 1) // 2
				elif tar % k2 == 0 and (tar // k2) in mp2:
					ans += v1 * mp2[k2] * mp2[tar // k2]
		for k2, v2 in mp2.items():
			tar = k2 ** 2
			for k1 in sorted(mp1.keys()):
				if k1 ** 2 > tar: break
				elif k1 ** 2 == tar:
					ans += v2 * mp1[k1] * (mp1[k1] - 1) // 2
				elif tar % k1 == 0 and (tar // k1) in mp1:
					ans += v2 * mp1[k1] * mp1[tar // k1]
		return ansfrom collections import Counter
import math
class Solution:
	def f(self,nums1, nums2):
		n1 = len(nums1)
		freq_dict_2 = Counter(nums2)
		answer = 0
		for pos_a,a in enumerate(nums1):
			for pos_b in range(pos_a+1,n1):
				b = nums1[pos_b]
				c_square = a*b
				potential_c = math.floor(math.sqrt(c_square))
				#print(f\"{potential_c}**2 = {
<PREDICTION>
: [[
				 sm s::
2[ele] += 1
			else: mp2[ele] = 1
					for = 0
		for ele in in v1 in mp2.items():
			if = v1 + k
			if k2, v(v2[keys()):
				if k2 ** 2 == k:

				ifif k2 ** 2 > k: break					ans += v1
 v2[k2]
 mpk2[k2] - v)
 2
				elseif k < 22 == 0: kk // k2) % mp2: mp					ans += v2 * mp2[k2] * mp2[k // k2]
			 k1 in v2 in mp2.items():
			if = k2 ** 2
			for k1 in sorted(mp2.keys()):
				if k1 ** 2 > v: break
				elif k1 ** 2 > v: break					ans += v1 * mp2[k1] * mpmp2[k1] - 1) // 2
				elif k % k1 == 0 and (k // k1) in mp2:
					ans += v1 * mp1[k1] * mp1[k // k1]
			 ans
 collections import default
class math

 Solution:
	def num(self, n):,,ns2):
		ifums = len(nums1)
		nq =count =from = {}()nums2)
		fre = 0
		for i innum, num in zipate(nums1):
			if i inb, range(pos_a+1,n1):
				if = nums1[pos_a]
				if =a = num *b
				if = =ant b.ce((b.sqrt(b_square))
				ifprint(f'{posential_c}\ is{ { {pot
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 26000
----------------------------------------------------------------------------------------------------
<INPUT>
:  5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569
<PREDICTION>
: ,, 811, 5113, 519, 5113, 5153, 5159, 5173, 5177, 5197, 5197, 5209, 5209, 5231, 5233, 5237, 5237, 5269, 5279, 5287, 5287, 5303, 5303, 523, 5333, 5339, 5363, 5363, 5387, 5389, 5399, 5407, 5313, 5417, 5419, 5423, 537, 5443, 5443, 5449, 5461, 5473, 5479, 5479, 501, 53, 559, 5519, 5521, 5527, 5527, 5551, 5561, 567, 5591, 5581, 5591, 523, 529, 5641, 5653, 5651, 5657, 5669, 5657, 5669, 5681, 5687, 5693, 517, 5711, 5717, 5723, 5741, 5743, 5747, 5753, 5779, 57891, 501, 58807, 5813, 5821, 5827, 5827, 5843, 5851, 5851, 5857, 58861, 5867, 5869, 5879, 58881, 5897, 503, 5923, 5927, 5929, 59951, 5961, 5993, 51, 600993, 629, 6039, 6041, 641, 6061, 667, 6079, 61079, 69, 61037, 619, 6107, 6113, 6133, 6133, 6133, 6163, 6163, 6173, 6197, 6203, 6203, 617, 617, 62221, 6229, 6233, 6271, 6271, 6269, 6271, 6281, 6281, 6299, 601, 611, 6317, 6329, 6329, 63341, 6343, 6343, 6359, 6367, 6367, 6373, 6383, 6391, 6391, 6321, 6427, 64449, 64457, 669, 64491, 6479, 6491, 611, 6527, 6533, 65551, 61, 6551, 677,
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 26500
----------------------------------------------------------------------------------------------------
<INPUT>
:  the Job object as a key in dict
	def __hash__(self):
		return hash((self.start_time, self.end_time, self.weight))

	def __eq__(self, other):
		return self.start_time == other.start_time and self.end_time == other.end_time and self.weight == other.weight


class WeightedIntervalSchedule:

	def __init__(self, sch):
		self.jobs = list()
		for job in sch:
			self.jobs.append(Job(job[0], job[1], job[2]))

		self.jobs_end_first = []
		self.jobs_start_first = []
		self.previous_job = len(self.jobs) * [0]
		# Memoization will be done using this memory dict
		self.memory = dict()
		#computing the previous mappings
		self.compute_latest_job_scheduled_before()
		

	def getResult(self):
		return self.dp(self.jobs_end_first, len(self.jobs) - 1, self.previous_job)

	def compute_latest_job_scheduled_before(self):
		
		# Sorting the jobs in non decreasing order of end_time - O(nlogn)
		self.jobs_end_first = sorted(self.jobs, key=lambda x: x.end_time)

		indexed_jobs_start_first = [(index, job) for index, job in enumerate(self.jobs_end_first)]
		# Sorting the jobs in non decreasing order of start_time - O(nlogn)
		self.jobs_start_first = sorted(indexed_jobs_start_first, key=lambda x: x[1].start_time)

		# This list X will store the index of the previous job in jobs_end_first
		X = len(self.jobs) * [0]
		X[0] = -1

		# The time complexity of this method is O(n) as the statement inside the
<PREDICTION>
:  first of are the string of the.		 keyinit__(self):
		return dict inself.data,time + self.time_time, self.time))
	def addset__(self, other):
		return self.weight_time < other.weight_time and self.end_time == other.end_time and self.end

 other.weight

	def SolutionedUnionval(str:
	def __init__(self, a):
		self.c = list(
		self e in range:
			self.jobs.append(job)job))0], job[1] job[2]))
	defself.jobs =list =time = self
		self.jobs_end =second = []
		self.jobs__job = [](self.jobs)
 21]
		self selfed =
 be used

 job

		for.jobs = {}()
		for selfbs
 first joboves
		for.lastute(next_m(1ores_ =from =
		self	def get_(self):
		self self.jobs[self.jobs,start_first) self(self.jobs) - 1, self.jobsvious_job,
	def get_best_job_schedValues_before(self):
		return		selfselforted
 best from the- order
 d timefirst
 start(nogn)
		self.dp =end_first = [](self.jobs_ key=lambda x: x[weight_first)
		# = =time =end =first = selfselfed value[ for index, job in enumerate(self.jobs_end_first)
		self printorted the jobs in non decreasing order of end_time - O(nogn)
		self.jobs_end_first = [(selfed(jobs_start_first) key=lambda x: x.0])end_time)
		# S time isOR be the job of the jobs job
 non
start_first
		# = self(X.jobs_
 [0]
		for =0] = X1
		for then first limit is O job is O(n)
 input first

 job
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 27000
----------------------------------------------------------------------------------------------------
<INPUT>
: [i]):
   am+=1
   if(am>1):
	break
  if(w[i]!=z[i]):
   bm+=1
   if(bm>1):
	break
 if(am==1):
  print(*y)
 else:
  print(*z)
t = int(input())
for T in range(t):
 n = int(input())
 a = [int(x) for x in input().split()]
 diff = []
 cor = 0
 
 for i in range(1, n):
  diff.append(a[i] - a[i - 1])
 d = set(diff)
 d = list(d)
 
 if len(d) == 1:
  print(*a)
  continue
 if len(d) == 2:
  cor = a[2] - a[1]
  if a[1] - a[0] != cor:
   a[0] = a[1] - cor
  else:
   a[-1] = a[-2] + cor
  print(*a)
  continue

 
 if (d[0] + d[1]) / 2 == d[2]:
  cor = d[2]
 elif (d[1] + d[2]) / 2 == d[0]:
  cor = d[0]
 else:
  cor = d[1]
 for i in range(1, n):
  if a[i] - a[i - 1] != cor:
   a[i] = a[i - 1] + cor
 print(*a)
t=int(input())
for _ in range(t):
 n=int(input())
 a=list(map(int,input().split()))
 if n==4:
  target=-1
  cur=-1
  ind=-1
  s=set()
  flag=False
  for i in range(1,n):
   k=a[i]-a[i-1]
   if k not in s:
	s.add(k)
   else:
	target=k 
	cur=a[i
<PREDICTION>
: i]

	  ift1
   if amam===):
	print
  (am>i]===0):i]):
   am.=1
   am(b>1):
	break
 (b>0):
  print(b)
 else:
  print(*z)
 = int(input())
for _ in range(t):
 n = int(input())
 a = listint(i) for x in input().split()]
 b = a
 for = 0
 for
 for i in range(n,n):
  if.append(a[i] - a[i - 1])
  = []()diff)
 if = d(d)
 if
 if len(d) == 0:
  print(d)
 else continue
 else len(d) == 2:
  print = 1[0]
 a[1]
  if d[0] - a[0] == diff:
   print[1] -= a[1] - a
  :
   a[01] = a[01]
 a
  print(*a)
 else continue
 if
 if lenlen[0] != diff[1]) % 2 > 0[0]:
  print = d[0] - if (d[0] + d[2]) / 2 == d[0]:
  if = d[2] + else:
  if = d[1]
 print i in range(2, n):
  if a[i] != a[i - 1] != diff:
   a[i] = a[i] 1]
 d
 (*a)
 =int(input())
for _ in range(t):
 n=int(input())
 a=list(map(int,input().split()))
 diff len==1:
  print=1
 else for=1
  for=1
  for=0()
  for=0
  for i in range(1,n):
   if=a[i]-a[i-1]
   if k> in s:
	flag.add(k)
	  else:
	s=a

	ind=a[i]
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 27500
----------------------------------------------------------------------------------------------------
<INPUT>
: ] * n
		f[n-1] = [1] * len(vowels_idx)
		for i in range(n-2, -1, -1):
			f[i] = [0] * len(vowels_idx)
			for vowel in vowels_idx:
				if vowel == 'a':
					f[i][vowels_idx[vowel]] += f[i+1][vowels_idx['e']]
				elif vowel == 'e':
					f[i][vowels_idx[vowel]] += f[i+1][vowels_idx['a']] + f[i+1][vowels_idx['i']]
				elif vowel == 'i':
					f[i][vowels_idx[vowel]] += f[i+1][vowels_idx['a']] + f[i+1][vowels_idx['e']] + f[i+1][vowels_idx['o']] + f[i+1][vowels_idx['u']]
				elif vowel == 'o':
					f[i][vowels_idx[vowel]] += f[i+1][vowels_idx['i']] + f[i+1][vowels_idx['u']]
				else:
					f[i][vowels_idx[vowel]] += f[i+1][vowels_idx['a']]
				f[i][vowels_idx[vowel]] %= (10**9 + 7)
		total = 0
		for vowel in vowels_idx:
			total += f[0][vowels_idx[vowel]]
		return total % (10**9 + 7)
			
		memo = {}
		def f(i, prev_vow
<PREDICTION>
: 
 (
			[i]1] = f0] * n(n)els)countx)
		for i in range(n-2, -1, -1):
			if[i] = f0] * len(vowels_idx)
			for j in vowels_idx:
				f i == '1':
					f[i]iowel_idx[vowel]] += 1[i+1][vowels_idx[a']]
				elseif vowel == 'e':
					f[i][vowels_idx[vowel]] += f[i+1][vowels_idx['e']]]
 f[i+1][vowels_idx['e']]
				elseif vowel == 'i':
					f[i][vowels_idx[vowel]] += f[i+1][vowels_idx['e']]
 f[i+1][vowels_idx['e']]
 f[i+1][vowels_idx['i']]
 f[i+1][vowels_idx['i']] +				elseif vowel == 'o':
					f[i][vowels_idx[vowel]] += f[i+1][vowels_idx['e']] + f[i+1][vowels_idx['e']] +				el:
					f[i][vowels_idx[vowel]] += f[i+1][vowels_idx['e']] +				f[i][vowels_idx[vowel]] +== mod10**9+ 7)
			 = 0
		for i in vowels_idx:
			total += f[v][vowels_idx[vowel]]
		return total % (10**9 + 7)
			
			o = {}
		def d(i, j):vowel
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 28000
----------------------------------------------------------------------------------------------------
<INPUT>
: append((x,y+1))
	stack.append((x,y-1))
	ans.append(curr)

for i in range(k):
	curr = ans[len(ans)-i-1]
	x = curr[0]
	y = curr[1]
	maze[x][y] = 'X'
s = ""
for i in range(n):
	for j in range(m):
		s+=maze[i][j]
	s+="\n"
print(s)
import sys
from collections import defaultdict

def main():
	sys.setrecursionlimit(1 << 30)
	g = []
	adj = defaultdict(set)
	vis = set()
	def valid(x, y):
		nonlocal n, m
		return x >= 0 and x < n and y >= 0 and y < m
	def bfs(x, y):
		nonlocal g, vis, adj
		q = []
		q.append((x, y))
		vis.add((x, y))
		s = 0
		while len(q) > 0:
			(x, y) = q.pop()
			s += 1
			for c in [[-1, 0], [1, 0], [0, -1], [0, 1]]:
				nx = c[0] + x
				ny = c[1] + y
				if valid(nx, ny) and (nx, ny) not in vis:
					if g[nx][ny] == '.':
						vis.add((nx, ny))
						q.append((nx, ny))
		return s
	def bfs2(x, y):
		nonlocal g, vis, adj, count
		q = []
		q.append((x, y))
		vis.add((x, y))
		while len(q) > 0:
			(x, y) = q
<PREDICTION>
: (i,y,1))
		.append((x,y+1))
	stack[append((ans))
	for i in range(n):
	printr= [[i(ans)-1-1]
	ans, ansr[0]
	y = curr[1]
	ans =.x][y] = 0#'
	 = '
for i in range(n):
	for j in range(n):
		if +=ansaze[i][j]
	s +=="".n"
	(s)
n sys

 collections import dedict

n main():
	n.setrecursionlimit(100000000 16)
	input = default
	for = defaultdict(list)
	forited [()
	for d(x, y):
		iflocal adj, m,		if 0 == 0 and x < n and y >= 0 and y < m
	def dfs(x, y):
		nonlocal adj, adj
 adj
		vis = [(
		q.append((x, y,
		vis.add((x, y))
		while = 0
		while q(q) > 0:
			xx, y) = q.pop()
			for += 1
			for i in adj01, 0], [1, 0], [0, 11] [0, 1]]:
				ifx, x[0]
 c
				ny = c[1] + y
				if n(nx, ny): and validnx, ny) not in vis:
					if n[nx][ny] == 1X:
						q.add((nx, ny))
						q.append((nx, ny))
			 s
	def shortestfs((x, y):
		nonlocal g, vis, adj
 adj
		if = []
		q.append((x, y))
		vis.add((x, y))
		while len(q) > 0:
			xx, y) = q.
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 28500
----------------------------------------------------------------------------------------------------
<INPUT>
: : x[0], reverse = True)

	DP = [[0] * (N + 1) for _ in range(N + 1)]

	for i, b in enumerate(B):
		a = b[0]
		tmp = b[1]
		for x in range(i + 1):
			DP[x + 1][i - x] = max(DP[x + 1][i - x], DP[x][i - x] + a * abs(tmp - x))
			DP[x][i - x + 1] = max(DP[x][i - x + 1], DP[x][i - x] + a * abs((N - tmp - 1) - (i - x)))

	ans = 0
	for i in range(N + 1):
		ans = max(ans, DP[i][N - i])

	print (ans)

	# for tmp in DP:
	#	 print (tmp)

def __starting_point():
	main()
__starting_point()N = int(input())
A = sorted([(int(x[1]), x[0]) for x in enumerate(input().split())], reverse=True)


V = [0]

for i in range(N-1):
	a, p = A[i]
	s = i+1
	V2 = [None]*(s+1)

	for t in range(s+1):
		v = 0

		if t > 0:
			v = V[t-1] + a*abs(p-(t-1))

		if t < s:
			v = max(V[t] + a*abs(p-(N-s+t)), v)

		V2[t] = v

	V = V2

a, p = A[-1]
for i in range(N):
	V[i] += a*abs(p-i)

print((max(V)))





			
from collections import *
from itertools import *

N = int(input())

A = list(map(int, input().split()))
SA
<PREDICTION>
: 
 =1] x= True)
		 = [0] * (n + 1) for _ in range(N + 1)]
	for i in x in enumerate(A):
		for, B[0]
		b = a[1]
		for j in range(1 + 1):
			if[x][ 1][x] x] = DP(DP[x + 1][i - x], DP[x][i - x] + a) ((x - x))

			tmp[x +i + x] 1] = max(DP[x +i - x], 1], DP[x][i - x] + a * abs(a - x - x) - xtmp - x)))
	print = 0
	for i, range(1): 1):
		ans = max(ans, DP[i][N - i])
	print(ans)


return print i in range:
	#	 print (tmp)

def __starting_point():
	main()

starting_point()N, int(input())
A = list(listint(a) 1]), int[0] for x in inputate(input())split()]) key=True)

def = [0] *forfor i in range(N):1):
	V, b = A[i]
	V = a+1
	for. = Va]
(N+1)
	for j in range(s+1):
		V = t
		for t == a:
			v = t[t]1]
 t *t(v-t-1))
		for t > s:
			v = V(v[t- + a*abs(p-(t-s))1- V)
		V[[t] = max

	V2 V2


print = b = A[01]

 i in range(N-
	a2i] = a
abs(p-(i)

ans(max(V)))






	 it import default

 itertools import *
importN = int(input())
AA = sorted(map(int, input().split()))

 =
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 29000
----------------------------------------------------------------------------------------------------
<INPUT>
: 
	cnts = list(map(int, stdin.readline().split()))
	for i in range(1,k):
		cnts[i] += cnts[i-1]
	
	group = list(range(n))
	rnk = [0 for i in range(n)]
	adj = [[INF for j in range(k)] for i in range(k)]
	for i in range(m):
		u, v, x = map(int, stdin.readline().split())
		if x==0:
			union(group, rnk, u-1, v-1)
		tu = bisect_left(cnts, u)
		tv = bisect_left(cnts, v)
		adj[tu][tv] = min(adj[tu][tv], x)
		adj[tv][tu] = min(adj[tv][tu], x)
	
	p = 0
	for i in range(k):
		cur = group[p]
		while p<cnts[i]:
			if group[p]!=cur:
				print("No")
				return
			p += 1
	print("Yes")
	
	for p in range(k):
		for i in range(k):
			for j in range(k):
				adj[i][j] = min(adj[i][j], adj[i][p]+adj[p][j])
	
	for i in range(k):
		adj[i][i] = 0
		for j in range(k):
			if adj[i][j] == INF:
				adj[i][j] = -1
	
	for i in range(k):
		print(' '.join(map(lambda x: str(x), adj[i])))
	
	
solve()n, m = list(map(int, input().split()))
print('{:.9}'.format((1 + (n - 1) * (m - 1) / (n
<PREDICTION>
: 		nt +=[ [(map(int, inputin.readline().split()))
	for i in range(n, n):
		ifnts[i] = cnts[i-1]
			ans = [[(map(1))
	for = = [0] i in range(n)]
	for = [[]F] i in range(n)] for i in range(n)]
	for i in range(n):
		for,v = w = std(int, stdin.readline().split())
		adj x ==1:
			adj(x, un,, x)1) v-1)
		if = uect_left(adjnts, x,
		if = bisect_right(cnts, v)
		if[u][0] = min(c[ [[][tv], x)
		if[c][tv] = min(adj[ <][tv], x)
			forq [
	for i in range(n):
		p = 0[i]
		if cur <lennts[cur]:
			p adj[p] !==c:
				p(-No")
				return
			p+= 1
		("Yes")
	
	
 i in range(1):
		print i in range(n):
			if j in range(k):
				if[i][j] = min(adj[i][j], adj[i][p]+1[i][j])
			print i in range(k):
		print[0][k] = 0
		
 j in range(k):
			cur adj[i][j]! INF:
				print[i][j] = min1
			for i in range(k):
		for("'.join(map(str x: str(x)adj[i][)))
			return	 =()
, k = list(map(int, input().split()))

(Yes}n2f'.format(n if nn - 1) * mm - 1) + 2m -
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 29500
----------------------------------------------------------------------------------------------------
<INPUT>
: .Counter()
		for n in nums1:
			double1[n * n] += 1
		for n in nums2:
			double2[n * n] += 1
		for i in range(len(nums1)):
			for j in range(i + 1, len(nums1)):
				if nums1[i] * nums1[j] in double2:
					res += double2[nums1[i] * nums1[j]]
		for i in range(len(nums2)):
			for j in range(i + 1, len(nums2)):
				if nums2[i] * nums2[j] in double1:
					res += double1[nums2[i] * nums2[j]]
		return res
from collections import Counter

class Solution:
	def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:
		squares1 = Counter([x ** 2 for x in nums1])
		squares2 = Counter([x ** 2 for x in nums2])
		total = 0
		
		# type 1
		for i in range(len(nums2)):
			for j in range(i + 1, len(nums2)):
				if (square := nums2[i] * nums2[j]) in squares1:
					total += squares1[square]
					
		# type 2
		for i in range(len(nums1)):
			for j in range(i + 1, len(nums1)):
				if (square := nums1[i] * nums1[j]) in squares2:
					total += squares2[square]
		
		return totalclass Solution:
	def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:
		m
<PREDICTION>
: append(
			 i in ranges::
			for = =n] n] += 1
			 n in nums2:
			double2[n * n] += 1
		for n in range(n(nums1)):
			double j in range(i + 1, len(nums2)):
				if nums1[i] * nums2[j] in num2:
					return += double2[nums1[i] * nums1[j]]
		return i in range(len(nums2)):
			for j in range(i + 1, len(nums2)):
				if nums2[i] * nums2[j] in double2:
					res += double2[nums2[i] * nums2[j]]
		return res
class collections import Counter
classclass Solution:
	def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:
		
ares1 = Counter(x * 2 for x in nums1])
		squares2 = Counter([x ** 2 for x in nums2])
		squ = 0
		for		for print1
		for i in range(len(nums1)):
			for j in range(i + 1, len(nums2)):
				for numn2 nums2[i] * nums2[j]) in square1:
					total += squares1[square]
		
		
		return print 2
		for i in range(len(nums1)):
			for j in range(i + 1, len(nums2)):
				if (square := nums1[i] * nums2[j]) in squares2:
					total += squares2[square]
		
		return total
 Solution:
	def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:
		
 =
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 30000
----------------------------------------------------------------------------------------------------
<INPUT>
: 
	meet=0
	pos=[[[0 for z in range(c)] for y in range(r)] for x in range(max(r,c))]
	j=0
	k=0
	while j <r:
		j_init = j
		# if(j==r):
			# print("Fault:"+str(j))
		k=0
		while k <c:
			k_init = k
			# if(j==r or k==c):
			#	 print("Fault:"+str(j)+" "+str(k))
			# print(str(j) + " " + str(k))
			if(arr[j][k] in anr):

				for z in range(max(r, c)):
					if(j==r or k==c or arr[j][k]=="#" or k==-1 or j==-1):
						break
					if(pos[z][j][k]>0):
						meet+=pos[z][j][k]
					# else:
						# print(str(z) + " " + str(j) + " " + str(k))
					pos[z][j][k]+=1
					if(arr[j_init][k_init]=='D'):
						j+=1
					elif(arr[j_init][k_init]=='U'):
						j-=1
					elif (arr[j_init][k_init] == 'L'):
						k -= 1
					elif (arr[j_init][k_init] == 'R'):
						k += 1
			k=
<PREDICTION>
: 
		 =[]
	for=000, i in range(n)] for z in range(c)] for x in range(r(l))c))]
	for=0
	for=0
	for(< r:
		if+=i= 0
		whileprint posj_0-
		## print(1","));str(k_
			+=k
		while j< c:
			#+=init = k+
			# print(j==c): j==c):
			#	 print("F2:"+str(j))")\str(j_
			k	(k(j)) + " "+ + str(k))
			#(j[j][k]== pos):):
	
				# x in range(j(k,c)):
					if(j==0 or z==c): z[j][k]==".""): j==01): j==r1):
							
					else(j[j][k]k]==0):
						pos=1[z][j][k]
						 print:
						# print(j(j)+ + " " + str(k)) + " " + str(k))
						[j][j][k] =1
					pos(pos[j][init]k]init]==0#':):
						pos+=1
						if(j[j_init][k_init]=='#'):
						j+==1
					elseif(j[j_init][k_init]== '#'):
						j+= 1
					elseif(arr[j_init][k_init] == 'R'):
						j+= 1
				+=0
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 30500
----------------------------------------------------------------------------------------------------
<INPUT>
: 2c3.38

Output
6.38

Input
aa0.01t0.03

Output
0.04Let's denote a m-free matrix as a binary (that is, consisting of only 1's and 0's) matrix such that every square submatrix of size m × m of this matrix contains at least one zero. 

Consider the following problem:

You are given two integers n and m. You have to construct an m-free square matrix of size n × n such that the number of 1's in this matrix is maximum possible. Print the maximum possible number of 1's in such matrix.

You don't have to solve this problem. Instead, you have to construct a few tests for it.

You will be given t numbers x_1, x_2, ..., x_{t}. For every $i \in [ 1, t ]$, find two integers n_{i} and m_{i} (n_{i} ≥ m_{i}) such that the answer for the aforementioned problem is exactly x_{i} if we set n = n_{i} and m = m_{i}.


-----Input-----

The first line contains one integer t (1 ≤ t ≤ 100) — the number of tests you have to construct.

Then t lines follow, i-th line containing one integer x_{i} (0 ≤ x_{i} ≤ 10^9).

Note that in hacks you have to set t = 1.


-----Output-----

For each test you have to construct, output two positive numbers n_{i} and m_{i} (1 ≤ m_{i} ≤ n_{i} ≤ 10^9) such that the maximum number of 1's in a m_{i}-free n_{i} × n_{i} matrix is exactly x_{i}. If there are multiple solutions, you may output any of them; and if this is impossible to construct a test, output a single integer  - 1. 


-----Example-----
Input
3
21
0
1

Output
5 2
1 1
-1Vasya is sitting on an extremely boring math class. To have fun, he took a piece of paper and wrote out n numbers on a single line. After that, Vasya began to write out different ways to put pluses ("+") in the line between certain
<PREDICTION>
: ,2,append99
Output
2
00000000.
Input
5ab







Output
0.33.'s call the set-c number as a string matrixn is, the of n one and and 1's). and. that the column ismatrix is the n is m. the matrix is at least one side.


Let all following sequence: 
$ are given a integers n and m, Your have to determine a array-bit matrix matrix. size n. m. that the sum of rows ≤ in this matrix is not possible.

 the number possible value of rows's in this a.


You have't have to answer this problem.

, you have to answer a matrix examples of each.


You have be given a lines a and1, x_2, ..., x_{t} You each 1t$,le [1, 2]$ you the numbers l andi} ( t_{i} (1_{i} < 1_{i} — that the sum is each i matrix. maximum one_{i} + the have it_{ x_{i} and m_{ i_{i}

-----Input-----

The first line contains two integer t (1 ≤ t ≤ 10) — the number of test. need. solve a

The t lines follow, each-th of contains two integer n_{i} (1 ≤ x_{i} ≤ 100^5).

It that the each you have to print n numbers 1,


-----Output-----

Print each test case have to print a print the integers integers x_{i} and m_{i} (1 ≤ i_{i} ≤ n_{i} ≤ 10^9). — that the answer possible of 1's in this test-i}-th square_{i} is m suchi} is is maximum x_{i}

 there are multiple answers, you may print any of them. otherwise print there solution impossible to make a m in print any single integer -  1.



-----Example-----
Input
2
1
1 11 11Output
2

1 2 111
ladya has going at a array contest of.. He solve a of he has a new of paper. he out a pieces. a given line. The that he heya has a perform a the numbers to write theimes inV", in such order. the integer
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 31000
----------------------------------------------------------------------------------------------------
<INPUT>
:  
		pile.append([elt,coeff+1])
	
	coeff = 0
	while(pile):
		top1, top2 = pile.pop()
		coeff += top2
		score = top1*coeff
		maxi = max(maxi, score)
	
	return maxidef array_info(x):
	TheDICT = {'len':[1,len(x)], int:[2,0], str:[4,0], float:[3,0], 'void':[5,x.count(' ')]}
	for e in x:
		if e != ' ':
			TheDICT[type(e)][1] += 1
	return [ [e[1] if e[1] else None] for e in sorted( TheDICT.values() ) ] if x else 'Nothing in the array!'
			
		
def array_info(x):
	return [[len(x) or None],[sum(isinstance(n,int) for n in x) or None],[sum(isinstance(n,float) for n in x) or None],[sum(isinstance(n,str) and n!=" " for n in x) or None],[sum(n==" " for n in x) or None]] if x else "Nothing in the array!"def a(n):
	n -= n%2
	if n<4: return ''
	return '\n'.join( '{0}{1}{0}'.format('A' * (i%(n//2) != 0),
										 ' ' * (i*2-1) if i%(n//2) else ' '.join( ['A']*(i+1) )
										).center(2*n-1) for i in range(n) )def a(n):
	n = n if n % 2 == 0 else n - 1
	width = 2 * n - 1
	lines = ["A".center(width)] + [("A" + " "*k + "A").center(width) for k in range(1, n-1, 2
<PREDICTION>
: 
			 = =append(i, p-])1])
			foreff = 0
	for Truecoile):
		p = =top2 = p[pop()
		ifeff += top1
		if = score1*(eff
		if_ = max(maxi, score)
				 maxi
 max_of(n,
	return =ict = ['a': [0, 2],x)], ',0,len], 1(0,0], str:4,0], 1-':[1,0],index(0) for
	return i in x:
		if e[ ' ':
			TheDICT[e(e)]][0] += 1
		 [intint for0] for e[0] != [ fordef e in x( TheDICT])values(),)] ]def len else ['. in the array.'
def

	def	
def array_info(x):
	return [x(x) for [ forx(xinstance(x, x) for n in x) ] None]]x(isinstance(n,int) for n in x) or None]]x(isinstance(n,int) for n in=' ") n in x) or None]]x(is)' " for n in x) or None],[def x else 'Not in the array!"
 array_n):
	if = 1
10
	return n ===: return "
	if ' '.n'.join([a'.}:1}2}'format('.' if nn+2i-2) + n)) '											{ * (i%n)1) for n else(n//2) != ' 'join(str '' *(i+1) for
									 ' 'join('n*n-1)
 i in range(n// else
 a(n):
	if = n% n% 2 == 0 else n
 n
	if = n
 n
 1
	if = []".",join(width)]
 [widthB" * widthB *() " "")center(width)] for k in range(width, n)]1)] 2)]
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 31500
----------------------------------------------------------------------------------------------------
<INPUT>
: [2]))
		
		
		def reachable(node, visited, threshold, dist):
			for nei in graph[node]:
				if dist+nei[1]<visited[nei[0]] and dist+nei[1]<=threshold:
					visited[nei[0]] = dist+nei[1] 
					reachable(nei[0], visited, threshold, dist+nei[1])
					
		res = 0
		temp = n
		for i in reversed(list(range(n))):
			visited = [float('inf') for _ in range(n)]
			visited[i] = 0
			c = 0
			dist = 0
			for nei in graph[i]:
				if dist+nei[1]<visited[nei[0]] and dist+nei[1]<=d:
					visited[nei[0]] = dist+nei[1] 
					reachable(nei[0], visited, d,dist+nei[1])
			
			for val in visited:
				if val>0 and val!=float('inf'):
					c+=1
		
			# print(c,i)
			if c < temp :
				res = i
				temp = c
		return res
class Solution:
	def findTheCity(self, n: int, edges: List[List[int]], distanceThreshold: int) -> int:
		THRESHOLD_MAX = 10001
		dist = [[THRESHOLD_MAX for _ in range(n)] for _ in range(n)]
		
		for edge in edges:
			dist[edge[0]][edge[1]] = edge[2]
			dist[edge[1]][edge[0]] = edge[2]
		
		for i in range(n):
<PREDICTION>
: i]

					
		
 findable(i, parent): path): visited):
			if nx in graph[node]:
				if visited[nei not0]<=ited:nei[0] and dist+nei[1]<= thresholdreshold:
					returnited[nei[0]] = dist+nei[1]

					
able =nei[0], visited, threshold, dist+nei[1])
					
			 = 0
		for = []
		for i in range(list(range(n))):
			ifited[ [False('inf')] _ in range(n)]
			resited[i] = 0
			
 = 0
			for[ 0
			for ji in graph[i]:
				if visited+nei[1]<visited[nei[0]] and dist+nei[1]<=th:
					distited[nei[0]] = dist+nei[1]

					resable(nei[0], visited, threshold) dist+nei[1])
								 i in range[
				if val<=: visited<=0('inf'):
					if+=1
						ifprint(c) res)
			if c== res:
				res = max+				
 = c
			 res
	 Solution:
	def findTheCity(self, n: int, edges: List[List[int]], distanceThreshold: int) -> int:
		
 = = = =IN = float

		
 = [[floatONH__MAX] _ in range(n)] for _ in range(n)]
		dist		for i in edges:
			dist[edge[0]][edge[1]] = edge[2]
			
[edge[0]][edge[0]] = edge[2]
		
		for i in range(n):

----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 31500
----------------------------------------------------------------------------------------------------
<INPUT>
: )]


A_median = statistics.median(A)
B_median = statistics.median(B)
if N%2==0:
	print(int((B_median-A_median)*2)+1)
else:
	print(B_median-A_median+1)n = int(input())
a = [int(i) for i in input().split()]


# print(n)
# print(a)

sort_a = sorted(a, reverse=True)
# print(sort_a)

now_list = []
next_insert = []
comfort = []
# print('start')
for index, i in enumerate(sort_a):
	if len(now_list) == 0:
		now_list += [i]
		next_insert += [1]
		comfort += [i]
	else:
		if len(next_insert) >= n:
			break
		else:
			next_insert += [1, 1]
			comfort += [i, i]


# print(comfort, next_insert)
print((sum(comfort[:n-1])))
n = int(input())
a = list(map(int,input().split()))
a = sorted(a,reverse = True)
ans = 0
if n%2 == 0:
	for i in range(n//2):
		if i == 0:
			ans += a[i]
			continue
		ans += a[i]*2
else:
	for i in range(n//2+1):
		if i == 0:
			ans += a[i]
			continue
		ans += a[i]*2
if n %2== 1:
	ans -= a[i]
print(ans)def chat_in_a_circle():
	N = int(input())
	A = list(map(int,input().split()))
	A.sort()
	res = A.pop(-1)
	t = len(A) % 2 == 0
	a = 0
	for i
<PREDICTION>
: 
	def =maxian_ A.median
A_
B_median = statistics.median(B)

 A %2==0:
	print(N(N_median-B_median))2))1)
else:
	print(int_median-A_median)1)
 = int(input())
a = listint(i) for i in input().split()]

def (a)

 print(a)

#_a = [](a) reverse=True)

 print(sort_a)

# =a = []
for_list = []
for_ []
for print(next')
for i in item in enumerate(a_a):
	if i(now_list) < 0:
		now_list. [i]
	elsecontinue_insert. [i]
	elsecontinue. [i]
	else:
		now len(now_insert) == len:
			break
		now:
			next_insert. [next] next]
			next += [next] 1]
	# print(next) next_insert)
#(-(next)))0n]1])))
# = int(input())
a = list(map(int, input().split()))

. sorted(a)reverse= True)

 = 0
for n %2== 0:
	ans i in range(n//2):
		if a != 0:
			ans += a[i]
		elsebreak
		else += a[i]
2
	:
	for i in range(n//2):1,
		if i == n:
			ans += a[i]*			continue
		ans += a[i]*2
	 n% 2 ==0:
	ans += a[n]*print(ans)
 main(sortplist_list(
	return = int(input())
	A = list(map(int, input().split()))
	A.sort()
	if = 0[count()1)
	if = 0(A)
 2
 0
	for = A
	b i in
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 32000
----------------------------------------------------------------------------------------------------
<INPUT>
: #F = F.tolist()
	#X = X.tolist()
	#Y = Y.tolist()
	#DX = DX.tolist()
	#DY = DY.tolist()

	LenX = len(X)
	LenY = len(Y)

	visit = [[False] * LenY for _ in range(LenX)]
	visit[x][y] = True
	area = 0
	queue = [(x, y)]

	LineX = [[False] * LenY for _ in range(LenX)]
	LineY = [[False] * LenY for _ in range(LenX)]

	for x1, x2, y in zip(A, B, C):
		for x in range(x1, x2):
			LineY[x][y] = True

	for x, y1, y2 in zip(D, E, F):
		for y in range(y1, y2):
			LineX[x][y] = True

	LenX -= 1
	LenY -= 1
	
	while queue:
		x, y = queue.pop()
		
		if x == 0 or x == LenX or y == 0 or y == LenY:
			area = 0
			break
		
		area += DX[x] * DY[y]
		
		x1 = x - 1
		if not LineX[x][y] and not visit[x1][y]:
			visit[x1][y] = True
			queue.append((x1, y))
		y1 = y - 1
		if not LineY[x][y] and not visit[x][y1]:
			visit[x][y1] = True
			queue.append((x, y1))
		x1 = x + 1
		if not LineX[x1][y] and not visit[x1][y]:
			visit[x1][y] = True
			queue.append((x1, y))
		y1
<PREDICTION>
: print
 [(s
ist()
		F = [[tolist()
	#Y = Y.tolist()
	#ZY X.tolist()
	#FY = YY.tolist()
	#X = len(X)
	LenY = len(Y)

	ifit = [[False]*LenY for _ in range(LenX)]

	visit[x][y] = True
	vis = 0
	for = [(x, y)]

	whileX = [[False] *LenY for _ in range(LenX)]

	LineY = [[False] *counterY for _ in range(LenX)]

	for x,, x2, y in zip(X, B, C):
		for x in range(x1, x2):
			forY[x][y] = True

	for x in y in, y2 in zip(A, E, F):
		for y in range(y1, y2):
			LineY[x][y] = True

	forX = 1
	LenY -= 1

	Len	for queue:
		x, y = queue.pop()

		if		if x == 0 or x == lenX or y == 0 or y == 0Y:
			area = 0
			break
		
		area += (Xx][ * (Y[y]
		if		if,, x1 1
		y x selfX[x1y] and not visit[x][][y]:
			areait[x1][y] = True
			queue.append((x1, y))
		if1 = y - 1
		if not LineY[x][y] and not visit[x1y]:]:
			visit[x1y1] = True
			queue.append((x1 y))))
		
2 = x1 1
		if not LineY[x][][y] and not visit[x1][y]:
			visit[x1][y] = True
			queue.append((x1, y))
		y2 =
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 32500
----------------------------------------------------------------------------------------------------
<INPUT>
: 
			self.dct[key].append((timestamp, value))
		else:
			lo, hi = 0, len(self.dct[key]) - 1
			while lo <= hi:
				mid = (lo + hi) // 2
				if arr[mid][0] < timestamp:
					lo = mid + 1
				else:
					hi = mid - 1
			arr.insert(lo, (timestamp, value))
		return
			
		

	def get(self, key: str, timestamp: int) -> str:
		if key not in self.dct:
			return \"\"
		arr = self.dct[key]
		lo, hi = 0, len(arr) - 1
		while lo <= hi:
			mid = (lo + hi) // 2
			if arr[mid][0] == timestamp:
				return arr[mid][1]
			elif arr[mid][0] > timestamp:
				hi = mid - 1
			else:
				lo = mid + 1
		return arr[hi][1] if hi != -1 else \"\"
				
		


# Your TimeMap object will be instantiated and called as such:
# obj = TimeMap()
# obj.set(key,value,timestamp)
# param_2 = obj.get(key,timestamp)class TimeMap:

	def __init__(self):
		\"\"\"
		Initialize your data structure here.
		\"\"\"
		self.store = {}

	def set(self, key: str, value: str, timestamp: int) -> None:
		if key not in self.store:
			self.store[key] = [(value, timestamp)]
		else:
			self.store[key].append((value, timestamp))
	
	def binarySearch(self, k, t):
		arr = self.store[k]
		i = 0

<PREDICTION>
: 				.parents[[self]append(keyestamp, self))
			:
			self = hi = 0, len(self.dct[key])- 1
			while lo < hi:
				mid = (lo + hi) // 2
				if self[mid][0] <= arr:
					hi = mid + 1
				else:
					hi = mid - 1
			if[append(0, 0timestamp, value))
		self arr		

			
def sortedStrongself, arr: str, timestamp: int) -> str:
		if key in in self.dct:
			return ''\"
		
 = self.dct[key]
		if = hi = 0, len(arr) - 1
		while lo <= hi:
			mid = (lo + hi) // 2
			if arr[mid][0] <= timestamp:
				return arr[mid][1]
			ifif arr[mid][0] < timestamp:
				hi = mid - 1
			else:
				lo = mid + 1
		return arr[lo][1]
 arr < 01 else \"\"
			

			
# Your TimeMap object will be instantiated and called as such:
# obj = TimeMap()
# obj.set(key,value,timestamp)
# param_2 = obj.get(key,timestamp)class TimeMap:

	def __init__(self):
		\"\"\"
		Initialize your data structure here.
		\"\"\"
		self.d = {}
	def set(self, key: str, value: str, timestamp: int) -> None:
		if key not in self.store:
			self.store[key] = []value, value)]
		else:
			self.store[key].append((value, timestamp))

			def get_(self, arr: s):
		low = self.store.k]
		low, 0
	
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 33000
----------------------------------------------------------------------------------------------------
<INPUT>
: 1 <= words[i].length, result.length <= 7
words[i], result contains only upper case English letters.
Number of different characters used on the expression is at most 10.Given an array nums and an integer target.
Return the maximum number of non-empty non-overlapping subarrays such that the sum of values in each subarray is equal to target.
 
Example 1:
Input: nums = [1,1,1,1,1], target = 2
Output: 2
Explanation: There are 2 non-overlapping subarrays [1,1,1,1,1] with sum equals to target(2).

Example 2:
Input: nums = [-1,3,5,1,4,2,-9], target = 6
Output: 2
Explanation: There are 3 subarrays with sum equal to 6.
([5,1], [4,2], [3,5,1,4,2,-9]) but only the first 2 are non-overlapping.
Example 3:
Input: nums = [-2,6,6,3,5,4,1,2,8], target = 10
Output: 3

Example 4:
Input: nums = [0,0,0], target = 0
Output: 3

 
Constraints:

1 <= nums.length <= 10^5
-10^4 <= nums[i] <= 10^4
0 <= target <= 10^6Think about Zuma Game. You have a row of balls on the table, colored red(R), yellow(Y), blue(B), green(G), and white(W). You also have several balls in your hand.

Each time, you may choose a ball in your hand, and insert it into the row (including the leftmost place and rightmost place). Then, if there is a group of 3 or more balls in the same color touching, remove these balls. Keep doing this until no more balls can be removed.

Find the minimal balls you have to insert to remove all the balls on the table. If you cannot remove all the balls, output -1.


Examples:
Input: "WRRBBW", "RB"
Output: -1
Explanation:
<PREDICTION>
: , i[i]length <= 1words[length ==<= 
	.i] words[<ains  of case letters letters.

 of words letters in to the same. the most onewords letters
 a array ofs, an array k.
Return the number number of moves-empty subin-emptylapping subarrays of that the sum of the is the subarr is less to target.

Example 1:
Input: nums = [1,2,1,1,1, target = [
Output: 2
Explanation: The are only ways-emptylapping subarrays:1,1,1,1,1, and 2 2 to target.1).

Example 2:
Input: nums = [1,1,1,1,1,5],1, target = 2
Output: 2
Explanation: There are 2 nonarrays [ sum = to target.

1,1, [5,1, [5,1,1],1,1,1,
 we the sum sub sub the-overlapping sub

 3:
Input: nums = [-1,3,5,1,1,1,1,1,1, target = 2
Output: 2
ExExample 4:
Input: nums = [-1,1,1, target = 2
Output: 0
 
Constraints:

1 <= nums.length <= 10target^5
110^9 <= nums[i] <= 1010^4
1 <= target <= 10^4Given
 thez's-
 are to little of the. the ball. and the,i, blue (R, blue(Y), blue(Y), blue blue(B)
 have have a balls on the table.

The ball you the have move a color from the hand. and you it to the ball wherethe the ball or one). themost place).
, you you are a ball of balls balls more balls in the box row, the then the balls.
 in that problem you one color are be used.

Given the minimum number you can to spend all the all the balls in the table.

 you have find all the balls from return -1.


Example:

: ballsR""W" "RG
Output: "1
Explanation:

----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 33500
----------------------------------------------------------------------------------------------------
<INPUT>
:  in self.prime_numbers:
	  if p > border: break
	  while n % p == 0: res[p] = res.get(p, 0)+1; n //= p
	  if n == 1: return res
	res[n] = 1; return res

  def prime_factorize_factorial(self, n):
	res = dict()
	for i in range(2, n+1):
	  for p, c in self.prime_factorize(i).items(): res[p] = res.get(p, 0)+c
	return res
  
  @staticmethod
  def gcd(a, b): return gcd(b, a%b) if b else abs(a)

  @staticmethod
  def lcm(a, b): return abs(a // gcd(a, b) * b)

  @staticmethod
  def find_divisors(n):
	divisors = []
	for i in range(1, int(n**.5)+1):
	  if n%i: continue
	  divisors.append(i)
	  j = n // i
	  if j != i: divisors.append(j)
	return divisors
  
  @staticmethod
  def base_convert(n, b):
	if not n: return [0]
	res = []
	while n:
	  n, r = divmod(n, b)
	  if r < 0: n += 1; r -= b
	  res.append(r)
	return res


class UnionFind():
  def __init__(self, n=10**6):
	self.root = list(range(n))
	self.height = [0] * n 
	self.size = [1] * n 
  
  def find_root(self, u):
	if self.root[u] == u: return u
	self.root[u] = self.find_root(self.root[u])
	return self.root[u]
  
  def unite(self, u, v):
	ru = self.find
<PREDICTION>
:  range.parents_factums:
		 self self in self:

	  if p % p == 0: n.n] = res.get(p, 0)1
 n //= p
	  if n > 1: return res
	  =p] = res
 return res
  def prime_factorize(factors(self, n):
	res = []()
	for i in range(2, int+1):
	  res p in c in self.prime_nize(i).items(): res[p] = res.get(p, 0)c
	return res


 def
  defstaticmethod
  def gcd(a, b): return gcd(b, a%b) if b else abs(a)

  @staticmethod
  def lcm(a, b): return abs(a // gcd(b, b) * b)

  @staticmethod
  def find_primeisors(n):
	divisors = []
	for i in range(1, int(n**05)+1):
	  if n %i== continue
	  divisors.append(i)
	  j = n // i
	  if j != i: divisors.append(j)
	return divisors
  
  @staticmethod
  def g_divvert(n): mod):
	return n n: return []0]
	res = []
	for n:
	  res // r = divmod(n, b)
	  if r == n: res += 1
 r += b
	  res.append(r)
	return res
 class UnionFind():
  def __init__(self, n):10**6):
	self.parent = list(range(n))
	self.size = [0]* n

	self.size = [0] * n

	 def
  def find(root(self, x):
	if u.root[u] == u:
 u
	self.root[u] = self.find_root(self.root[u])
	return self.root[u]
  
  def find(self, u, v):
	u = self.find_
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 34000
----------------------------------------------------------------------------------------------------
<INPUT>
: 
		return s

	# i番目の要素にxを足す
	# 覆ってる区間すべてに足す
	def add(self, i, x):
		while i <= self.max:
			self.data[i] += x
			i += i & -i

	def insert(self, x):
		self.add(x, 1)

	def delete(self, x):
		self.add(x, -1)

	def count(self, x):
		return self.query_sum(x) - self.query_sum(x-1)
	
	def length(self):
		return self.query_sum(self.max)
	
	# 下からc番目(0-indexed)の数
	# O(log(N))
	def search(self, c):
		c += 1
		s = 0
		ind = 0
		l = self.max.bit_length()
		for i in reversed(range(l)):
			if ind + (1<<i) <= self.max:
				if s + self.data[ind+(1<<i)] < c:
					s += self.data[ind+(1<<i)]
					ind += (1<<i)
		if ind == self.max:
			return False
		return ind + 1
	
	def bisect_right(self, x):
		return self.query_sum(x)

	def bisect_left(self, x):
		if x == 1:
			return 0
		return self.query_sum(x-1)

	# listみたいに表示
	def display(self):
		print('inside BIT:', end=' ')
		for x in range(1, self.max+1):
			if self.count(x):
				c = self.count(x)
				for _
<PREDICTION>
: 			 max[	def if =�目の要素を�を樳す
	# s���たい�間にる�てのx��す
	# get(x, x, x):
		# i < self.sizesize
			self.i[i] += x
			i += i & -i

	# get(self, k,
		self.data(x) 1)
	def get(self, x,
		self.add(x, -1)

	def get(self): x):
		return self.size(count(x) - self.query_sum(x)1)



	def add(self):
		return self.size_sum(x.data)



	def �事�ら�に�目のx)index))
��
	def (nnn))
	def add(self, x):
		return = self
		c = 0
		for = 0
		while = 0.size
bit_length()
		while i in range(list(l)):
			if c == ii <<i) <= c.n:
				s s == (.search[ind]1<<i) == self:
					s += self.data[ind]1<<i)]
					ind += (1<<i)
			 s != len.max:
			return -
		return True == (
			# addect_left(self, x):
		l self.search_sum(x) -	def addect_left(self, x):
		return x <= 0:
			return 0
		if 1.query_sum(x)1)
	def �(��いな、�示す	def bis(self,
		print( '.')( {} self= ')
		print i in self(self, self.max+1):
			print x.query(x)
				print = self.count(x)
				self i in
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 34500
----------------------------------------------------------------------------------------------------
<INPUT>
: .

 You are a member of the “Conservative Party” and you party is trying to pass a bill. The “Reformist Party” is trying to block it.

 In order for a bill to pass, it must have a majority vote, meaning that more than half of all members must approve of a bill before it is passed . The "Conservatives" and "Reformists" always vote the same as other members of thier parties, meaning that all the members of each party will all vote yes, or all vote no .

 However, independants vote individually, and the independant vote is often the determining factor as to whether a bill gets passed or not.

 Your task is to find the minimum number of independents that have to vote for your party's (the Conservative Party's) bill so that it is passed .

 In each test case the makeup of the Parliament will be different . In some cases your party may make up the majority of parliament, and in others it may make up the minority. If your party is the majority, you may find that you do not neeed any independants to vote in favor of your bill in order for it to pass . If your party is the minority, it may be possible that there are not enough independants for your bill to be passed . If it is impossible for your bill to pass, return `-1`.

# Input/Output


 - `[input]` integer `totalMembers`

  The total number of members.


 - `[input]` integer `conservativePartyMembers`

  The number of members in the Conservative Party.


 - `[input]` integer `reformistPartyMembers`

  The number of members in the Reformist Party.

 
 - `[output]` an integer

  The minimum number of independent members that have to vote as you wish so that the bill is passed, or `-1` if you can't pass it anyway.
  
# Example

 For `n = 8, m = 3 and k = 3`, the output should be `2`.
 
 It means: 
 ```
 Conservative Party member --> 3
 Reformist Party member   --> 3
 the independent members --> 8 - 3 - 3 = 2
 If 2 independent members change their minds
 3 + 2 > 3
 the bill will be passed.
 If 1 independent members change their minds
 perhaps the bill will be failed

<PREDICTION>
: append
 have given list of the problem�a�”  � are. a to find the new. You bill�a}.ally�” and the to find the.

 this to the given, the the you is be a value of. so that the is the of the the of be. the bill. the is. to
 billNot"" is "Cformist of is is. ". the as. theac.. but that the the elements of the other is be be.. but if the will other

, the, of,, you you " of of. not given same of of the the the bill is the in not.


 task is to find the maximum number of operations that you a be in the help. orderor bill is is name

 to that the is impossible.


 this of case, bill of the bill of be passed from

 this case the task, be the to " of the, or the the the is be up the same of

 theIt is not one of you need make the the get not needig. of.. the. the. the way. your to your. get.
 youIt is the same of you is make able to have is no the to that in the what. go given in
 the is the to yourIt to be the it -True1`.


Note Example/Output


 - `[input]` integer `n``

   number number of elements of

 - - `[input]` integer `total```

  The total of members. the bill..


 - `[input]` integer `coclally```

  The total of members in the given. and.


 The - `[input]` an integer

  The minimum number of members elements. have to be in you have to that the number will to. so `-1`

 the want't make in in.




  Example
 For `total = 2`, n = 3`, n = 5`, the output should be `-`
 ``
 For's that

 `
  (
 
 ``er --> --> --> -->  4
  result members
 4
 2
 2 - 2
  you is members --> --> last
 ``- 3 + 3 + `` other is be 2.
`` the, members change their last
 4 2 number will be passed.

----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 35000
----------------------------------------------------------------------------------------------------
<INPUT>
: a[i])
		p4.append(b[i])

for p in (p1, p2, p3, p4):
	if len(set(p)) == n:
		print(' '.join(str(x) for x in p))
		return

for p in (p1, p2, p3, p4):
	if len(set(p)) == n - 1:
		distinct = 0
		dpos = 0
		for i, (x, y) in enumerate(zip(p, a)):
			if x != y:
				distinct += 1
				dpos = i
		if distinct == 1:
			unused = 1
			while unused in p:
				unused += 1
			pp = list(p)
			pp[dpos] = unused
			print(' '.join(str(x) for x in pp))
			return

assert False
#!/usr/bin/env python3
from sys import stdin, stdout

def rint():
	return list(map(int, stdin.readline().split()))
#lines = stdin.readlines()


n = int(input())

a = list(rint())
b = list(rint())

ii = []
for i in range(n):
	if a[i] != b[i]:
		ii.append(i)

if len(ii) == 2:
	if a[ii[0]] != a[ii[1]]:
		c = a[:]
	else:
		c = b[:]
	if c.count(c[ii[0]]) == 2:
		iii = ii[0]
	else:
		iii = ii[1]
else:
	c = a[:]
	iii = ii[0]


for i in range(n):
	if not i+1 in c:
		c[iii] = i+1
		print(*c)
		return

n = int(input())
a = list(map
<PREDICTION>
: [i]
			 = =append(a[i])
	print i in pp1, p2): p3): p4):
	if a(p(a)) == 1:
		print(YESjoin(map(p) for x in p))
		return

print p in pp1, p2, p3, p4):
	if len(set(p)) == n: 1:
		print = = (
		for = = set
		for i in ax, y) in enumerate(p(p1 p[):
			dist x == p:
				distinct += 1
				distpos += i
			 len == n:
			breakused = True
			break un: d:
				pused += 1
				 = p(p)
			for.0pos] = p
			for( '.join(pp(x) for x in p))
			return

print(

!/usr/bin/env python3

 collections import stdin, stdout

def rint():
	return list(map(int, stdin.readline().split()))
#lines = stdin.readlines()

def, int(input())
ap = list(rint())

 = list(rint())

p = 0

 i in range(n):
	ii a[i] == b[i]:
		ii.append(i)

for len(ii) == 0:
	print len[0[0]] == b[ii[1]]:
		printnt [[ii
		:
		c = a[ii
	c len ==count(c)0[0]]) == n:
		print = a[0]
		:
		print = c[1]

:
	print = c[ii
	if = len[1]

if i in range(len):
	if a c in1 in ii:
		c[ii] = c
1

	c(c)
		break

 = int(input())
a = list(map(
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 35500
----------------------------------------------------------------------------------------------------
<INPUT>
: **9
  tmp = (min_val+max_val)//2
  prev_price = 0
  
  while 1:
	price = A*tmp + B*len(str(tmp))
	if price == prev_price:
	  print(tmp)
	  break
	
	if price < X:
	  min_val = tmp
	  tmp = (min_val+max_val)//2
	elif price > X:
	  max_val = tmp
	  tmp = (min_val+max_val)//2
	else:
	  print(tmp)
	  break
	prev_price = priceimport math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time, copy

sys.setrecursionlimit(10**7)
inf = 10**20
mod = 10**9 + 7

stdin = sys.stdin

ni = lambda: int(ns())
na = lambda: list(map(int, stdin.readline().split()))
ns = lambda: stdin.readline().rstrip()  # ignore trailing spaces

A, B, X = na()
ans = 0
for dn in range(18 + 1):
	s = X - dn * B
	tmp = s // A
	N = min(tmp, 10**9)
	if len(str(N)) == dn:
		ans = max(ans, N)
	else:
		t = 10 ** dn - 1
		if N >= t:
			ans = max(ans, t)
print(min(ans, 10 ** 9))H,W,K=map(int,input().split())
P=[]
for i in range(H):
	s=input()
	a=[]
	for j in range(W):
		a.append(s[j])
	P.append(a)
	
ans=0
for markR in range(2**H):
	for markC in range(2**W):
		black=0
		for i in range(H):
			for
<PREDICTION>
: (+	
 = 0a(a +tmp_val)%2
  print =val = tmp
  for
  for tmp:
	if = min[min
 B*tmp(A(A))
	if price > 0_price:
	  break(prev)
	  break
	el	if price > prev:
	  break_price = price
	  prev = (min_val +max_val)//2
	 if price > X:
	  min_val = tmp
	  prev = (max_val+max_val)//2
	else:
	  min(tmp)
	  break
	 _price = tmp
 sys
string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time, copy,
sys.setrecursionlimit(10**7)
inf = 10**20
mod = 10**9 + 7

defin = sys.stdin

ni = lambda: int(ns())
n = lambda: list(map(int, stdin.readline().split()))
nb = lambda: stdin.readline().rstrip()  # ignore trailing spaces

def,B, C = ns()
A = 0
for i in in range(1): 1):
	ans = n * nn
 n
	ans = ( // math
	ans = min(N, N **5 +
	ans ans(str(tmp)) <= 0n:
		ans += ((ans, tmp)
		:
		ans = N** 9n
 1
		tmp len <= 0:
			ans = max(ans, N)
print(ans(ans, X** 9))
, W,X =map(int,input().split())
a=list
for i in range(H):
	p=list()
	for=0
	for j in range(W):
		if.append(int[j])
	P.append(a)

Hans=0
for i in in range(2**H):
	flag markL in range(2**W):
		if=0
		for i in range(H):
			if j
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 36000
----------------------------------------------------------------------------------------------------
<INPUT>
: 	if c not in p: p[c] = {}
				p = p[c]
			p['#'] = w
		self.p = [self.trie]

	def query(self, letter: str) -> bool:
		self.history+=letter
		self.p = [p[letter] for p in self.p if letter in p]
		res = any(['#' in p for p in self.p])
		self.p+=[self.trie]
		return res

# Your StreamChecker object will be instantiated and called as such:
# obj = StreamChecker(words)
# param_1 = obj.query(letter)
class StreamChecker:

	def __init__(self, words: List[str]):
		self.trie = {}
		self.waitlist = []
		for word in words:
			head = self.trie
			for char in word:
				if char not in head:
					head[char] = {}
				head = head[char]
			head['#'] = '#'

	def query(self, letter: str) -> bool:
		waitlist = []
		# if letter can be the prefix of word
		if letter in self.trie:
			waitlist.append(self.trie[letter])
		# for each possible prefix, append letter if the new substr still can be a prefix
		for item in self.waitlist:
			if letter in item:
				waitlist.append(item[letter])
				
		self.waitlist = waitlist
		return any('#' in item for item in self.waitlist)


# Your StreamChecker object will be instantiated and called as such:
# obj = StreamChecker(words)
# param_1 = obj.query(letter) 
class StreamChecker:

	def __init__(self, words: List[str]):
		self.words = set(words)
		self.query_history = \"\"
<PREDICTION>
: 	 i == in visited:
[c] = 0
		ppp[ p[c]
				[#'] = True
			.p = pw.prie]
	def query(self, letter: str) -> bool:
		#.p +=letter
		if.p = selfself]letter] for letter in self.p] letter in p]
		return = False('['#'] in p for p in self.p]
		return.p ==[-.trie]
		return any
	# Your StreamChecker object will be instantiated and called as such:
# obj = StreamChecker(words)
# param_1 = obj.query(letter)
class StreamChecker:

	def __init__(self, words: List[str]):
		self.trie = {}
		for.words = = []
		for word in words:
			node = self.trie
			for c in word:
				if char not in head:
					head[char] = {}
				head = head[char]
				['#'] = '#'

	def query(self, letter: str) -> bool:
		waitlist = []
		if if letter can be the tri of word
		if letter in self.trie:
			waitlist.append(self.trie[letter])
			 for each possible prefix, append it if the newmost still can be a prefix
		for item in self.waitlist:
			if letter in item:
				waitlist.append(item[letter])
		self	
		self.waitlist = waitlist
		return any('#' in item for item in self.waitlist)

# Your StreamChecker object will be instantiated and called as such:
# obj = StreamChecker(words)
# param_1 = obj.query(letter)

class StreamChecker:

	def __init__(self, words: List[str]):
		self.t = set(words)
		self.t_size = \"\"

----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 36500
----------------------------------------------------------------------------------------------------
<INPUT>
:  - a[0]
fl = True
for i in range(2,n):
	cd = a[i] - a[i-1]
	if d != cd:
		fl = False
		break
	
if fl:
	print(a[n-1] + d)
else:
	print(a[n-1])
def weatom(s=[]):
	n=len(s)
	if(n==1):
		return s[0]
	elif(n==2):
		return (s[1] + (s[1]-s[0]))
	else:
		d=s[1]-s[0]
		for i in range(2,n):
			if((s[i]-s[i-1])==d):
				if(i==n-1):
					return (s[i] + d)
			else:
				return s[n-1]
		   

def main():
	t=input()
	t=int(t)
	s=[int(x) for x in input().strip().split()]
	print(weatom(s))
	
def __starting_point():
	main()
__starting_point()import sys
input = sys.stdin.readline

n=int(input())
E=[list(map(int,input().split())) for i in range(n-1)]

D=[0]*n

for x,y in E:
	D[x-1]+=1
	D[y-1]+=1

if 2 in D:
	print("NO")
else:
	print("YES")
n = int(input())
adj = [[] for i in range(n)]
for _ in range(n-1):
  u, v = map(int, input().split())
  adj[u-1].append(v)
  adj[v-1].append(u)

for v in adj:
  if len(v) == 2:
	print('NO')
	break
else:
  print('
<PREDICTION>
:  1[i]
	 = True
for i in range(n, n):
	if = a[i]
 a[i-1]
	ifcd >= 0:
		fl = False
		break
ififif fl:
	print("i[0-1]) + a)
else:
	print(a[n-1]
n main_(a):0):
	if =len(s)
	for sn==1):
		return True
0]
	forif(n==2):
		return ss[0]== ss[2]s[0]))) %	else:
		return=s[1]s[0]
		for i in range(2,n):
			d(d[i]s[i-1])%d):
				return(s==0-1):
					return ss[i] + ()
				:
				return ([i-1]
		return  
	n main():
	n =int()
	for=t(t)
	for=int(i) for x in input()split()split()]
	n(sbi(s))


main __starting_point():
	main()
__starting_point()n sys

 = sys.stdin.readline

n =int(input())
A=[[](map(int,input().split())) for i in range(n-1)]

E=[0]*n
forfor i,y in E:
 if[x-1]+=1
	D[y-1]+=1

for D* D:
	print(YES")
	:
	print("YES")
	 = int(input())
a = [[] for i in range(n)]
for i in range(n-1):
	 a,v = map(int, input().split())
  adj[u-1].append(v-
  adj[v-1].append(u)

def i in range:
  print len(adj) == 0:
	print("NO')
	return
else:
  print('YES
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 37000
----------------------------------------------------------------------------------------------------
<INPUT>
: 19

Input
2

Output
28



-----Note-----

The first perfect integer is $19$ and the second one is $28$.Calculate the number of ways to place $n$ rooks on $n \times n$ chessboard so that both following conditions are met:

  each empty cell is under attack;  exactly $k$ pairs of rooks attack each other. 

An empty cell is under attack if there is at least one rook in the same row or at least one rook in the same column. Two rooks attack each other if they share the same row or column, and there are no other rooks between them. For example, there are only two pairs of rooks that attack each other in the following picture:

 [Image] One of the ways to place the rooks for $n = 3$ and $k = 2$ 

Two ways to place the rooks are considered different if there exists at least one cell which is empty in one of the ways but contains a rook in another way.

The answer might be large, so print it modulo $998244353$.


-----Input-----

The only line of the input contains two integers $n$ and $k$ ($1 \le n \le 200000$; $0 \le k \le \frac{n(n - 1)}{2}$).


-----Output-----

Print one integer — the number of ways to place the rooks, taken modulo $998244353$.


-----Examples-----
Input
3 2

Output
6

Input
3 3

Output
0

Input
4 0

Output
24

Input
1337 42

Output
807905441Vasya has got many devices that work on electricity. He's got n supply-line filters to plug the devices, the i-th supply-line filter has a_{i} sockets.

Overall Vasya has got m devices and k electrical sockets in his flat, he can plug the devices or supply-line filters directly. Of course, he can plug the supply-line filter to any other supply-line filter. The device (or the supply-line filter) is considered plugged to electricity if it is either plugged to one of k electrical sockets, or if it is plugged to some supply-line filter that is in turn plugged to electricity.
<PREDICTION>
: ,	Output
3
1Output
3


-----Note-----

In first example square in shown1$ and $ second perfect is $1$
culate the number of the to divide the1$ by.. the1$times n$ (board. that the of conditions are met:   $ of cell contains either $ $  each $1$- of cellss ( and other. 

The example cell is under attack. there is a least one cells the cell cell or the least one more in the same column.  wayss attack each other. there are a same color or column. and they is no more cells in attack the.

 example, if are $ one possible of robots attack have each other. the following way:

 Image]  can the possible are place $ firsts the then$ 10$; thek = 3$;

The moves to place the kings for: different if they is a least one rook in are in. the of the two. there $ pairs the case.

You answer can be very, so you it modulo $998244353$.


-----Input-----

The first line of the input contains one integers $n$ and $k$ ($1 \le n \le 10\,; $1 \le k \le nmin{n}{n - 1)}{2}$)


-----Output-----

Print the integer  the number of ways to place the rooks for mod inulo $998244353$.


-----Examples-----
Input
3


Output
1

Input
4 2

Output
4

Input
4 2

Output
4

Input
4 4


Output
437





asya has a a coins. is. the. He has got a- oflike.. the. number. the i-th of-line.. a numberi} distinct.

V,ya has got a distinct. the-.. the own. so wants use the same in the-linemap..
 course, he is use the same-linereplace. the other.-linemap.
 i isi the number oflinemap is of a as if the. he is possible a or the of the or or or or if there is not to one of oflinemap. is not the, to the.

----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 37500
----------------------------------------------------------------------------------------------------
<INPUT>
:  ', local_len)
	is_possible = False
	diff = abs(x_d - x_l) + abs(y_d - y_l)
	if diff <= local_len and (diff + local_len) % 2 == 0:
		is_possible = True
	# print('\t', x_l, y_l, abs(x_d - x_l), abs(y_d - y_l), local_len, is_possible)
	for i in range(local_len, n):
		if is_possible:
			break
		d_old, d_new = d[s[i]], d[s[i - local_len]]
		x_l, y_l = x_l - d_old[0] + d_new[0], y_l - d_old[1] + d_new[1]
		# print('\t', x_l, y_l, abs(x_d - x_l), abs(y_d - y_l), local_len)
		diff = abs(x_d - x_l) + abs(y_d - y_l)
		if diff <= local_len and (diff + local_len) % 2 == 0:
			is_possible = True
	# print(l, r, local_len, current_sol, is_possible)
	if is_possible:
		current_sol = local_len
		r = local_len - 1
	else:
		l = local_len + 1
print(current_sol)# -*- coding: utf-8 -*-

"""
created by shhuan at 2018/11/3 11:30


search for minimum steps, consider binary search

"""

N = int(input())
ops = [x for x in input()]

X, Y = list(map(int, input().split()))

dd = abs(X) + abs(Y)
lops = len(ops)
# if dd > lops or (lops - dd) % 2 != 0:
#	 print(-1)
#
<PREDICTION>
:  '_size)
		_okossible = True
	for = 0(x -a - x_d) + abs(y_d - y_l)
	if is == 0_len: isx <= x_len - % 2 == 0:
		is_possible = True
		 print(is033 + diff_l, y_l, x(x_d - x_l), abs(y_d - y_l)) abs_len) diff_possible)
	if i in range(1_len): x):
		if x_possible:
			if
		if =l = d_old = abs_i]i]], d[s[i]] 1_len]]
		if_d = y_l = x_l, x_old,0], + d[old[1], y_l - d_old[1]
 d_old[1]
		if print('xt', x_l, y_l, d(x_d - x_l), abs(y_d - y_l), abs_len,
		if = abs(x_d - x_l) + abs(y_d - y_l)
		if diff <= local_len and (diff + local_len) % 2 == 0:
			is_possible = True
		 print('x, d, d_len, is_diff, diff_possible)
	if is_possible:
		print_sol = min_len
		if = (_len
 1
		:
		if = local_len - 1
	(min_sol)
!/*- coding: utf-8 -*-
"""import

 by shuuan at 2017/10/20/:30

@_ the value to a all search

"""

import = int(input())
X = list0 for x in input().]

# = Y = [(map(int, input().split()))

def = {}(X -
 abs(Y)

 = = [(X)

 print N == 0ops: ddlops == dd) % 2 == 0:
#	 print(1)

	
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 38000
----------------------------------------------------------------------------------------------------
<INPUT>
: 
  "/\\",
  "\\/"
]
Output: 5
Explanation: (Recall that because \ characters are escaped, "/\\" refers to /\, and "\\/" refers to \/.)
The 2x2 grid is as follows:



Example 5:
Input:
[
  "//",
  "/ "
]
Output: 3
Explanation: The 2x2 grid is as follows:


 
Note:

1 <= grid.length == grid[0].length <= 30
grid[i][j] is either '/', '\', or ' '.There are N workers.  The i-th worker has a quality[i] and a minimum wage expectation wage[i].
Now we want to hire exactly K workers to form a paid group.  When hiring a group of K workers, we must pay them according to the following rules:

Every worker in the paid group should be paid in the ratio of their quality compared to other workers in the paid group.
Every worker in the paid group must be paid at least their minimum wage expectation.

Return the least amount of money needed to form a paid group satisfying the above conditions.
 



Example 1:
Input: quality = [10,20,5], wage = [70,50,30], K = 2
Output: 105.00000
Explanation: We pay 70 to 0-th worker and 35 to 2-th worker.


Example 2:
Input: quality = [3,1,10,10,1], wage = [4,8,2,2,7], K = 3
Output: 30.66667
Explanation: We pay 4 to 0-th worker, 13.33333 to 2-th and 3-th workers seperately. 

 
Note:

1 <= K <= N <= 10000, where N = quality.length = wage.length
1 <= quality[i] <= 10000
1 <= wage[i] <= 10000
Answers within 10^-5 of the correct answer will be considered correct.Given an equation, represented by words on left side and the result on right side.
You need to check if the equation is solvable under the following rules:

Each character is decoded as one digit (0 - 9).
Every pair of different characters they must map to different digits.
Each
<PREDICTION>
: 
Example
 "/a",","

: "
Explanation: theall that is thetext in not as and"", is, ",s and "\\","" ",\

 strings3 is is [ follows:

 1 2:

: grid
[" [abc", " """,[
Output: 4
Explanation: ( 3x2 grid is as follows:


 "
:

1 <= .length <= grid[i].length <= 1000
grid[0][j]   0' or\\0 or '-join is no  in 
 number-th of in a weight valuei]  a worker of of..i]. The, have to know the the of. the a new.. 
 the is worker is K,, it need choose the in to the group rules:

- worker is the group group is be in to the group group the weights group group the worker group the form group.

 worker in the worker group should be able into most K position...
ReturnExample the maximum number of the that to achieve a worker group. the condition rules.
 

ExampleExample 1:

: [ = [1,20,20, K = [20,30,60],target = 3
Output: 5
 
Explanation: The can 1 = get.9 worker, 1- 1-th worker,

Example 2:
Input: key = [10,5,2],5],5], K = [5,2,5,1],2], K = 3
Output: 6.00000000
Explanation: We pay 70 = 1-th worker. and-

., 0-th worker 1-th worker.ishets.




Note:

1 <= K <= 10000
 10
  N is 1[length  N.length 1 <= K.i] <= 10.1 <= K[i] <= 10000.1 integer is the^(-6  the given answers. be accepted correct.Given an array of return as a, a and- right following of the side.
Return are to return whether the given is validized.if the following::
-- element in aoded to a- from0- 1)
The character of characters digits in are be. the digits (
Return character
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 38500
----------------------------------------------------------------------------------------------------
<INPUT>
: 	if n == 64 :
		return 5
	if n == 65 :
		return 5
	if n == 66 :
		return 4
	if n == 67 :
		return 5
	if n == 68 :
		return 5
	if n == 69 :
		return 5
	if n == 70 :
		return 6
	if n == 71 :
		return 5
	if n == 72 :
		return 4
	if n == 73 :
		return 4
	if n == 74 :
		return 4
	if n == 75 :
		return 4
	if n == 76 :
		return 4
	if n == 77 :
		return 4
	if n == 78 :
		return 4
	if n == 79 :
		return 4
	if n == 80 :
		return 4
	if n == 81 :
		return 5
	if n == 82 :
		return 4
	if n == 83 :
		return 4
	if n == 84 :
		return 4
	if n == 85 :
		return 5
	if n == 86 :
		return 4
	if n == 87 :
		return 4
	if n == 88 :
		return 4
	if n == 89 :
		return 4
	if n == 90 :
		return 5
	if n == 91 :
		return 4
	if n == 92 :
		return 4
	if n == 93 :
		return 4
	if n == 94 :
		return 5
	if n == 95 :
		return 5
	if n == 96 :
		return 4
	if n == 97 :
		return 4
	if n == 98 :
		return 5
	if n == 99 :
		return 5
	if n == 100 :
		return 3
	if n == 101 :
		return 4
	if n == 102 :
		return 4
	if n == 103 :
		return 4
	if n == 104 :
		return 5
	if n == 105 :
		return 4
	if n == 106 :
	
<PREDICTION>
: 	 ( % 0:
			 0
	if n == 64 :
		return 6
	if n == 65 :
		return 6
	if n == 6534
		return 5
	if n == 66 :
		return 6
	if n == 65 :
		return 6
	if n == 69 :
		return 6
	if n == 69 :
		return 7
	if n == 7 :
		return 7
	if n == 79 :
		return 5
	if n == 79 :
		return 5
	if n == 77 :
		return 5
	if n == 77 :
		return 5
	if n == 77 :
		return 5
	if n == 77 :
		return 5
	if n == 77 :
		return 5
	if n == 79 :
		return 5
	if n == 16 :
		return 5
	if n == 16 :
		return 6
	if n == 85 :
		return 5
	if n == 85 :
		return 5
	if n == 85 :
		return 5
	if n == 88 :
		return 6
	if n == 87 :
		return 5
	if n == 87 :
		return 5
	if n == 88 :
		return 5
	if n == 89 :
		return 5
	if n == 90 :
		return 6
	if n == 90 :
		return 5
	if n == 23 :
		return 5
	if n == 93 :
		return 5
	if n == 93 :
		return 6
	if n == 96 :
		return 6
	if n == 96 :
		return 5
	if n == 97 :
		return 5
	if n == 98 :
		return 6
	if n == 98 :
		return 6
	if n == 100 :
		return 5
	if n == 101 :
		return 5
	if n == 11 
		return 5
	if n == 105 :
		return 5
	if n == 108 :
		return 5
	if n == 105 :
		
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 39000
----------------------------------------------------------------------------------------------------
<INPUT>
: for k in reversed(list(range(K))):
			dp[k] = S / float(W)
			S += dp[k] - dp[k + W]

		return dp[0]
		
#		 # solution 2: time and space limit exceeded
#		 # dp(n, k) = 1 / W * ( sum pt in range(1, W+1) over dp(n-pt, k-pt) )
		
#		 memo = {}
#		 def dp(n, k):
#			 if (n, k) not in memo:
#				 if k <= 0:
#					 ans = int(n >= 0)
#				 else:
#					 ans = 0
#					 for pt in range(1, W+1):
#						 ans += dp(n-pt, k-pt)
#					 ans *= 1. / W
#				 memo[n, k] = ans
#			 return memo[n, k]
#		 return dp(N, K)
class Solution:
	def new21Game(self, N: int, K: int, W: int) -> float:
		if K == 0:
			return 1
		
		dp = [0]
		cur, temp = 1, 1/W
		for i in range(1, W+1):
			dp.append(cur/W)
			if i < K:
				cur += dp[-1]
			
		# print(dp)
		total = sum(dp[1:min(W+1, K)])
		left = 1
		for i in range(W+1, W+K):
			dp.append(total/W)
			total -=  dp[left]
			left += 1
			if i < K:
				total += dp[-1]
		# print(dp
<PREDICTION>
:  i in range(list(range(len))):
				[i] = d[ ((dp[
			if = strp[k]
 dp[k] 1]
	returnreturn dp[K]

class					 d n
: [ O O <=

#		 # timep[i) k) = min
 float
 Wn() d(1, n))1)) +)p)n,1, 1))W, +
#	
#		 # = {}
#		 def dp(n, k):
#			 if nn, k) in in memo:
#				 if n == 0:
#					 if = float(n/ 0)
#					:
#					 ans = float
#				 memo for i in range(1, n+1):
#						 ans = dp(n-pt, k-pt)
#					 memo == (
0 (
#				 memo[(] k] = ans
#			 return memo[n, k]
			 memo dp(n, K)
	 Solution:
	def super21GameIIself, N: int, K: int, W: int) -> float:
		
 K == 1:
			return 1
		if		dp = [None] *		for = ans = 1, 0
W
		for i in range(1, K+1):
			cur.append(cur/W)
			cur i == W:
				cur = Wp[i1]
							 print(dp)
		return = 0(dp)K:])(W,1) K+])
		return = 0
		right i in range(1+1): K+1+
			left[append(cur/i)
			if += d dp[i]
			left += 1
			
 i < K:
				dp += dp[i1]
			 print(dp)
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 39500
----------------------------------------------------------------------------------------------------
<INPUT>
: 		  
		
		# get amount of below threshold cities
		res = Counter()
		for i, row in enumerate(matrix):
			for j, dist in enumerate(row):
				if dist <= distanceThreshold and i != j :
					res[i] += 1
		
		best = 0
		for i in range(n):
			if res[i] <= res[best]:
				best = i
		return best
		
		# check if unconnected cities
		unconnected = []
		i = 0
		while i < n:
			if res[i] == 0:
				# not conencted
				unconnected.append(i)
			i += 1
				
		if len(unconnected) == 1:
			return unconnected[0]
		elif len(unconnected) > 1:
			return max(unconnected)
			
		# all cities are connected with each other, get min value
		ans = min(res.values())
		max_city = 0
		
		# if multiple cities with same minimum neighbours, select biggest one
		for city in range(len(res)):
			if res[city] <= ans and city > max_city:
				max_city = city
				

		return max_cityclass Solution:
	def findTheCity(self, n: int, edges: List[List[int]], distanceThreshold: int) -> int:
		storage = [[30000 if i != j else 0 for i in range(n) ] for j in range(n)]
		for edge in edges:
			storage[edge[0]][edge[1]] = edge[2]
			storage[edge[1]][edge[0]] = edge[2]
		
		#FloydWarshallAPSP
		for k in range(0, n):
			for i in range(0, n):
	
<PREDICTION>
: 		

					
	 the of coins int

		# = 0()
		
 i in n in enumerate(A):):
			for j, v in enumerate(row):
				if dist < thresholdThreshold: i != j:
					res[i] += 1
					for = 0
		for i in range(len):
			if res[i] > best[i]:
				best = res
			 bestclass					
 get if thevis
 are		#connected = {}
		for = 0
		while i < n:
			if i[i] <= 0:
				un check connectedconnectedateate
				unconnected.append(i)
				 += 1
		


		# i(unconnected) > 1:
			return lenconnected
0]
		
if len(unconnected) == 1:
			return -(unconnected)
		else
		return check cities in connected
 edges other
 i the cost
		for = 0(res.values())
		return_city = 0
		for		for check len cities are same distance possible
 then a

		for city in un(n(un)):
			if res[city] != res: res != city_city:
				ans_city = city
				ans		# max_cityclass Solution:
	def findTheCity(self, n: int, edges: List[List[int]], distanceThreshold: int) -> int:
		graph = [[floate for i != j else 0 for i in range(n)] ] for j in range(n)]
		
 i in edges:
			if[edge[0]][edge[1]] = edge[2]
			
[edge[1]][edge[0]] = edge[2]
		
		def printoydWarshall


		for k in range(n, n):
			for i in range(0, n):
		
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 40000
----------------------------------------------------------------------------------------------------
<INPUT>
: s2:
			if ele in mp2: mp2[ele] += 1
			else: mp2[ele] = 1
		
		ans = 0
		for k1, v1 in mp1.items():
			tar = k1 ** 2
			for k2 in sorted(mp2.keys()):
				if k2 ** 2 > tar: break
				elif k2 ** 2 == tar:
					ans += v1 * mp2[k2] * (mp2[k2] - 1) // 2
				elif tar % k2 == 0 and (tar // k2) in mp2:
					ans += v1 * mp2[k2] * mp2[tar // k2]
		for k2, v2 in mp2.items():
			tar = k2 ** 2
			for k1 in sorted(mp1.keys()):
				if k1 ** 2 > tar: break
				elif k1 ** 2 == tar:
					ans += v2 * mp1[k1] * (mp1[k1] - 1) // 2
				elif tar % k1 == 0 and (tar // k1) in mp1:
					ans += v2 * mp1[k1] * mp1[tar // k1]
		return ansfrom collections import Counter
import math
class Solution:
	def f(self,nums1, nums2):
		n1 = len(nums1)
		freq_dict_2 = Counter(nums2)
		answer = 0
		for pos_a,a in enumerate(nums1):
			for pos_b in range(pos_a+1,n1):
				b = nums1[pos_b]
				c_square = a*b
				potential_c = math.floor(math.sqrt(c_square))
				#print(f\"{potential_c}**2 = {
<PREDICTION>
: [[
				 sm s::
2[ele] += 1
			else: mp2[ele] = 1
					for = 0
		for ele in in v1 in mp2.items():
			if = v1 - 2
			if k2, mp(v2.keys()):
				if k2 < 2 > k ** ans
				ansif k2 ** 2 > k: break					ans += v1 * v2[v2]
 vv2[k2] - 1)
 2
					if k < k2 == 0: kk // k2) % mp1:
					ans += v1 * mp2[k2] * mp2[k // k2]
			 k1 in v1 in mp2.items():
			if = k2 ** 2
			for k3, sorted(mp1.keys()):
				if k1 ** 2 >tar: break
				elif k1 ** 2 == prod:
					ans += v1 * mp1[k1] * mpmp1[k1] - 1) // 2
				elif k % k2 == 0 and (k // k2) in mp1:
					ans += v1 * mp1[k1] * mp1[k // k1]
		return ans
 collections import default

 n

 Solution:
	def num(self, num):1,ns2,
		ifums, len(nums1)
		nq1count = = = {}()nums2)
		fre = 0
		for i innum in num in zipate(nums1):
			if pos_b, range(pos_a,1,pos1):
				if = nums1[pos_a]
				if =a = num *n
				if = =dictnt a.sq(n.sqrt(a_square)
				ifprint(a'bposential_c}\ is{ + {pot
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 40500
----------------------------------------------------------------------------------------------------
<INPUT>
:  5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569
<PREDICTION>
: ,, 501, 5113, 519, 51113, 5153, 5159, 5167, 5179, 5189, 5197, 5197, 5221, 5231, 5233, 5237, 5237, 5273, 5273, 5281, 5297, 5297, 5309, 523, 5333, 5333, 5351, 5357, 5387, 5389, 5399, 5407, 5313, 5419, 5419, 5431, 5437, 54441, 5443, 5447, 5453, 5477, 5479, 5479, 501, 57, 557, 5519, 5521, 5527, 5531, 55551, 5561, 567, 5573, 5581, 5591, 501, 527, 5641, 5647, 5651, 5653, 5659, 5659, 5663, 5681, 5687, 5693, 501, 5711, 5717, 5719, 5743, 5743, 5747, 57753, 5779, 57891, 501, 58807, 5813, 5819, 5827, 5831, 5843, 5851, 5857, 5857, 58861, 5867, 5869, 5879, 58881, 58877, 503, 5923, 5927, 5947, 59951, 59963, 5993, 51, 600993, 6029, 6031, 6007, 6043, 60071, 667, 6073, 6079, 67, 61031, 601, 6107, 6127, 6131, 6133, 6133, 6151, 6163, 6173, 6197, 6199, 6203, 611, 6217, 62221, 6229, 6229, 6257, 6271, 6269, 6271, 6299, 6281, 6299, 601, 611, 6317, 6319, 6329, 63337, 6343, 6353, 6367, 6367, 6367, 6373, 6379, 6389, 6391, 6321, 6427, 64449, 64457, 6467, 64457, 6479, 6491, 611, 6529, 6533, 65551, 63, 65563, 6569,
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 41000
----------------------------------------------------------------------------------------------------
<INPUT>
:  the Job object as a key in dict
	def __hash__(self):
		return hash((self.start_time, self.end_time, self.weight))

	def __eq__(self, other):
		return self.start_time == other.start_time and self.end_time == other.end_time and self.weight == other.weight


class WeightedIntervalSchedule:

	def __init__(self, sch):
		self.jobs = list()
		for job in sch:
			self.jobs.append(Job(job[0], job[1], job[2]))

		self.jobs_end_first = []
		self.jobs_start_first = []
		self.previous_job = len(self.jobs) * [0]
		# Memoization will be done using this memory dict
		self.memory = dict()
		#computing the previous mappings
		self.compute_latest_job_scheduled_before()
		

	def getResult(self):
		return self.dp(self.jobs_end_first, len(self.jobs) - 1, self.previous_job)

	def compute_latest_job_scheduled_before(self):
		
		# Sorting the jobs in non decreasing order of end_time - O(nlogn)
		self.jobs_end_first = sorted(self.jobs, key=lambda x: x.end_time)

		indexed_jobs_start_first = [(index, job) for index, job in enumerate(self.jobs_end_first)]
		# Sorting the jobs in non decreasing order of start_time - O(nlogn)
		self.jobs_start_first = sorted(indexed_jobs_start_first, key=lambda x: x[1].start_time)

		# This list X will store the index of the previous job in jobs_end_first
		X = len(self.jobs) * [0]
		X[0] = -1

		# The time complexity of this method is O(n) as the statement inside the
<PREDICTION>
:  first. will given string- the.		 keyinit__(self):
		return self(self.data,word, self.time_time, self.time))
	def __str__(self, other):
		return self.weight_time < other.start_time and self.end_time < other.end_time and self.end == other.weight

	def SolutionedListval( examples(
	def __init__(self, n:
		self.data = [](
		self line in file:
			self.jobs.append(job[job[0], job[1], job[2]))
	defself.jobs =list =time_ [
		self.jobs_start =first = []
		self.jobsvious_job = [](self.jobs)
 20]
		self self_ization
 be sorted

 job

		for.jobs = {}()
		for forbs to most jobmost of		for.currentute_job_job(2ores( =for(
		for	def job_(self,
		return self.jobs.self.jobs,start_first, self(self.jobs_ - 1, self.jobsvious_job)

def get_job_job_scZvest_before(self):
		return		returnreturnorted to current in the- order
 the offirst
 start(nogn)
		#.jobs =start_first = [(self.jobs_ key=lambda x: x[start_time)
		# = =index =end =first = selfindexed value[ for job, job in enumerate(self.jobs_end_first)]
		selfprintorted the jobs in non decreasing order of job_time - O(nlogn)
		self.jobs_end_first = [(selfed_start_start_first) key=lambda x: x.0])end_time)
		# O is should is be the job to the job job
 self_start_first
		# = self(self.jobs_
 index0]
		for[index] = X1
		for sort first O is O list should O(nl)
 the index is
 job
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 41500
----------------------------------------------------------------------------------------------------
<INPUT>
: [i]):
   am+=1
   if(am>1):
	break
  if(w[i]!=z[i]):
   bm+=1
   if(bm>1):
	break
 if(am==1):
  print(*y)
 else:
  print(*z)
t = int(input())
for T in range(t):
 n = int(input())
 a = [int(x) for x in input().split()]
 diff = []
 cor = 0
 
 for i in range(1, n):
  diff.append(a[i] - a[i - 1])
 d = set(diff)
 d = list(d)
 
 if len(d) == 1:
  print(*a)
  continue
 if len(d) == 2:
  cor = a[2] - a[1]
  if a[1] - a[0] != cor:
   a[0] = a[1] - cor
  else:
   a[-1] = a[-2] + cor
  print(*a)
  continue

 
 if (d[0] + d[1]) / 2 == d[2]:
  cor = d[2]
 elif (d[1] + d[2]) / 2 == d[0]:
  cor = d[0]
 else:
  cor = d[1]
 for i in range(1, n):
  if a[i] - a[i - 1] != cor:
   a[i] = a[i - 1] + cor
 print(*a)
t=int(input())
for _ in range(t):
 n=int(input())
 a=list(map(int,input().split()))
 if n==4:
  target=-1
  cur=-1
  ind=-1
  s=set()
  flag=False
  for i in range(1,n):
   k=a[i]-a[i-1]
   if k not in s:
	s.add(k)
   else:
	target=k 
	cur=a[i
<PREDICTION>
: i]

	  ift1
   if amam>=):
	am
  (am>i]>=0[i]):
   am[=1
   am(b>1):
	break
 (b>1):
  print(b)
 else:
  print(z)
 = int(input())
for _ in range(t):
 n = int(input())
 a = listint(i) for x in input().split()]
 b = a
 for = 0
 for
 for i in range(n, n):
  if.append(a[i] - a[i - 1])
  = diff()diff)
 for = d(d)
 diff
 if len(d) == 1:
  print(d)
 else continue
  len(d) == 2:
  print = 1[0] - a[1]
  if d[0] - a[0] == diff:
   print[1] = a[1] - a
  else:
   a[01] = a[01] - a
  print(*a)
 else continue
 if
 if lend[0] - diff[1]) % 2 >= 1[0]
  print = d[0] - if dd[0] + d[2]) / 2 == d[1]:
  print = d[1] - else:
  print = d[0]
 print i in range(2, n):
  if a[i] - a[i - 1] != diff:
   a[i] = a[i - 1] - d
 (*a)
 =int(input())
for T in range(t):
 n=int(input())
 a=list(map(int,input().split()))
 diff n==1:
  print=1
 el printr1
  for=1
  for=set()
  for=0
  for i in range(1,n):
   if=a[i]-a[i-1]
   if k> in s:
	flag.add(k)
   else:
	flag=k

	s=k[i]-
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 42000
----------------------------------------------------------------------------------------------------
<INPUT>
: ] * n
		f[n-1] = [1] * len(vowels_idx)
		for i in range(n-2, -1, -1):
			f[i] = [0] * len(vowels_idx)
			for vowel in vowels_idx:
				if vowel == 'a':
					f[i][vowels_idx[vowel]] += f[i+1][vowels_idx['e']]
				elif vowel == 'e':
					f[i][vowels_idx[vowel]] += f[i+1][vowels_idx['a']] + f[i+1][vowels_idx['i']]
				elif vowel == 'i':
					f[i][vowels_idx[vowel]] += f[i+1][vowels_idx['a']] + f[i+1][vowels_idx['e']] + f[i+1][vowels_idx['o']] + f[i+1][vowels_idx['u']]
				elif vowel == 'o':
					f[i][vowels_idx[vowel]] += f[i+1][vowels_idx['i']] + f[i+1][vowels_idx['u']]
				else:
					f[i][vowels_idx[vowel]] += f[i+1][vowels_idx['a']]
				f[i][vowels_idx[vowel]] %= (10**9 + 7)
		total = 0
		for vowel in vowels_idx:
			total += f[0][vowels_idx[vowel]]
		return total % (10**9 + 7)
			
		memo = {}
		def f(i, prev_vow
<PREDICTION>
:  = (
			[i -1] = fn] * n(n)els)countx)
		for i in range(len-2, -1, -1):
			if[i][ = f0] * len(vowels_idx)
			for j in vowels_idx:
				for i[ '1':
					f[i][vowels_idx[vowels]] += 1[i+1][vowels_idx[a']]
					if vowel == 'e':
					f[i][vowels_idx[vowel]] += f[i+1][vowels_idx['a']]
 f[i+1][vowels_idx['e']]
				elif vowel == 'i':
					f[i][vowels_idx[vowel]] += f[i+1][vowels_idx['e']]
 f[i+1][vowels_idx['e']]
 f[i+1][vowels_idx['i']]
 f[i+1][vowels_idx['u']]
				elif vowel == 'o':
					f[i][vowels_idx[vowel]] += f[i+1][vowels_idx['i']]
 f[i+1][vowels_idx['o']]
				el:
					f[i][vowels_idx[vowel]] += f[i+1][vowels_idx['i']]
				f[i][vowels_idx[vowel]] +== mod10**9 + 7)
			 = 0
		for i in vowels_idx:
			total += f[n][vowels_idx[vowel]]
		return total % (10**9 + 7)
		

			o = {}
		def d(i, v):vowel
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 42500
----------------------------------------------------------------------------------------------------
<INPUT>
: append((x,y+1))
	stack.append((x,y-1))
	ans.append(curr)

for i in range(k):
	curr = ans[len(ans)-i-1]
	x = curr[0]
	y = curr[1]
	maze[x][y] = 'X'
s = ""
for i in range(n):
	for j in range(m):
		s+=maze[i][j]
	s+="\n"
print(s)
import sys
from collections import defaultdict

def main():
	sys.setrecursionlimit(1 << 30)
	g = []
	adj = defaultdict(set)
	vis = set()
	def valid(x, y):
		nonlocal n, m
		return x >= 0 and x < n and y >= 0 and y < m
	def bfs(x, y):
		nonlocal g, vis, adj
		q = []
		q.append((x, y))
		vis.add((x, y))
		s = 0
		while len(q) > 0:
			(x, y) = q.pop()
			s += 1
			for c in [[-1, 0], [1, 0], [0, -1], [0, 1]]:
				nx = c[0] + x
				ny = c[1] + y
				if valid(nx, ny) and (nx, ny) not in vis:
					if g[nx][ny] == '.':
						vis.add((nx, ny))
						q.append((nx, ny))
		return s
	def bfs2(x, y):
		nonlocal g, vis, adj, count
		q = []
		q.append((x, y))
		vis.add((x, y))
		while len(q) > 0:
			(x, y) = q
<PREDICTION>
: (i,y,1,
		.append((x,y+1))
	stack.append((1))
	for i in range(n):
	printr= stack[i(ans)-1-1]
	print, ansr[len]
	y = curr[1]
	if =[x][y] = '*'
	 = 0
for i in range(len):
	if j in range(m):
		if +=ansaze[i][j]
	s+=="Xn"
	(s)
n sys

 collections import dedict

sys main():
	n.setrecursionlimit(10000000 60)
	input = default
	n = defaultdict(list)
	for = [()
	for d(x, y):
		iflocal g, m,		if 0 == 0 and x < n and y >= 0 and y < m
	def dfs(x, y):
		nonlocal adj, adj
 adj
		vis = [(
		q.append((x, y,
		vis.add((x, y))
		while = '
		while q(q) > 0:
			xx, y) = q.pop()
			for += 1
			for i, adj01, 0], [1, 0], [0, 11], [0, 1]]:
				ifx, x[0]
 x
				ny = c[1] + y
				if valid(nx, ny) and validnx, ny) not in vis:
					q n[nx][ny] == 1X:
						q.add((nx, ny))
						q.append((nx, ny))
		return s
	g dfs((x, y):
		nonlocal g, vis, adj
 adj
		if = []
		q.append((x, y))
		vis.add((x, y))
		count len(q) > 0:
			xx, y) = q.
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 43000
----------------------------------------------------------------------------------------------------
<INPUT>
: : x[0], reverse = True)

	DP = [[0] * (N + 1) for _ in range(N + 1)]

	for i, b in enumerate(B):
		a = b[0]
		tmp = b[1]
		for x in range(i + 1):
			DP[x + 1][i - x] = max(DP[x + 1][i - x], DP[x][i - x] + a * abs(tmp - x))
			DP[x][i - x + 1] = max(DP[x][i - x + 1], DP[x][i - x] + a * abs((N - tmp - 1) - (i - x)))

	ans = 0
	for i in range(N + 1):
		ans = max(ans, DP[i][N - i])

	print (ans)

	# for tmp in DP:
	#	 print (tmp)

def __starting_point():
	main()
__starting_point()N = int(input())
A = sorted([(int(x[1]), x[0]) for x in enumerate(input().split())], reverse=True)


V = [0]

for i in range(N-1):
	a, p = A[i]
	s = i+1
	V2 = [None]*(s+1)

	for t in range(s+1):
		v = 0

		if t > 0:
			v = V[t-1] + a*abs(p-(t-1))

		if t < s:
			v = max(V[t] + a*abs(p-(N-s+t)), v)

		V2[t] = v

	V = V2

a, p = A[-1]
for i in range(N):
	V[i] += a*abs(p-i)

print((max(V)))





			
from collections import *
from itertools import *

N = int(input())

A = list(map(int, input().split()))
SA
<PREDICTION>
: 
[0] x= True)
		[ [0] * (n + 1) for _ in range(N + 1)]
	for i in x in enumerate(A):
		for, A[0]
		b = a[1]
		for j in range(1 + 1):
			b[x][ 1][x] x] = max(DP[x + 1][i], x], DP[x][i - x - + a) x(x - x))

			DP[x][i + x] 1] = max(DP[x][i - x + 1], DP[x][i - x] + a * abs(x - x - x) // xtmp - x -
	print = 0
	for i, range(1): 1):
		ans = max(ans, DP[i][N]) i])
	print(ans)


return print i in range:
	#	 print(tmp)

def __starting_point():
	main()

starting_point()N, int(input())
A = list(intint(a),0]), int[0] for x in inputate(input().split())]) reverse=True)

def = [0] *forfor i in range(N):1):
	V, b = A[i],
	V = a+1
	for. = V0]
(N+1)
	for j in range(s):1):
		a = t
		for t == a:
			v = t[t]1]
 t*v(v-t-1))
		for t < N:
			v = V(v2t- + a*abs(p-(t-t))1)) 0)
		V2[t] = max

	V[ V2


print = b = A[N1]

 i in range(N-
	a2i] = a
((p-(a)

ans(max(a)))




			 it import default
n itertools import *
importimport = int(input())
AA = sorted(map(int, input().split()))

 =
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 43500
----------------------------------------------------------------------------------------------------
<INPUT>
: 
	cnts = list(map(int, stdin.readline().split()))
	for i in range(1,k):
		cnts[i] += cnts[i-1]
	
	group = list(range(n))
	rnk = [0 for i in range(n)]
	adj = [[INF for j in range(k)] for i in range(k)]
	for i in range(m):
		u, v, x = map(int, stdin.readline().split())
		if x==0:
			union(group, rnk, u-1, v-1)
		tu = bisect_left(cnts, u)
		tv = bisect_left(cnts, v)
		adj[tu][tv] = min(adj[tu][tv], x)
		adj[tv][tu] = min(adj[tv][tu], x)
	
	p = 0
	for i in range(k):
		cur = group[p]
		while p<cnts[i]:
			if group[p]!=cur:
				print("No")
				return
			p += 1
	print("Yes")
	
	for p in range(k):
		for i in range(k):
			for j in range(k):
				adj[i][j] = min(adj[i][j], adj[i][p]+adj[p][j])
	
	for i in range(k):
		adj[i][i] = 0
		for j in range(k):
			if adj[i][j] == INF:
				adj[i][j] = -1
	
	for i in range(k):
		print(' '.join(map(lambda x: str(x), adj[i])))
	
	
solve()n, m = list(map(int, input().split()))
print('{:.9}'.format((1 + (n - 1) * (m - 1) / (n
<PREDICTION>
: 		nt += = [(map(int, inputin.readline().split()))
	c i in range(n, n):
		ifnts[i] = cnts[i-1]
			ans = [(map(k))
	for = = [0] i in range(n)]
	for = [[]F for i in range(n)] for i in range(n)]
	for i in range(n):
		for,v = w = map(int, stdin.readline().split())
		u u >1:
			group(u[ unk, 0,1) v-1)
		else = [ect.left(groupnts, x)
		if = cect_right(cnts, v)
		if[c][0] = min(c[tu][tv], v)
		if[c][ru] = min(adj[tu][ru], x)
			forq [
	for i in range(1):
		p = [[i]
		while cur<lennts[i]:
			p adj[p] !==cur:
				p('No")
				return
			p+= 1
		("Yes")
	
	
 i in range(n):
		print i in range(n):
			print j in range(k):
				if[i][j] = min(adj[i][j], adj[i][k]+adj[i][j])
			print i in range(k):
		cur[i][0] = 0
		
 j in range(k):
			if adj[i][j]== INF:
				print[i][j] = 11
			for i in range(k):
		print('.join(map(str x: str(x) adj[i][)))
			return	olve()
, m, map(map(int, input().split()))
g(YES}022f'.format(n + nn - 1) * mm - 1) + 2n -
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 44000
----------------------------------------------------------------------------------------------------
<INPUT>
: .Counter()
		for n in nums1:
			double1[n * n] += 1
		for n in nums2:
			double2[n * n] += 1
		for i in range(len(nums1)):
			for j in range(i + 1, len(nums1)):
				if nums1[i] * nums1[j] in double2:
					res += double2[nums1[i] * nums1[j]]
		for i in range(len(nums2)):
			for j in range(i + 1, len(nums2)):
				if nums2[i] * nums2[j] in double1:
					res += double1[nums2[i] * nums2[j]]
		return res
from collections import Counter

class Solution:
	def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:
		squares1 = Counter([x ** 2 for x in nums1])
		squares2 = Counter([x ** 2 for x in nums2])
		total = 0
		
		# type 1
		for i in range(len(nums2)):
			for j in range(i + 1, len(nums2)):
				if (square := nums2[i] * nums2[j]) in squares1:
					total += squares1[square]
					
		# type 2
		for i in range(len(nums1)):
			for j in range(i + 1, len(nums1)):
				if (square := nums1[i] * nums1[j]) in squares2:
					total += squares2[square]
		
		return totalclass Solution:
	def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:
		m
<PREDICTION>
: append(
			 i in As::
			if = =n] n] += 1
			 n in nums2:
			double2[n * n] += 1
		for n in range(n(nums1)):
			if j in range(i + 1, len(nums2)):
				if nums1[i] * nums1[j] in d2:
					if += double2[nums1[i] * nums1[j]]
		return i in range(len(nums2)):
			for j in range(i + 1, len(nums2)):
				if nums2[i] * nums2[j] in double2:
					res += double2[nums2[i] * nums2[j]]
		return resclassclass collections import Counter
classclass Solution:
	def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:
		
ares1 = Counter(x** 2 for x in nums1])
		squares2 = Counter([x ** 2 for x in nums2])
		squ = 0
		for		for print 3
		for i in range(len(nums1)):
			for j in range(i + 1, len(nums2)):
				for numn2 nums2[i] * nums2[j]) in squares1:
					total += square1[square]
					
		for print 2
		for i in range(len(nums1)):
			for j in range(i + 1, len(nums2)):
				if (square := nums1[i] * nums2[j]) in squares2:
					total += square2[square]
					return total
 Solution:
	def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:
		def =
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 44500
----------------------------------------------------------------------------------------------------
<INPUT>
: 
	meet=0
	pos=[[[0 for z in range(c)] for y in range(r)] for x in range(max(r,c))]
	j=0
	k=0
	while j <r:
		j_init = j
		# if(j==r):
			# print("Fault:"+str(j))
		k=0
		while k <c:
			k_init = k
			# if(j==r or k==c):
			#	 print("Fault:"+str(j)+" "+str(k))
			# print(str(j) + " " + str(k))
			if(arr[j][k] in anr):

				for z in range(max(r, c)):
					if(j==r or k==c or arr[j][k]=="#" or k==-1 or j==-1):
						break
					if(pos[z][j][k]>0):
						meet+=pos[z][j][k]
					# else:
						# print(str(z) + " " + str(j) + " " + str(k))
					pos[z][j][k]+=1
					if(arr[j_init][k_init]=='D'):
						j+=1
					elif(arr[j_init][k_init]=='U'):
						j-=1
					elif (arr[j_init][k_init] == 'L'):
						k -= 1
					elif (arr[j_init][k_init] == 'R'):
						k += 1
			k=
<PREDICTION>
: 
		 =0
	for=000, i in range(n)] for z in range(c)] for x in range(r(l))c))]
	for=0
	for=0
	for(< len:
		if+=i= 0
		ifprint jj==0-
		## print(1","))str(pos))
		#+=k
		while j< c:
			#+=init = k +
			# print(j==r): j==c):
			#	 print("Fibo:"+str(j))")\str(j))
			k	(j(j)) +" "+ + str(j))
			#(j[j][k]== 'ss):
	
				an x in range(j(k,c)):
					if(j==r or z==c): z[j][k] in"+"): arr==c1): z==c1):
							
					#(j[j][k]k]==pos):
						pos=1[z][j][k]
						 print:
						#	(j(j)+ + " " + str(j)) + " " + str(k))
						[j][j][k] =1
					pos(pos[j][init][j]init]==0#'):
						pos+=1
						if(pos[j_init][k_init]=='#'):
						j+==1
					elseif(j[j_init][k_init]== 'L'):
						j+= 1
					elif(j[j_init][k_init] == 'L'):
						j+= 1
				+=max
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 45000
----------------------------------------------------------------------------------------------------
<INPUT>
: 2c3.38

Output
6.38

Input
aa0.01t0.03

Output
0.04Let's denote a m-free matrix as a binary (that is, consisting of only 1's and 0's) matrix such that every square submatrix of size m × m of this matrix contains at least one zero. 

Consider the following problem:

You are given two integers n and m. You have to construct an m-free square matrix of size n × n such that the number of 1's in this matrix is maximum possible. Print the maximum possible number of 1's in such matrix.

You don't have to solve this problem. Instead, you have to construct a few tests for it.

You will be given t numbers x_1, x_2, ..., x_{t}. For every $i \in [ 1, t ]$, find two integers n_{i} and m_{i} (n_{i} ≥ m_{i}) such that the answer for the aforementioned problem is exactly x_{i} if we set n = n_{i} and m = m_{i}.


-----Input-----

The first line contains one integer t (1 ≤ t ≤ 100) — the number of tests you have to construct.

Then t lines follow, i-th line containing one integer x_{i} (0 ≤ x_{i} ≤ 10^9).

Note that in hacks you have to set t = 1.


-----Output-----

For each test you have to construct, output two positive numbers n_{i} and m_{i} (1 ≤ m_{i} ≤ n_{i} ≤ 10^9) such that the maximum number of 1's in a m_{i}-free n_{i} × n_{i} matrix is exactly x_{i}. If there are multiple solutions, you may output any of them; and if this is impossible to construct a test, output a single integer  - 1. 


-----Example-----
Input
3
21
0
1

Output
5 2
1 1
-1Vasya is sitting on an extremely boring math class. To have fun, he took a piece of paper and wrote out n numbers on a single line. After that, Vasya began to write out different ways to put pluses ("+") in the line between certain
<PREDICTION>
: ,2 =append93
Output
1
8.
Input
5ab




0.
Output
0.0
's call the set-rd number as a string matrixn is, the of n one and), 2's). and. that the row ismatrix is the 1 is m. the matrix is exactly least one side.


Let a following sequence: 
$ are given a integers n and m, You have to determine a integer-digit matrix,. size n, m. that the sum of rows's in the row is equal possible.

 the number possible value of rows's in this a.


If have't have to minimize this problem.

, you have to answer a m of of each.


You have be given a lines a_1, x_2, ..., x_{t} You each 1t$,le [1, 2]$ you the integers $ andi} and m_{i} such1_{i} � 1_{i} that that the sum is each i matrix is maximum $_{i} + the can the_{ x,i} and m_{ n_{i}


-----Input-----

The first line contains two integer t (1 ≤ t ≤ 10) — the number of test in have. solve.

Each t lines follow, each-th line contains two integer m_{i} (1 ≤ x_{i} ≤ 10^5).

It that in this you have to print n in 1.


-----Output-----

Print each test case have to print a print the integers integers x_i} and m_{i} —1 ≤ n_{i} ≤ n)i}). m^9). — that the answer possible of 1's in this row andi} isth square ini} is m isi} is is maximum x_{i}

 there are multiple answers, you may print any of them. otherwise the there solution not to make a m case output any single integer - - 1.



-----Example-----
Input
3
1
1 11 11Output
2

1 1
11
ladya has going in a array contest of,. He do a, he has a lot of paper and he out a cards. it given number.
 each he heya has a the a the numbers to write theb onV", in a order. the integer
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 45500
----------------------------------------------------------------------------------------------------
<INPUT>
:  
		pile.append([elt,coeff+1])
	
	coeff = 0
	while(pile):
		top1, top2 = pile.pop()
		coeff += top2
		score = top1*coeff
		maxi = max(maxi, score)
	
	return maxidef array_info(x):
	TheDICT = {'len':[1,len(x)], int:[2,0], str:[4,0], float:[3,0], 'void':[5,x.count(' ')]}
	for e in x:
		if e != ' ':
			TheDICT[type(e)][1] += 1
	return [ [e[1] if e[1] else None] for e in sorted( TheDICT.values() ) ] if x else 'Nothing in the array!'
			
		
def array_info(x):
	return [[len(x) or None],[sum(isinstance(n,int) for n in x) or None],[sum(isinstance(n,float) for n in x) or None],[sum(isinstance(n,str) and n!=" " for n in x) or None],[sum(n==" " for n in x) or None]] if x else "Nothing in the array!"def a(n):
	n -= n%2
	if n<4: return ''
	return '\n'.join( '{0}{1}{0}'.format('A' * (i%(n//2) != 0),
										 ' ' * (i*2-1) if i%(n//2) else ' '.join( ['A']*(i+1) )
										).center(2*n-1) for i in range(n) )def a(n):
	n = n if n % 2 == 0 else n - 1
	width = 2 * n - 1
	lines = ["A".center(width)] + [("A" + " "*k + "A").center(width) for k in range(1, n-1, 2
<PREDICTION>
:  			 = =append(i, p-])1])
			foreff = 0
	for lenlenile[
		p = =top2 = p[pop()
		ifeff += top1
		if += max1 +topeff
		ifscore = max(maxi,score)
				 maxi
 max_of_n):
	return = = = [0a': [0,2(x)], ',0,len], ...(2,0], ...,0,0], ...	':[1,0],index(0)}
	return i in x:
		if e[ ' ':
			returnDICT[e(e)]][0] += 1
		 The [int for0] for e[0] != 0 fordef e in x( TheDICT)]values(),)] ]def e else [No' the array_importdef
		def	
def array_info(x):
	return [x(x) for [ forx(xinstance(x, int) for n in x) ] None]]0(isinstance(n,int) for n in x) or None]]x(isinstance(n,int)) for n in=' ") n in x) ] None]]None(is)' " for n in x) or None]]def x else [[None in the array!"
 array_n):
	if = 1
10
	return n ===: return "
	if 'Pn'.join(a'.}}2}2}'format( '', if nn+2i+2) + 0, '							   	{ + (i%n)1) for i%2n//2) != ' 'join(str '' *(i%1) for for								 for for 'split(n,i//i) for n in range(n// or
 a(n):
	if = n% n< 2 == 0 else n
 n
	if = [
 n + 1
	if = []{",join(width)
 [lineB" * widthB *width) " ""center(width)] for k in range(width, width +1)] 2)]
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 46000
----------------------------------------------------------------------------------------------------
<INPUT>
: [2]))
		
		
		def reachable(node, visited, threshold, dist):
			for nei in graph[node]:
				if dist+nei[1]<visited[nei[0]] and dist+nei[1]<=threshold:
					visited[nei[0]] = dist+nei[1] 
					reachable(nei[0], visited, threshold, dist+nei[1])
					
		res = 0
		temp = n
		for i in reversed(list(range(n))):
			visited = [float('inf') for _ in range(n)]
			visited[i] = 0
			c = 0
			dist = 0
			for nei in graph[i]:
				if dist+nei[1]<visited[nei[0]] and dist+nei[1]<=d:
					visited[nei[0]] = dist+nei[1] 
					reachable(nei[0], visited, d,dist+nei[1])
			
			for val in visited:
				if val>0 and val!=float('inf'):
					c+=1
		
			# print(c,i)
			if c < temp :
				res = i
				temp = c
		return res
class Solution:
	def findTheCity(self, n: int, edges: List[List[int]], distanceThreshold: int) -> int:
		THRESHOLD_MAX = 10001
		dist = [[THRESHOLD_MAX for _ in range(n)] for _ in range(n)]
		
		for edge in edges:
			dist[edge[0]][edge[1]] = edge[2]
			dist[edge[1]][edge[0]] = edge[2]
		
		for i in range(n):
<PREDICTION>
: i] =
					
		
 findable(i, visited): graph): visited):
			# nx in graph[node]:
				if visited <=nei not0] <=ited:nei[0] and dist+nei[1]>= thresholdreshold:
					returnited[nei[0]] = dist+nei[1]

					heable(nei,0], visited, threshold, dist+nei[1],
					
			 = 0
		vis = []
		
 i in range(range(range(1))):
			ifited[ [0('inf')] _ in range(n)]
			resited[n] = 0
			
nt 0
			for = 0
			for ji in graph[i]:
				if visited+nei[1]<=ited[nei[0]] and dist+nei[1]<=th:
					visited[nei[0]] = dist+nei[1]

					reachable(nei[0], visited, threshold+ dist+nei[1])
								 ne in graph:
				if val<=: val<=0('inf'):
					if+=1
						ifprint(c) res,
			if c> threshold:
				temp = val
				temp = c
			 res
	 Solution:
	def findTheCity(self, n: int, edges: List[List[int]], distanceThreshold: int) -> int:
		
S = = =IN = float

		
 = [[floatecH___MAX] _ in range(n)] for _ in range(n)]
		dist		for i in edges:
			dist[edge[0]][edge[1]] = edge[2]
			dist[edge[1]][edge[0]] = edge[2]
		
		for i in range(n):

----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 46500
----------------------------------------------------------------------------------------------------
<INPUT>
: , 0, 0, 1, 1],
    [d, d, 0, 0, 1, 1, 0, d, 0, d, 1, d, d, d, _, d, 1, 0, 1, 1],
    [1, d, 1, 1, 0, 1, 0, 0, d, 1, d, 1, d, 1, d, _, 1, 1, 0, d],
    [d, d, 1, d, 0, 0, d, d, d, 0, 1, 0, 1, 1, 0, 0, _, 0, 0, 1],
    [1, 0, 1, 0, 0, d, 0, 1, 0, d, 1, 1, 0, 1, 1, 0, 1, _, d, d],
    [1, d, 0, d, d, 0, 0, 1, 1, 0, d, 1, d, 0, 0, 1, 1, d, _, 0],
    [d, 1, 0, 0, d, 0, 1, 1, 1, d, d, 1, d, 0, 0, d, 0, d, 1, _]])

# returns
'''\
 #  Player             1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20  Pts     SB
===============================================================================================
 1  Gregory Bates         1  =  0  1  1  =  1  =  1  0  =  =  =  1  1  =  1  1  1  13.5  124.50
 2  Justus Sloan       0     0  =  1  1  =  =  1  1  1  1  =  0  =  1  =  1  1  0  12.0  109.00
 3  Makena Galloway    =  1     1  1  1  0  =  =  1  0  0  =  1  1  0  1  0  =
<PREDICTION>
:  5, 1, 0, 1,
	   [0, 0, e, 0, 1, 1, 1, 1], 2], 1, 0], 1, 2, 2, 2, 1, _, 1], 1], 1,
   [ [d, 1, d, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 2, 1, 2, d, 1], 1], 1,
   [ [1, 1, 1, 1, 1, 1, 1, 1, 1, _, 1, 1, 1, 1], 1], 1], 1, d, 1], 1,
   [ [d, d, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1], 1], 1, 1, 2,
   [ [1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1,
   [ [1, 1, 1, d, 1, 0, 1, 1, 0, 0, 1, 0, 1, 2, 1, 1, 1], 1, 1, 1,

 def for thedef'

# Definition  of : : :                   
 7  
 9


 13 14 15
 17 18
 20 19
   


 
: 
 
.  
                        1  
 =  1  1  0      1  
 =
  14    
 
  ..
               0    =  1  1      =    1  =  1    1    
 =.5 
 

3     is

       2 2      =    =  1  1  1  =  =  1  0  
 =
 
 = 
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 47000
----------------------------------------------------------------------------------------------------
<INPUT>
:  si, sj, validSet):
		m, n = len(grid), len(grid[0])
		for dx, dy in [(0, 1), (0, -1), (-1, 0), (1, 0)]:
			i, j = si+dx, sj+dy
			if (i, j) in validSet:
				continue
			if 0 <= i < m and 0 <= j < n and (i, j) != (bi, bj) and grid[i][j] != '#':
				validSet.add((i, j))
				self.canMoveTo(grid, bi, bj, i, j, validSet)
		return validSet
	'''	class Solution:
	def minPushBox(self, grid: List[List[str]]) -> int:
		if not grid or not grid[0]:
			return -1
		
		# Main idea: run Dijkstra's except only expand on nodes
		# that do not have a wall on the oposite side of the
		# box location. Also check for each position if we can
		# get from the old starting location to the new appropriate
		# push position
		
		self.grid = grid
		self.memo = {} # (start => dst) : True or False by DFS'ing
		dst = None
		start = None
		box_start = None
		from queue import Queue
		pq = Queue()
		for row in range(len(grid)):
			for col in range(len(grid[row])):
				elem = grid[row][col]
				if elem == \"B\":
					box_start = (row, col)
				elif elem == \"T\":
					dst = (row, col)
				elif elem == \"S\":
					start = (row, col)
		
		assert dst is not None
		assert start is not None

<PREDICTION>
:  = sj, a),
			 = n = len(grid), len(grid[0])
		if i, dy in [(1, 1), (0, -1), (1, 0), (1, 0)]:
			i, j = i +dx, sj+dy
			if 0i, j) in validSet:
				continue
			if grid <= i < m and 0 <= j < n: gridi, j) not (m, bj) and grid[i][j] != '#':
				ifSet.add((i, j))
				valid.dfMove((grid, bi, bj, valid, j, validSet)
			 validSet
	
'
	 Solution:
	def minPushBox(self, grid: List[List[str]]) -> int:
		m not grid or not grid[0]:
			return -1
		
		m b


 onFSstra
 algorithm only on on the.		# if means D change a key for the grid
.
 the grid		# if can,
, if the cell of there have move		# have the position current position position
 the new position location		# if the to		def		def.b = grid
		
.r = = {}
 stateposition, 0_
 the # False
 visitedFS

 D		
 =_ set
		for = None
		for_count = None
		for_ import Queue
		forq = Queue()
		for i in range(len(grid)):
			if col in range(len(grid[0])):
				if = = grid[row][col]
				if (m == 'B':
					if_start = (row, col)
				elif elem == \"S\":
					boxst = (row, col)
				elif elem == \"S":
					box = (row, col)
					def( is not None
		
 grid is not None
	
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 47500
----------------------------------------------------------------------------------------------------
<INPUT>
: 	mask_left = mask_left | (1 << u)
					c += 1
			joint_mask = mask_left | mask_right
			if answer[mask_left] and not answer[joint_mask]:
				answer[joint_mask] = True
				left[joint_mask] = mask_left
				right[joint_mask] = mask_right
				if joint_mask == ((1 << k) - 1):
					return build_answer(k, masks, left, right)
	if answer[(1 << k) - 1]:
		return build_answer(k, masks, left, right)
	return False, None, None


def build_answer(k, masks, left, right):
	c = [-1] * k
	p = [-1] * k
	pos = (1 << k) - 1
	while not masks[pos]:
		for key, val in list(masks[right[pos]].items()):
			c[key] = val[0]
			p[key] = val[1]
		pos = left[pos]
	for key, val in list(masks[pos].items()):
		c[key] = val[0]
		p[key] = val[1]
	return True, c, p


def build_num_map(k, n, a):
	result = dict()
	for i in range(k):
		for j in range(n[i]):
			result[a[i][j]] = (i, j)
	return result


def find_cycle(i_origin, j_origin, i, j, k, n, a, sums, tsum, num_map, mask, path):
	if (mask & (1 << i)) != 0:
		if i == i_origin and j == j_origin:
			return True, mask, path
		else:
			return False, None, None
	mask = mask | (1 << i)
	a_needed = t
<PREDICTION>
: 	 =id = mask_left
 mask1 << ()
		maskmaskmask	nt 1
				 +=[set = mask_left & mask_left
			if j[i_left] == c ([joint_mask]:
				answer[joint_mask] = True
				answer_maskoint_mask] = True_left
				right[ioint_mask] = mask_left
				answer not_mask & 01 << u) - 1):
					answer True_answer(mask, j) j, right)
		 answer[-1 << k) - 1]
		return build_answer(k,println, left, right)
	return -
 True
 None

def ___answer(k, asteroids, left, right):
	ifnt 01] * k
	for = 01] * k
	for = [1 << k) - 1
	for pos ([pos]:
		pos i in value in left(pks[pos])pos]].items()):
			if[key] = val
0]
			if[key] = pos[1]
		pos = pos
pos]
	return i, val in list(cks[left].items()):
		if[key] = val[0]
		pos[key] = pos[1]
	return c, c

 left


def solve_answer_of(k, n, x,
	a = []()
	for i in range(k):
		for j in range(n[i]):
			if[a[i][j]] = ai, j)
	return result


def build_one(k,list, k_sl, a_ j): k, n, a): b, sums):, numsof): num): pos):
	if ii[ (1 << k_ != 0:
		return i == j_origin: j == j_origin:
			return True,
, path
		else:
			return False, path, None

	mask = mask & (1 << i)
	if =next = asum
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 48000
----------------------------------------------------------------------------------------------------
<INPUT>
: [x]
	
	def union(self,x,y):
		px = self.find(x)
		py = self.find(y)
		rx = self.rank[x]
		ry = self.rank[y]
		if px==py:
			return False
		if rx>ry:
			self.parent[py]=px
			self.rank[px]+=self.rank[py]
		else:
			self.parent[px]=py
			self.rank[py]+=self.rank[px]
		return True
				
class Solution:
	def minCostConnectPoints(self, points: List[List[int]]) -> int:
		n = len(points)
		edges = []
		for i in range(n):
			for j in range(i+1, n):
				dist = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])
				edges.append((dist, i, j))
	
		edges.sort()
		res = 0
		ds = DSU(n)
		for cost, u, v in edges:
			if ds.union(u,v):
				res += cost
		return resclass Solution:
	def minCostConnectPoints(self, points: List[List[int]]) -> int:
		cache = []
		l = len(points)
		if l == 1:
			return 0

		for i in range(l-1):
			for j in range(i+1, l):
				start = points[i]
				end = points[j]
				length = abs(start[0]-end[0])+abs(start[1]-end[1])
				cache.append([length, i, j])
		cache.sort()
		#print(cache)

		res = 0
		t
<PREDICTION>
: i] =			for get(self, x,y):
		x = self.find(x)
		py = self.find(y)
		if = self.find[px]
		if = self.rank[y]
		
 px ==ry:
			return

		if selfx==ry:
			self.rank[rx]=px
			self.rank[px]+=self.rank[py]
		else:
			self.parent[px]=py
			self.rank[py]+=self.rank[px]
		return True
	
	

	 Solution:
	def minCostConnectPoints(self, points: List[List[int]]) -> int:
		
= len(points)
		edges = []
		for i in range(n):
			for j in range(i+1, n):
				dist = abs(points[i][0]- - points[j][0]) + abs(points[i][1] - points[j][1])
				edges.append((dist, i, j))
				edges.sort()
		
 = 0
		uf = DisSU(n)
		for cost, u, v in edges:
			if ds.union(u, v):
				res += cost
		return resclass Solution:
	def minCostConnectPoints(self, points: List[List[int]]) -> int:
		
 = {}
		n = len(points)
		for l == 1:
			return 0
		dist i in range(l):1):
			for j in range(i+1, l):
				if = abs[i]
				distance = points[j]
				if = abs(start[0]-end[0]) +abs(start[1]-end[1])
				if.append((start, i, j])
		cache.sort()
		ans print(cache)
		res = 0
		for =
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 48500
----------------------------------------------------------------------------------------------------
<INPUT>
: 	j += 1
	
	# print(B)
	return maxSumSubarray(B)
	
	
	
try:
	T = int(input())
except Exception as e:
	pass
else:
	while T >= 1:
		N, K = map(int, input().split())
		A = [int(x) for x in input().split()]
		print(formB(A, K))
		T -= 1# cook your dish here
import sys
t = int(input())
for _ in range(t):
	N,k = map(int,input().split())
	A = list(map(int,input().split()))
	B = A*k
	max_ = -(sys.maxsize)-1
	value = 0
	for i in range(len(B)):
		value = value + B[i]
		if value>max_:
			max_ = value
		if value<0:
			value = 0
	print(max_)from fractions import gcd as G
for ii in range(eval(input())):
 n=eval(input())
 arr=list(map(int,input().split()))
 k=arr[0]
 for i in range(1,n-1):
  k=G(k,arr[i])
 print(k*n)
  
  
import math
testcases=int(input())
while(testcases>=1):
 N=int(input())
 l=6
 m=3
 a=2**m
 if (N!=1 and math.ceil(math.log(N,2)))==math.floor(math.log(N,2)):
  print('-1')
  testcases-=1
  continue
 elif N==1:
  print('1',end=' ')
 elif(N==3):
  print("2 3 1",end=' ')
 elif(N==5):
  print("2 3 1 5 4",end=' ')
 if(N>5):
  print("2
<PREDICTION>
: 	 = 1

		
	whileprint(i)
	 B(arraySumB)

	
	
	:
	# = int(input())
	:: e:
	print
:
	#( > 0:
		T = K = map(int, input().split())
		A = listint(a) for x in input().split()]
		B(max((N)) K))
		T -= 1 cook your dish here
def sys

 = int(input())
for _ in range(t):
	n, K = map(int,input().split())
	A = list(map(int,input().split()))
	B = list[k
	for_A max110.maxsize)1
	for = 0
	for i in range(N(A)):
		value += max + B[i]
	ifif value >max_:
			max_ = value
	print	 max<max:
			value = 0
	print(max_)
 sys import Fcd
 g
from _ in range(int(input())):
	,eval(input())
 a=list(map(int,input().split()))
 ans=list.0]
 g i in range(1,n):1):
  if=min(k)arr[i])
 (k)()
for 
  
  sys
def = =int(input())
for testtestcases>01):
 test,eval(input())
 A=list
 l=math
 a=list*m
 for(N>=1): math.ceil(N.log(N))2)))==math.ce(N.log(N,2))):
  print(11')
  testcases-=1
 else continue
 ifif (==1:
  print('2')end=' ')
 if NN>2):
  print('2 1 1")end=' ')
 elif(N==5):
  print("1 3 1 5 6",end=' ')
 el(N>=):
  print("1 3
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 49000
----------------------------------------------------------------------------------------------------
<INPUT>
: ], dp[j] + a)

if dp[-1] == INF:
  print((-1))
else:
  print((dp[-1]))
N,M = map(int,input().split())
from collections import defaultdict
INF = float('inf')
dic = defaultdict(lambda: INF)
for i in range(M):
	a,b = map(int,input().split())
	c = list(map(int,input().split()))
	d = 0
	for k in c:
		d |= (1<<(k-1))
	dic[d] = min(dic[d], a)

dp = [INF] * (1<<N)
dp[0] = 0
for k,v in dic.items():
	for b in range((1<<N)-1):
		if dp[b] == INF: continue
		if b == (b|k): continue
		dp[b|k] = min(dp[b|k], dp[b]+v)
print(-1 if dp[-1]==INF else dp[-1])				import sys
readline = sys.stdin.readline

N,M = map(int,readline().split())
INF = 10 ** 10
dp = [INF] * (2 ** N)
dp[0] = 0

for i in range(M):
  a,b = map(int,readline().split())
  c = list(map(int,readline().split()))
  key = 0
  for j in range(len(c)):
	key += (1 << (c[j] - 1))
  for j in range(len(dp)):
	if dp[j] == INF:
	  continue
	if j | key == j:
	  continue
	if dp[j | key] > dp[j] + a:
	  dp[j | key] = dp[j] + a

if dp[-1] == INF:
  print(-1)
else:
  print(dp[-1
<PREDICTION>
:  [type[i][ + 1[
	print dp[-1] == 0:
	 print((-1))
else:
  print((dp[-1]))
import, M= map(int,input().split())
A heap import defaultdict

F = 10('inf')

 = = defaultdict(int: INF)

 i in range(M):
	a,b = map(int,input().split())
	d, list(map(int,input().split()))
	dic default
	for j in range:
		if +== k1<<kk-1))
	foric[(] = min(dic[d],a)

dp = [INF]* (1<<N)
dp[0] = 0
for i inv in listp.items():
	for i in range(1<<()1,-
		if kp[b] + INF:

		for v& 11<<v)

		dp[b|k] = min(dp[b|k], vp[b]+a)
print(1 if dp[-1] ==INF else dp[-1])import				 sys
importline = sys.stdin.readline

N,M = map(int,readline().split())

F = 10** 10

 = [INF] * (1** N)
dp[0] = 0
forfor i in range(M):
	 a,b = map(int,readline().split())
  d = list(map(int,readline().split()))
  d = (
  for j in range(N(c)):
	key | 11 << (c[j] - 1))
  d k in range(len(c)):
	dp dp[j] > INF:
	  d
	if d == ( in a:
	  d
	if dp[j] key] > dp[j] + a:
	  dp[j | key] = dp[j] + a
	ans dp[-1] == INF:
  print(-1)
else:
  print(dp[-1])
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 49500
----------------------------------------------------------------------------------------------------
<INPUT>
:  == l[a[i]]:
			min_l = f[a[i]]
			max_r = i
			used = set()
			v = 0

			for j in range(i, -1, -1):
				min_l = min(min_l, f[a[j]])
				max_r = max(max_r, l[a[j]])

				if a[j] not in used:
					v ^= a[j]
					used.add(a[j])

				if max_r > i:
					break
				if j == min_l:
					dp[i] = max(dp[i], dp[j - 1] + v)
					break

	# print(dp)
	ans = dp[n]
	print(ans)

def __starting_point():
	solve()
__starting_point()from collections import deque

class Graph(): #directed
	def __init__(self, n, edge, indexed=1):
		self.n = n
		self.graph = [[] for _ in range(n)]
		for e in edge:
			self.graph[e[0] - indexed].append(e[1] - indexed)

INF = 10**18

N, M = map(int, input().split())
edge = [tuple(map(int, input().split())) for _ in range(M)]

g = Graph(N, edge)

loopsize = INF

for i in range(N):
	root = i
	queue = deque([root])
	dist = [INF for _ in range(N)]
	dist[root] = 0
	prev = [None for _ in range(N)]
	while queue:
		node = queue.popleft()
		for adj in g.graph[node]:
			if adj == root: #閉路を検出する
	
<PREDICTION>
:  0:i]i]]:
				_l = i
a[i]]
			max_l = max
			a[ True()
			for = a
			while j in range(i, n1, -1):
				if_l = min(min_l, l[a[j]])
				max_r = max(max_r, f[a[j]])
				used min[j] == in used:
					used == 1[j]
					used.add(a[j])
				if v_l < v:
					max

				used v not max_l:
					used[i] = max_dp[i], vp[j] 1] + 1)
				elsemax
		 print(dp)
	print = maxp[0 -
	print(ans)


def __starting_point():
	mainolve()
__starting_point()import collections import defaultque

n Union:
 1:	def __init__(self, n_ edges= weight=1):
		self.n = n
		self.edge = [[] for _ in range(n)]
		# edge in edge:
			self.graph[e[0]]. 1].append(e[1] - indexed)
	defF = 10 **9

def, M = map(int, input().split())

 = []listuple(map(int, input().split())) for _ in range(M)]

# = [()N, M,

for = = = [[

for i in range(N):
	for = edge
	for = deque([i])
	while = [INF] _ in range(N)]
	dist[root] = 0
	while = [None for _ in range(N)]
	while len:
		node = queue.popleft()
		for next in g[graph[node]:
			if dist == prev:
 �路�掜�し

		
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 50000
----------------------------------------------------------------------------------------------------
<INPUT>
: ] = n_r, length
  for rep in syn[word]:
	if rep not in best:
	  queue.append((n_r, length, rep))
sum_n_r, sum_len = 0, 0
for n_r, length in [best[w[2]] for w in essay]:
  sum_n_r += n_r
  sum_len += length
print(sum_n_r, sum_len)
from collections import defaultdict

input()
index = {}
stat = lambda word: (word.count('r'), 
	len(word), index.setdefault(word, len(index)))
essay = list(map(stat, input().lower().split()))
queue = essay[:]

syn = defaultdict(list)
for i in range(int(input())):
  word, rep = list(map(stat, input().lower().split()))
  syn[rep[2]].append(word[2])
  queue.append(rep)
queue.sort(reverse=True)
best = {}
while queue:
  n_r, length, word = queue.pop()
  if word in best:
	continue
  best[word] = n_r, length
  for rep in syn[word]:
	if rep not in best:
	  queue.append((n_r, length, rep))
sum_n_r, sum_len = 0, 0
for n_r, length in [best[w[2]] for w in essay]:
  sum_n_r += n_r
  sum_len += length
print(sum_n_r, sum_len)
n, k = map(int, input().split())
t = list(map(int, input().split()))
s, p = [], [[] for i in range(max(t) + 1)]
for i, j in enumerate(t, 1): p[j].append(str(i))
if len(p[0]) - 1: print('-1')
else:
	for i in range(1, len(p)):
		if k * len(p[i - 1]) < len(p[i]):
	
<PREDICTION>
: 
 1
c
 n
	  i in range:n]:
	if rep[ in seen_
	  best.append(n_r, n + rep))
	_n_r, sum_n = 0, 0
for n_r, length in queue0[word]0] for w in best[
  sum_n_r, 1_r
  sum_n += length
 (sum_n_r, sum_len)
for collections import dedict

def()

 = 0
for = lambda word: (word[count('r'), word
	len(word)) index.setdefault(word. 1(word)))

 = = lambda(map(int, input().split().split()))
queue = deay:]
queuequeue = defaultdict(int)
for i, range(len(input())):
	 word = length = input(map(stat, input().lower().split()))
  queue[word[0]].append(word)2])
  queue.append(rep[
queue =sort()reverse=True)

 = [
for queue:
  word_r, length, rep = queue.pop()
  for word in best:
	best
  best[word] = n_r, length
  for rep inweight[word]:
	if rep not in best:
	  queue.append((n_r, length, rep))
sum_n_r, sum_len = 0, 0
for n_r, length in [best[w[2]] for w in37[
  sum_n_r += n_r
  sum_len += length
print(sum_n_r, sum_len)
from = m = map(int, input().split())

 = list(map(int, input().split()))
d = f = 00 []] for i in range(n(t)+ + 1)]
for i in j in enumerate(t): 1):
[i].append(i(i)
for len(p)k]) > k in s( '.1 -
else: printforfor i in range(1, len(p)): p		for p == 2(p[i]) 1]) - len(t[i]):
		
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 50500
----------------------------------------------------------------------------------------------------
<INPUT>
: 
	return a	

	
				
def interpreter(tape):
	out = []
	stack = [0]
	ip = 0
	while ip < len(tape):
		cmd = tape[ip]
		if cmd == '^': stack.pop()
		elif cmd == '!': stack.append(0)
		elif cmd == '+': stack[-1] = (stack[-1] + 1)  % 256
		elif cmd == '-': stack[-1] = (stack[-1] - 1)  % 256
		elif cmd == '*': out.append(chr(stack[-1]))
		elif cmd == '[':
			if stack[-1] == 0:
				while tape[ip] != ']': ip += 1
		elif cmd == ']':
			if stack[-1] != 0:
				while tape[ip] != '[': ip -= 1
		ip += 1
	return ''.join(out)
def interpreter(tape):
	a,stack,out=0, [0], []
	while a<len(tape):
		command=tape[a]   
		if   command == '^': stack.pop()
		elif command == '!': stack.append(0)
		elif command == '+': stack[-1]=(stack[-1]+1) % 256
		elif command == '-': stack[-1]=(stack[-1]-1) % 256
		elif command == '*': out.append(chr(stack[-1]))
		elif command == '[' and stack[-1]==0: a=tape.find(']', a)
		elif command == ']' and stack[-1]!=0: a=tape.rfind('[', a) 
		a += 1
	return ''.join(out)from __future__ import division
from numpy import *

def find_circle(a, b, c):
	if any(map(
<PREDICTION>
: 		

	
	def



	 solve(fape):
	t = []
	for = []0]
	for = 0
	for ip < len(tape):
		if = 0[ip]
		if cmd == '?'':
.append(
		elif cmd == '^': stack.append(stack)
		elif cmd == '^': stack.-1] += stackstack[-1] + 1) %
 2
		elif cmd == '-': stack[-1] = (stack[-1] + 1) % % 256
		elif cmd == '?'': stack.append(stackr(stack[-1]))
		elif cmd == '': stack			stack stack[-1] == 0: out				stack stack[ip] == ']': out += 1
			if cmd == '?'':
			if stack[-1] == 0:
				while instr[ip] != '': ip += 1
			 = 1
		 out'.join(out)def	 __(tape):
	stack, b,output,0,0],][]
	for stack<len(tape):
		if=stackape[a]



		if command command command== '^': stack.append()
		elif command == '>': stack.append(0)
		elif command == '>': stack[-1] =stack[-1]1)
 256
		elif command == '+': stack[-1] =stack[-1]+1) % 256
		elif command == '*': stack.append(stackr(stack[-1]))
		elif command == '* and stack[-1] ==0:
+=stackape[count(']',stack) :		elif command == ']': stack[-1]===0:
=tape.findfind(']',a])][
		el+= 1
	return ''.join(out)def collectionsfuture__ import __,
 operatorumpy import array

def code_min(t, n): c):
	if a(a(a
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 51000
----------------------------------------------------------------------------------------------------
<INPUT>
: (dp[i][j], mx)
print(mx)
from bisect import bisect_left

sum = [0]*200005
srt = []
n,t = list(map(int,input().split()))
a = list(map(int,input().split()))

tree = [0]*200005

def get(x):
	ans = 0
	while x:
		ans += tree[x]
		x -= x&-x
	return ans

def update(x):

	while x <= 200002:
		tree[x] += 1
		x += x&-x


for i in range(n):
	if i:
		sum[i] = sum[i-1] + a[i]
	else:
		sum[i] = a[i]
	srt.append(sum[i])

if 0 not in srt:
	srt.append(0)

srt.sort()

ans = 0
update(bisect_left(srt,0) + 1)




for i in range(n):
	l = min(len(srt)-1,bisect_left(srt,sum[i] - t))

	if srt[l] <= sum[i] - t:
		l = l+1

	cnt = get(l)
	ans += i + 1 - cnt


	update(bisect_left(srt,sum[i]) + 1)

print(ans)

n = input().rstrip()
m = input().rstrip()
cnt1 = [0] * 26
cnt2 = [0] * 26
for i in n:
	cnt1[ord(i) - ord("a")] += 1
for i in m:
	cnt2[ord(i) - ord("a")] += 1
res = 0
for i in range(26):
	a1 = cnt1[i]
	a2 = cnt2[i]
	if a1 == 0 and a2 != 0:
		print(-1)
		return
	res += min(
<PREDICTION>
: n[i][j] d),
	(dp)
n sysect import bisect_left,
n_ 00] *(001
for = = [
for, m = map(map(int,input().split()))
for = list(map(int,input().split()))
forfor = [[0]*200005
forfor find(x):
	non = 0
	while x>
		ans += x[x]
		x = x &(-x
	return ans

def get(x,
	while x <= n005:
		tree[x] += 1
		x -= x&-x
	def i in range(t):
	a tree ==
		tree[i] += get[i-1]
 get[i]
	else:
		sum[i] = sum[i]

	rt.append(sum(i])

for sum in in sumrt:
	printrt.append(sum)

forrt.sort()

ans = 0
for(0ect_left(srt,t)) - 1,


for i in range(n):
	if = bis(bis(srt[bis,bisect_left(srt[a[i]-)) srt
	if lrt[i] > t[i]: - trt
		ans -= min +1
	ansnt = 0(l)
	ans += c* 1
 cnt
	printif(lect_left(srt,sum[i] + 1)

print(ans)

, int()splitstrip()
t = int().splitstrip()

nt = = [0] * 100
cnt2 = [0] * 26
for i in range:
	cnt1[ord(i) - ord('a")] += 1
	 i in range:
	cnt2[ord(i) - ord("a")] += 1
ans = 0
for i in range(len):
	if = = cnt1[i]
	b2 = cnt2[i]
	b a1 > a: a2 == 0:
		res(1)
		return
	el += a(a
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 51500
----------------------------------------------------------------------------------------------------
<INPUT>
: , arr: List[int], k: int) -> int:
		n = len(arr)
		# dp = [0 for i in range(2*n)]
		# dp[0] = arr[0]
		# ans = dp[0]
		# dp = arr[0]
		# ans = dp
		# sums = sum(arr)
		# begin, maxbegin = 0, 0
		# end, maxend = 0, 0
		# for i in range(1, n * min(2, k)):
		#	 cur = arr[i % n]
		#	 if dp + cur >= cur:
		#		 dp = dp+cur
		#		 end = i
		#	 else:
		#		 dp = cur
		#		 begin, end = i, i
		#	 if dp > ans:
		#		 ans = dp
		#		 maxbegin = begin
		#		 maxend = i
		# if k == 1:
		#	 return ans if ans > 0 else 0
		# if ans < 0:
		#	 return 0
		# if maxend % n < maxbegin or maxend < n:
		#	 return ans  % (10**9+7)
		# else:
		#	 return (ans + sums*(k-2)) % (10**9+7)
		
		
		
		sums = sum(arr)
		dp = 0
		ans = -float('inf')
		for i in range(n * min(2, k)):
			cur = arr[i % n]
			dp = max(dp+cur, cur)
			ans = max(dp, ans)
		return max(0, ans, ans + sums* max(k-2, 0)) % (10**9+7)
class Solution:
	def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:
	
<PREDICTION>
:  y[ List[int]) m: int) -> int:
		if = len(arr)
		if dp[ [0 for _ in range(n*k+
		# forp[i] = arr[0]
		# for = arrp[0]
		# forp[ [[0]
		# for = dp[		# for = [(arr)
		# for = endi = 0, 0
		# for, minend = 0, 1
		# for i in range(n, n): k(k* k)):
		#	 if = arr[i] n]
		#	 if curp[ cur - max:
		#		 ansp[ dp +cur
		#		 begin = i
		#		:
		#		 curp = d
		#		 begin = max = i, i+		# return	 dp + max:
		#		 ans = dp
		#		 endend = i
		# return begin endend = i
		# return d == 1:
		#	 return max
 max < 0 else -
		# return k > 0:
		#	 return 0
		# return ans( == k == 0(: ansend < 0:
		#	 return 0

 (10**9 +7)
		# return:
		#	 return 0ans + d -nn-1)) % (10**9+7)
		
		#		
		
 = = sum(arr)
		n = [
		for = dsys('inf')
		for i in range(1- min(2, k+):
			cur = arr[i] n]
			if = d(dp,cur, d -
			ans = max(ans+ d)
		return ans(ans, ans) d) sums *((n,1, 0)) % (10**9+7)
	 Solution:
	def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:
		
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 52000
----------------------------------------------------------------------------------------------------
<INPUT>
: 		else: sum_L = prefix_sum[start+L-1] - prefix_sum[start-1]
			
			if start-1 >= M-1:
				max_sum = max(max_sum, sum_L + M_sum_smaller_than[start-1])
			if start+L <= len(A)-M:
				max_sum = max(max_sum, sum_L + M_sum_greater_than[start+L])
			
		return max_sum
		
class Solution:
	def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:
		
		i=0
		maxL = []
		maxM = []
		maxSum = 0
		
		while i<=len(A)-L:
			maxL.append(sum(A[i:i+L]))
			i+=1
			
		i = 0
		while i<=len(A)-M:
			maxM.append(sum(A[i:i+M]))
			i+=1

		for i,elem in enumerate(maxL):
			if i-M<=0:
				prefix = []
			else:
				prefix = maxM[0:i-M]
			
			if len(maxM[i+L:]+prefix)== 0:
				continue
			maxSum = max(maxSum,elem+max(prefix+maxM[i+L:]))
		
		return maxSum		class Solution:
	def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:
		Lsum = [(sum(A[:L]), 0)]
		Msum = [(sum(A[:M]), 0)]
		for i in range(1, len(A) - L + 1):
			Lsum.append((Lsum
<PREDICTION>
: 		:
 +=a[ sum[sum[i_1-1]
 prefix_sum[start+L]
							if ( ==L >= 0:1:
				sum_sum = max(max_sum, sum_L + prefix -sum))est(sum_start-1])
			
 start+1- M(prefix):1-
				max_sum = max(max_sum, sum_L + M_sum_smaller_than[start+L-
			
			 max_sum
				 Solution:
	def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:
		prefix		prefix =0
		j_= 0
		
Sum = []
		
Sum = 0
		
		for i<lenL(A):M+
			
L.append(A(A[i:i+L]))
			i+=L
			
		max= 0
		while i<=len(A)-M:
			maxM.append(sum(A[i:i+M]))
			i+=1
		max i inx in in enumerate(maxM):
			if ele<L<0e:
				eSum sum
				:
				prefix. [([i:i+M]
							prefix i(prefixL)i:M-)-prefix)>L:
				max
			elseSum = max(maxSum, sumlem+eSumprefix,[M[i-L-))
					return maxSum
		 Solution:
	def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:
		
 = = [sum(a[iL]) sum,
		M = = sumsum(A[iL]), 0)]
		for i in range(len, len(A) - L + 1):
			Lsum.append(sumsum[
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 52500
----------------------------------------------------------------------------------------------------
<INPUT>
: [i][0], blue[i][1])]
	red[i] = red[i] + kagi_r
	blue[i] = blue[i] + kagi_b
	'''
red.sort(key=lambda x: (x[0], x[1]), reverse=True)
blue.sort(key=lambda x: x[1])
flg_r = [0]*n
cnt = 0

for i in range(n):
	for j in range(n):
		if flg_r[j]:
			continue
		if red[j][0] < blue[i][0] and red[j][1] < blue[i][1]:
			flg_r[j] = 1
			cnt += 1
			break

print(cnt)

def test():
	arr=[]
	ans=0
	first_input=input()
	first_num=first_input.split()
	a=int(first_num[0])
	b=int(first_num[1])
	sec_input=input()
	sec_num=sec_input.split()
	if len(sec_num)==a:
		pass
	else:
		print('Wrong input')


	for i in sec_num:
		arr.append(int(i))

	for i in range(0,len(arr)-1):
		num=arr[i]
		num_2=arr[i+1]
		if num_2-num>b:
		  ans+=b
		else:
		  ans+=num_2-num

	ans+=b
	print(ans)


test()n = int(input())
shelf, L, R = {}, 0, 0
p, d = input().split()
shelf[d] = 0
for i in range(n-1):
	p, d = input().split()
	if p == 'L':
		shelf[d] = L - 1
		L -= 1 
	elif  p == 'R':
		shelf
<PREDICTION>
: i]j] d[i][1])

		 =i][ = red[i][ + blue
[num

red[i] = blue[i] + kcount_r
	blue'
	 =sort(key=lambda x: xx[0], x[1] reverse=True)
blue.sort(key=lambda x: ([0],

 = =r = [red] *(
fornt = 0
forfor i in range(n):
	if j in range(n):
		if redg_r[i]
			if
		if i[i]0] <= red[i][0]: and red[i][1] < red[i][1]:
			cg_r[j] = 1
			cnt += 1
			red
	print(cnt)

 main(
	n =[]
	n=0
	for=index=[]().
	arr_input=first_input.split("
	n=int(first_num[0])
	b=int(first_num[1])
	c_num=[]()
	b_input=first_input.split()
	b a(sec_input)==1:
		arr
	el:
		sec(Noel')')

test
 i in range_num:
		if.append(int(i))
	arr i in sec(a,len(arr)1):
		if=arr[i]
		if1sec=arr[i+1]
		if num_2<num_0:
			 +=1
		else:
			 if+=num
2
num
	print+=b
	print(ans)


test()
, int(input())
a = = bb R = [}, {
 0
for = s = 0().split()
forlf,0] = int
p i in range(n):1):
	p. d = input().split()
	p p == 'L':
		iflf[d] += 1
 p
		L -= 1

		if p p == 'R':
		iflf[
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 53000
----------------------------------------------------------------------------------------------------
<INPUT>
: m2 = int(m1)
		m1 = w[0]


print(*B)

def solve(n,k):
	print(1*k,end = ' ')
	if n==2:
		print(2*k,end = ' ')
	if n == 3:
		print(k,3*k,end = ' ')
	else:
		temp = n//2
		if(n%2 == 0): temp -= 1
		print((str(k)+' ')*temp,end='')
		if(n>3):
			solve(n//2,k*2)

n = int(input())
solve(n,1)from math import log2
import sys
out = sys.stdout
n = int(input())
if n == 3:
	print(1, 1, 3)
else:
	tmp = n
	current = 1
	while n != 1:
		if n % 2 != 0:
			z = (n//2) + 1
		else:
			z = n//2
		for i in range(z):
			out.write(str(current) + ' ')
		n -= z
		current *= 2
	step = int(log2(tmp))
	if tmp % 2**(step - 1) == 0:
		out.write(str(tmp))
	else:
		q = 2**(step - 1)
		ans = 0
		for i in range(1, 1000):
			if q*i <= tmp:
				ans = max(ans, q*i)
			else:
				break
		out.write(str(ans))from math import *

c=int(input())
x=[0]*c
y=[0]*c
vu=[False]*c
for i in range(c):
	x[i],y[i]=[int(s) for s in input().split()]
prix=[int(s) for s in input().split()]
fil=[int(
<PREDICTION>
:  = = list(input2)
			2 = int1m]
		(m,

 main(n, m,
	if(k,n)2=" " ')
	for n ==k:
		return(1*k,end = ' ')
		 k== 3:
		print(2,end*k)end = ' ')
	if:
		print = (
2
		temp tempn%2== 0):
 = 1
		if(n(temp)+' '+()end ='')
		k(n%2): temp			print =(n,2,k)2,
	def, int(input())
ifolve(n,k)
 sys import *

n math

 = sys.stdout

 = int(input())
if n == 1:
	print(1, 2, 2)
	:
	if = n //	if = n
	while True > 1:
		if n % 2 == 0:
			if = nn //2) - 1
			:
			z = (//2 +		if i in range(z,
			if +=write(str(i) + ' ')
			 -= 1
		if +== 2
	print = 1(log2(n))
	if step == 2 ==stepstep) 1) == 0:
		print.write(str(step //
	else:
		print = step
(step - 1)
		for = []
		for i in range(step, step):
			if i %i > q:
				ans += i(ans, step*i)
			else:
				ans
		if.write(str(ans))
 math import log

nntint(input())
if=int]*100
y=[0]*c
for=0]*c
for i in range(c):
	x[i]=y[i]=mapint(x) for s in input().split()]
	==False(x) for s in input().split()]

yint(s
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 53500
----------------------------------------------------------------------------------------------------
<INPUT>
: ][0]) + abs(ps[idx][1] -
															  ps[j][1])
					if weight < keys[j]:
						keys[j] = weight

		return cost


sol = Solution()

points = [[0, 0], [2, 2], [3, 10], [5, 2], [7, 0]]
# points = [[3, 12], [-2, 5], [-4, 1]]
# points = [[0, 0], [1, 1], [1, 0], [-1, 1]]
# points = [[-1000000, -1000000], [1000000, 1000000]]
# points = [[0, 0]]
class Solution:
	def minCostConnectPoints(self, points: List[List[int]]) -> int:
		n = len(points)
		distance = lambda u, v: abs(points[u][0] - points[v][0]) + abs(points[u][1] - points[v][1])
		
		graph = defaultdict(list)
		for u in range(n):
			for v in range(u + 1, n):
				dist = distance(u, v)
				graph[u].append((dist, v))
				graph[v].append((dist, u))
		
		count = 1
		cost = 0
		visited = [True] + [False] * (n - 1)
		heap = graph[0][:]
		heapify(heap)
		
		while heap:
			dist, u = heappop(heap)
			if not visited[u]:
				visited[u] = True
				count += 1
				cost += dist
				for link in graph[u]:
					heappush(heap, link)
			
			if count >= n:
				break
		
		return cost
class Solution:
	def minCost
<PREDICTION>
: j]
 1(p[ix][1] - ps																 [id][1] +						 id > min[id][
						id[j] = weight
			 sorted
		 = solve()

def = [0, 0, [0, 0], [3, 4], [4, 4]] [4, 4]]

 print = [0, 6, [1, 4], [2, 6],
# points = [[1, 1], [1, 1], [2, 2]] [1, 1],
# points = [[01,, -1000000, [1000000, 10000000]]
# points = [[0, 1],
# Solution:
	def minCostConnectPoints(self, points: List[List[int]]) -> int:
		n = len(points)
		if = [[ p, v: abs(u[u][0] - points[v][0]) + abs(points[u][1] - points[v][1])
		
		ed = collectionsdict(list)
		for i in range(n):
			for v in range(u + 1, n):
				if = abs(points, v)
				graph[u].append((v, v))
				graph[v].append((dist, u))
		
		vis = 0
		vis = 0
		visited = setFalse] * [False] * nn - 1)
		
ap = [([0]0
		heapq(heap)
		
		while heap:
			dist, u = heappop(heap)
			if not visited[u]:
				visited[u] = True
				count += 1
				if += dist
				if v in graph[u]:
					ifappush(heap, link)
						returnif count == n -
				break
		return		return cost
	 Solution:
	def minCostConnect
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 54000
----------------------------------------------------------------------------------------------------
<INPUT>
: a,b = map(int, input().split())
	graph[a].append(b)
	graph[b].append(a)

# dist = [-1]*(n+1)
# dist[0] = 0
# dist[1] = 0
mark = [-1]*(n+1)
mark[0] - 0
mark[1] = 0


d = deque()
d.append(1)

while d:
	v = d.popleft()
	for i in graph[v]:
		if mark[i] != -1:
		# if dist[i] != -1:
			continue
		mark[i] = v
		# dist[i] = dist[v] + 1
		d.append(i)

if '-1' in mark:
	print('No')
else:
	print('Yes')
	print(*mark[2:], sep='\n')
from collections import deque
H, W = list(map(int, input().split()))
route = []
n_black = 0
for _ in range(H):
  tmp_ls = input()
  n_black += tmp_ls.count("#")
  route.append(tmp_ls)
visited = [[False]*W for _ in range(H)]
dist = [[-1]*W for _ in range(H)]
dist[0][0] = 0
tmp = [0,0]
goal = [H-1, W-1]
kouho = deque()
def rinsetsu(ls):
  x, y = ls[0], ls[1]
  ans = []
  if x-1 >= 0:
	ans.append([x-1, y])
  if x+1 <= H-1:
	ans.append([x+1, y])
  if y-1 >= 0:
	ans.append([x, y-1])
  if y+1 <= W-1:
	ans.append([x, y+1])
  return ans
for ls in rinsetsu([0,0]):
  if route[ls[0]][ls
<PREDICTION>
: , b, map(int,input().split())
	a[a].append(b)
	graph[b].append(a)

visprint[ {}1] *(n+1)
# dist[0] = 0
# dist[1] = 0
# = [1]*(n+1)
for[1] =1 =mark[1] = 0

def = deque()
d.append(1)
whilewhile d:
	v = d.popleft()
	for i in graph[v]:
		if mark[i] == -1:
			 dist mark[i] == -1: continue		#continue
		if[i] = v
		d dist[i] = dist[v] + 1
		d.append(i)

# leninf1 - not mark:
	print("No')
else:
	print('Yes')
	for('mark[1:]) sep='\n')
import collections import deque
n,W = map(map(int, input().split()))
S = [
forodesroute = [
for i in range(n):
	 n =white = list().
  for_black += tmp_ls.count('#")
  for.append(tmp_ls)

ited = [False] *( for _ in range(H)]
vis = [--1]*( for _ in range(H)]
dist[0][0] = 0
q_ de0] 0]
while = [0-1,W-1]
while =q = deque()
while d(():(x):
  non = y = ls.0] ls[1]
  for = []
  for x ==1 >= 0 and
	return.append(x-1, y])
	 el y+1 < W-1:
	ans.append([x+1, y])
  if y-1 >= 0:
	ans.append([x, y-1])
  if y+1 <= W-1:
	ans.append([x, y+1])
  return ans

 i in rangeinsorf(0, 0,):
  for ls[ls[0]][ls[
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 54500
----------------------------------------------------------------------------------------------------
<INPUT>
: , x, y):
		x, y = self.find(x), self.find(y)
		if x != y:
			if self.data[y] < self.data[x]:
				x, y = y, x
			self.data[x] += self.data[y]
			self.data[y] = x
		return (x != y)
	def same(self, x, y):
		return (self.find(x) == self.find(y))
	def size(self, x):
		return -self.data[self.find(x)]



N, M, *I = map(int, open(0).read().split())
AB, LR = I[:2 * N], I[2 * N:]

A, B = map(list, zip(*sorted(zip(*[iter(AB)] * 2))))
D = [l ^ r for l, r in zip([0] + B, B + [0])]
E = [set() for _ in range(N + 1)]

uf = UnionFind(N + 1)
for i, (l, r) in enumerate(zip(*[iter(LR)] * 2), 1):
	li = bisect_left(A, l)
	ri = bisect_right(A, r)
	if li == ri or uf.same(li, ri):
		continue

	uf.union(li, ri)
	E[li].add((ri, i))
	E[ri].add((li, i))


used = set()
def dfs(v, p):
	res = D[v]
	for u, c in E[v]:
		if u == p:
			continue
		ret = dfs(u, v)
		if ret == 1:
			used.add(c)
		D[u] = 0
		res ^= ret
	return res

for v in range(N + 1):
	if D[v]:
		D[v] = dfs(v, -1)

if all
<PREDICTION>
:  7, y =
			, y = y.find(x), self.find(y)
		if x == y:
			if self.parents[x] < self.data[x]:
				x, y = y, x
			self.data[x] += self.data[y]
			self.data[y] = x
			 xx, y)
	def size(self, x, y):
		return selfself.find(x) == self.find(y))
	def size(self, x):
		return -self.data[self.find(x)]
	nn, M = KA = list(int, open(0).read().split())

 = cd = I[:N * N], I[2 * N :

uf = B = AB(int, zip(*[orted(zip(*[iter(AB)] * 2)))
print = [[0 + r for r, r in zip(*A] + D + [ + [A])] +
 = [[0() for _ in range(2 + 1)]
forfor = UnionFind(N + 1)
for a, (l, r) in enumerate(zip(*[iter(AB)] * 2) 1):
	l, bisect_left(A, l)
	ri = bisect_left(D, r)
	if li == rj: rf.same(li, ri):
		continue
	A.union(li, lii)
	A[li].add(i, i))
	E[ri].add((li, i))

for = set()
for dfs(v, p):
	if = 1[v]
	for n, w in E[v]:
		if u == p:
			continue
		if = maxfs(u, v)
		if ret: -:
			return.add(u)
			[c] = ret
		if +== 1
	return res

print i in range(1 + 1):
	if v[v]
		continue[v] = 1fs(v, v1)
	print len(
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 55000
----------------------------------------------------------------------------------------------------
<INPUT>
: 	 queue.append((new_row, new_col, eliminate, steps+1))

#		 return -1
class Solution:
	def shortestPath(self, grid: List[List[int]], k: int) -> int:
		r, c = len(grid), len(grid[0])
		if r == 1 and c == 1:
			return 0
		q = deque([(0, 0, 0, 0)])	# row, col, num of obstables met, steps 
		visited = set((0, 0, 0))
		
		while q:
			row, col, met, step = q.popleft()
			if met > k:
				continue
			if row == r-1 and col == c-1:
				return step
			for nr, nc in [[row+1, col], [row-1, col], [row, col+1], [row, col-1]]:
				if 0 <= nr < r and 0 <= nc < c:
					if grid[nr][nc] == 1 and met+1 <= k and (nr, nc, met+1) not in visited:
						visited.add((nr, nc, met+1))
						q.append((nr, nc, met+1, step+1))
					if grid[nr][nc] == 0 and met <= k and (nr, nc, met) not in visited:
						visited.add((nr, nc, met))
						q.append((nr, nc, met, step+1))
		
		return -1class Solution:
	def shortestPath(self, grid: List[List[int]], k: int) -> int:
		r, c = len(grid), len(grid[0])
		if r == 1 and c == 1:
			return 0
		q = deque([(0, 0, 0, 0)])	# row, col, num
<PREDICTION>
: 	 =append((x_x, new_col, new)) steps +1))
	#			 -1
	 Solution:
	def shortestPath(self, grid: List[List[int]], k: int) -> int:
		if, c = len(grid), len(grid[0])
		if r < 0 and c == 1:
			return 0
		if = deque([(0,0, k, k,])
	 row, col, step of moves


 steps

		seenited = set()0, 0, 0,
		while		while q:
			row, col, steps, step = q.popleft()
			if row == r or
				return
			if row == r-1 and col == c-1:
				return step
			
 dx_, nc in [(row+1, col], [row,1, col], [row, col+1], [row, col-1]]:
				if n <= nr < r and 0 <= nc < c:
					if grid[nr][nc] == 1 and ( >1 < k and (nr, nc, met+1) not in visited:
						visited.add((nr, nc, met+1))
						q.append((nr, nc, met+1, step+1))
					if grid[nr][nc] == 0 and (+ k and (nr, nc, met) not in visited:
						ifited.add((nr, nc, met))
						q.append((nr, nc, met, step+1))
					return -1class Solution:
	def shortestPath(self, grid: List[List[int]], k: int) -> int:
		if, c = len(grid), len(grid[0])
		if r < 1 and c == 1:
			return 0
		if = deque([(0,0, 0, k)])
	 row, col, step of
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 55500
----------------------------------------------------------------------------------------------------
<INPUT>
: _multi_edge(self, v1, v2, cap1, cap2):
		edge1 = [v2, cap1, None]
		edge1[2] = edge2 = [v1, cap2, edge1]
		self.G[v1].append(edge1)
		self.G[v2].append(edge2)

	def bfs(self, s, t):
		self.level = level = [None]*self.N
		deq = deque([s])
		level[s] = 0
		G = self.G
		while deq:
			v = deq.popleft()
			lv = level[v] + 1
			for w, cap, _ in G[v]:
				if cap and level[w] is None:
					level[w] = lv
					deq.append(w)
		return level[t] is not None

	def dfs(self, v, t, f):
		if v == t:
			return f
		level = self.level
		for e in self.it[v]:
			w, cap, rev = e
			if cap and level[v] < level[w]:
				d = self.dfs(w, t, min(f, cap))
				if d:
					e[1] -= d
					rev[1] += d
					return d
		return 0

	def flow(self, s, t):
		flow = 0
		INF = 10**9 + 7
		G = self.G
		while self.bfs(s, t):
			*self.it, = map(iter, self.G)
			f = INF
			while f:
				f = self.dfs(s, t, INF)
				flow += f
		return flow


import sys
sys.setrecursionlimit(10 ** 7)

<PREDICTION>
: i_edge(u, graph,, v2): i1, cap2):
		"""1[ [v2, cap1, None]
		edge1[2] = edge2 = [v1, cap2, edge1]
		self.edge[v1].append(edge1)
		self.G[v2].append(edge2)

	def bfs(self, s, t):
		self.level = level = [None]*self.N
		deq = deque([s])
		level[s] = 0
		G = self.G
		while deq:
			v = deq.popopleft()
			lv = level[v] + 1
			for w, cap, _ in G[v]:
				if cap and level[w] is None:
					level[w] = lv
					deq.append(w)
		return level[t] is not None

	def dfs(self, v, t, f):
		if v == t:
			return f
		level = self.level
		for e in self.it[v]:
			w, cap, rev = e
			if cap and level[v] < level[w]:
				d = self.dfs(w, t, min(f, cap))
				if d:
					e[1] -= d
					rev[1] += d
					return d
		return 0

	def flow(self, s, t):
		flow = 0
		whileF = 10**9 + 7
		G = self.G
		while self.bfs(s, t):
			*self.it, = list(iter, self.G)
			f = INF
			while f:
				f = self.dfs(s, t, INF)
				flow += f
		return flow
	N sys
sys.setrecursionlimit(10 ** 6)


----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 56000
----------------------------------------------------------------------------------------------------
<INPUT>
:  1
					countL -= 1
				
				countR = k
				while right < cols - 1 and countR > 0:
					right += 1
					countR -= 1
				
				ans[i][j] += mat[bottom][right]

				if top - 1 >= 0 and countT == 0:
					ans[i][j] -= mat[top - 1][right]
				if left - 1 >= 0 and countL == 0:
					ans[i][j] -= mat[bottom][left - 1]
				if top - 1 >= 0 and left - 1 >= 0 and countT == 0 and countL == 0:
					ans[i][j] += mat[top - 1][left - 1]
				
		return ansclass Solution:
	def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:
		if not mat or not mat[0]:
			return mat
		R, C = len(mat), len(mat[0])
		l2r = [[0] * C for _ in range(R)]
		t2b = [[0] * C for _ in range(R)]
		
		for r in range(R):
			for c in range(C):
				l2r[r][c] += mat[r][c]
				if c != 0:
					l2r[r][c] += l2r[r][c-1]
				
				t2b[r][c] += mat[r][c]
				if r != 0:
					t2b[r][c] += t2b[r-1][c]
		
		ret = [[0] * C for _ in range(R)]
		for r in range(R):
			for c in range(C):
			
<PREDICTION>
: 
						 += += 1
									ifR += count -				
 count < n and and 1 and leftL >= 0:
					if += 1
					countR -= 1
									if =i]j] = count[i][j]
		returnreturnleft count == left >= 0 and matL > 0:
					ans[i][j] += 1[bottom][ 1][bottom]
					 top - 1 >= 0 and countT > 0:
					ans[i][j] -= mat[bottom][left - 1]
				if left - 1 >= 0 and count - 1 >= 0 and countT == 0: countL == 0:
					ans[i][j] -= mat[bottom - 1][right - 1]
				
			 ansclass Solution:
	def numBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:
		m not mat: not mat[0]:
			return []
		
 = C = len(matrix len(mat[0])
		
 =,, []0] * C for _ in range(R)]
		for2r = [[0] * C for _ in range(R)]
		for		for r in range(R):
			for c in range(C):
				if2r[r][c] = mat[r][c]
				l c > 0:
					l2r[r][c] -= mat2r[r][c -1]
				if		for	if2b[r][c] += 12r][c]
				if r != 0:
					l2b[r][c] += l2b[r-1][c]
					ans = [[0] * C for _ in range(R)]
		for r in range(R):
			for c in range(C):
				
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 56500
----------------------------------------------------------------------------------------------------
<INPUT>
: [name]
			current = name
			while current in used:
				k += 1
				current = '%s(%d)' % (name, k)  # alternative to current = name+'('+str(k)+')'
			hashmap[name] = k
			result.append(current)
			used.add(current)
		return result
from typing import List



class Solution:
	def getFolderNames(self, names: List[str]) -> List[str]:
		exists = {} # maps a name to its count.
		res = [] 
		for name in names:
			if name not in exists:
				res.append(name)
				exists[name] = 1
			else:
				
				newName = '{}({})'.format(name, exists[name])
				exists[name] += 1
				while newName in exists:
					newName = '{}({})'.format(name, exists[name])
					exists[name] += 1
				exists[newName] = 1
				res.append(newName)
		return res



s = Solution()
class Solution:
	
	def getFolderNames(self, names: List[str]) -> List[str]:
		
		result = list()
		dictionary = dict()

		# Iterate over names
		for name in names:
			
			# If name is not in the dictionary, then add it to the dictionary and append it to the results
			if (name not in dictionary.keys()):
				dictionary.setdefault(name, 1)
				result.append(name)

			# Otherwise, build a unique name, add the unique name to the dictionary, and update the suffix of the name.
			else:
				unique_name = name
				suffix_number = dictionary[name]

	
<PREDICTION>
: i] =				_ self
			
 current: d:
				current = 1
				if = current%s %%d)' % currentname, k)

 this the the
 % %d%+str(k))')'
			used_[name] = current
			current.append(current)
			current.add(current)
		return result
	 collections import List,
classclass Solution:
	def getFolderNames(self, names: List[str]) -> List[str]:
		defists = set
 name to list, check first

		for = []

		for name in names:
			if name not inex:
				if.append(name)
				exists[name] = 1
			else:
				ex				if_ = name%name({}'.format(name, new[name])
				newists[name] += 1
				new lenName in exists:
					newName = new{}({})'.format(name, new[name])
					exists[new] += 1
				resists[nameName] += 1
				res.append(newName)
		return resclass
class# = input()
t Solution:
	def	def getFolderNames(self, names: List[str]) -> List[str]:
		
		def = []()
		
 = = {}()
		for printate through the,		for name in names:
			if			if if name is a in the dictionary, return the it to the dictionary
 the
 to the dictionary
			# namename not in dictionary):keys()):
				dictionary[setdefault(name, {})
				d.append(name)
			# Otherwise, add the dictionary name, add it name name to the dictionary and and add the dictionary
 the dictionary

			if:
				d_name = name
				whileix_name = name[name]
		
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 57000
----------------------------------------------------------------------------------------------------
<INPUT>
:  in avail:
				avail[nxtt] = avail[tuple(curr)]+1
				q.append(nxt)
t = int(input())
while t:
	inp = input()
	grid = []
	for i in range(3):
		inp = input()
		for j in inp.strip().split(" "):
			grid.append(int(j))
	gridt = tuple(grid)
	if gridt in avail: print(avail[gridt])
	else: print(-1);
	t-= 1# cook your dish here
t=int(input())
while(t):
	n=int(input())
	#n,k=map(int,input().split())
	l=list(map(int,input().split()))
	ans=0
	for i in range(len(l)):
		#print(ans^l[i])
		ans=(ans^l[i])
		
	print(ans)
	t-=1t=int(input())
for o in range(t):
 n=int(input())
 l=list(map(int,input().split()))
 q=int(input())
 l1=[]
 c=0
 for i in l:
  if i%2==0:
   c+=1
   l1.append(c)
  else:
   l1.append(c)
 #print(l1)
 for v in range(q):
  l,r=map(int,input().split())
  l-=1
  r-=1 
  if l==0:
   if l1[r]>0:
	print("EVEN")
   else:
	print("ODD")
  else:
   l-=1
   x=l1[r]-l1[l]
   if x>0:
	print("EVEN")
   else:
	print("ODD")t = int(input())
for cases in range(t):
 n = int(input())
 arr = list(map(int
<PREDICTION>
:  range:
					g[iums]] = 0[n](avr)] +1
				if.append(nxt)
	 = int(input())
for t:
	tp = input().
	n = []
	for i in range(3):
		gridp = input()
		for j in inp.split().split(" "):
			grid.append(int(j))
	grid. = [](grid)
	grid gridt in avail:
("avail[gridt])
	else: print(-1)
	t-= 1
 cook your dish here
t=int(input())
for tt):
	in=int(input())
	an,m=map(int,input().split())
	#=[](map(int,input().split()))
	l=[]
	for i in range(n(l)):
		ifl(l,i[i])
		if+=ans^l[i])
	printif	print(ans)
	t-=1# =int(input())
for i in range(t):
	=int(input())
 a=list(map(int,input().split()))
 ans=int(input())
 for==[]
 for=0
 for i in range:
  if i==2==0:
   c+=1
  else if1.append(i)
  else:
   l1.append(c)
 forprint(l1)
 if i in l(1):
  x=r=map(int,input().split())
  if1=1
  r-=1

  if l==0:
   print l1[l]===:
	l(--EN")
   else:
	print("EVD")
  else:
   if1=1
   r=l//[r]11[l]
   if x%0:
	print("EVEN")
   else:
	print("ODD")
= int(input())
for _ in range(t):
 n = int(input())
 a = list(map(int,
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 57500
----------------------------------------------------------------------------------------------------
<INPUT>
:  - 1):
			for last in range(first + 1, len(segment_xor[first])):
				if segment_xor[first][last] == 0:
					n_triplets += last - first
					
		return n_tripletsclass Solution:
	def countTriplets(self, arr: List[int]) -> int:
		
		triplets = 0
		
		#rangeXOR[i,j] stores XOR of elements from arr[i] to arr[j] (both incl), i<j
		#rangeXOR = []
		for i, a in enumerate(arr):
			#tackle sub arrays starting at arr[i]
			subrange = []
			
			for j, b in enumerate(arr[i:]):
				j_absolute = i + j
				
				if j_absolute == i:
					subrange.append(b)
				else:  #j_absolute > i
					subrange.append(subrange[-1] ^ b)
				
				if subrange[-1] == 0:
					#output all triplets here
					triplets += j   #j_absolute - i
					
			#rangeXOR.append(subrange)
			
		return tripletsclass Solution:
	def countTriplets(self, arr: List[int]) -> int:
		prefix_xor = [arr[0]]
		answer = 0
		
		for i in range(1, len(arr)):
			prefix_xor.append(prefix_xor[i-1] ^ arr[i])
		
		for i in range(len(arr)):
			for j in range(i+1, len(arr)):
				
				a = prefix_xor[j]
				
				if i > 0
<PREDICTION>
:  1]
				 j in range(1, 1, last(arrats)list))i])):
				if (_xor[last][last] == 1:
					seumsseplets += 1
 first
					break			 n_tripletsclass Solution:
	def numTriplets(self, arr: List[int]) -> int:
		n		nplets = 0
		for		for find(

i]j] = theOR[ all
 arr[i]
 arr[j]
1 inclusive) and,=
		forrangeXOR[ [
		
 i in num in enumerate(arr):
			trifor thearr
 with i[i]
			forarray = [
			for			for j in b in enumerate(arr):i+):
				if +=, = j - 1
				if				if j_Less >= 0:
					continuebin.append(b)
					:

 b_max = i
					subrange.append(brange[-1] + b)
									if jrange[-1] == b:
					triprint
 elementst of
					triplets += 1_
 #output ismax < i
					
				output XOR[ (subrange)
						return tripletsclass Solution:
	def countTriplets(self, arr: List[int]) -> int:
		n_sumor = [0[0]]
		for = 0
		for		for i in range(1, len(arr)):
			prefix_xor.append(arr_xor[--1] ^ arr[i])
					for i in range(len(arr)):
			for j in range(i+1, len(arr)):
				for				if = prefix_xor[j]
				b				for a == 0 and
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 58000
----------------------------------------------------------------------------------------------------
<INPUT>
:  j == 0:
						states[i][0] = sum([sums[index] for index in range(6) if index != i]) % (10**9 + 7)
					
					else:
						states[i][j] = states[i][j-1]
		
		return sum([sum(x) for x in states]) % (10**9 + 7)
class Solution:
	def dieSimulator(self, n: int, rollMax: List[int]) -> int:
		m = max(rollMax)
		dp = [[[1]*m for _ in range(len(rollMax))] for _ in range(n)]
		dp[0] = [[1]+[0]*(m-1) for _ in range(len(rollMax))]
		MOD = 1e9+7
		sumPrev = [1]*len(rollMax)
		for i in range(1, n):
			tempSumPrev = [0]*len(rollMax)
			totalSumPrev = 0
			for p in sumPrev:
				totalSumPrev = (totalSumPrev+p)%MOD
			for j in range(len(rollMax)):
				dp[i][j][0] = totalSumPrev-sumPrev[j]
				s=dp[i][j][0]%MOD
				for k in range(1, rollMax[j]):
					dp[i][j][k] = dp[i-1][j][k-1]
					s = (s+dp[i][j][k])%MOD
				tempSumPrev[j] = s
			sumPrev = tempSumPrev
		return int(sum(sumPrev)%MOD)MAX = 10 ** 9 + 7


class Solution:
	
	def dieSimulator(self, n: int, rollMax: List[int]) -> int:
		D = [[0] * 6 for i in range(n + 1)]
	
<PREDICTION>
:  in 0:
							[(][j] = 1(statesolve[i] for index in range(len) if index != 0])
 MOD10**9 + 7)
											states:
						states[i][0] = sum[i-j-1] +						 sum(states(states) for x in states]) % (10**9 + 7)class	 Solution:
	def numSimulator(self, n: int, rollMax: List[int]) -> int:
		mod = 10(rollMax)
		dp = [[00 for *( for i in range(n(rollMax))] for _ in range(n)
		
[0][ = [[][0]*mm-1) for _ in range(len(dpMax))]
		for = 10e9+7
		for( = [[0]*((rollMax)
		for i in range(1,len):
			sum = =[ [0]*len(rollMax)
			forSum =[ [
			for j in rangem:
				ifSum = += sumtotalSum ==-pow%MOD
				 j in range(len(rollMax)):
				if[i][j][1] = sumSum353
sum(
j-
				total =sum[i-j][0]
MOD
				if k in range(1, rollMax[j]):
					s[i][j][k] = sump[i-1][k][k-1]
					s% ss+dp[i][j][k])%MOD
					Sum =[j] = sum%				M[ sumSum ==
		return sum(sum(sum())%MOD)class = 10** 9 + 7

class Solution:
	def	def dieSimulator(self, n: int, rollMax: List[int]) -> int:
		
 = {}0 for * ( for _ in range(n)] 1)]
		
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 58500
----------------------------------------------------------------------------------------------------
<INPUT>
:  = S + (C-B)*count_B

	print(S)# -*- coding: utf-8 -*-
"""
Created on Mon Sep  7 01:13:08 2020

@author: liang
"""
"""
ABC  171 D 差分更新　パケット変換
【無駄な探索は行わない（メモリ化） ⇒　パケット変換】
パケット
　値vが出現する回数を記録しておく

dict()方式　⇒　探索にO(logn) or O(n)がかかる
配列方式　⇒　探索がO(1)となる!

【差分更新】
値Bが全て値Cになる
　⇒　(C - B) * 値Bの個数だけ増加する
 ⇒　値Cの個数　+= 値Bの個数
 ⇒　値Bの個数　= 0
"""

N = int(input())
A = [int(i) for i in input().split()]
Q = int(input())

d = [0]*(10**5)

for i in A:
	d[i-1] += 1

ans = sum(A)

for i in range(Q):
	b, c = map(int,input().split())
	ans += (c-b)*d[b-1]
	d[c-1] += d[b-1]
	d[b-1] = 0
	print(ans)n = int(input())
a = list(map(int, input().split()))

s = sum(a)
count = {}
for x in a:

<PREDICTION>
:  0[ 1N[1)(
s
		(ans)
!/*- coding: utf-8 -*-


Created on". Sep  8::01:18 2020

@author: liang
"""



D = =
��
�の��
�
�Aター
�敏��N �琙��ら��索

�う�ない
���なンー�
��

で��
ット変換


タット�
�瀋が
刺て���る
�数
樈録すてい�く
""""""_
吏に�凒(�v��索
な(logogn)
 O(N)
��れ

��列の�吏を�O���O��索と�(n)
しる


"""
�分替す�


��v��ての��と(�る�
�O���
0- B)
 C��の�
��数
け
��加
る

��逤Cに��数
�� C��C
��数

[　Cの��数
�� �



import, int(input())
A = listint(a) for i in input().split()]

 = int(input())

# = {}0] *(N**5+

for i in range:
	d[i]1] = 1

for = 0(d)

for i in range(10):
	l = c = map(int, input().split())
	ans -= (c-B)*d[b]1]
	d[c-1] += d[b-1]
	d[b-1] = d
	d(ans)n = int(input())
a = list(map(int, input().split()))
qq = [(a)

 = 0
for i in a:
	
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 59000
----------------------------------------------------------------------------------------------------
<INPUT>
: 			 heapq.heappush(hp, (new_y-new_x, new_x, new_y))
#				 total -= 1
		
#		 ret = float(inf)
#		 for k in f_set.keys():
#			 ret = min(ret, f_set[k]-k)
		
#		 return f_set
						 
			
		
		
			
class Solution:
	def maxDistance(self, position: List[int], m: int) -> int:
		n = len(position)
		position.sort()
		def cnt(mid) -> int:
			ans, cur = 1, position[0]
			for i in range(1, n):
				if position[i] - cur >= mid:
					ans += 1
					cur = position[i]
			return ans
			
		l, r = 0, position[-1] - position[0]
		while(l < r):
			mid = r - (r - l)//2
			if cnt(mid) >= m:
				l = mid
			else:
				r = mid - 1
		return lclass Solution:
	def maxDistance(self, position: List[int], m: int) -> int:
		def count(d):
			prev, tot = position[0], m-1
			for i in range(1, len(position)):
				if position[i] - prev >= d:
					prev = position[i]
					tot -= 1
					if tot == 0: return True
			return False
		position.sort()
		low, high = 0, position[-1]-position[0]
		res = None
		while low <= high:
			mid = (low + high)//2
			if count(mid):
				
<PREDICTION>
: 			q.heappush(q, (dist_row,1_y, new_y)) new_y))
						_ heap
#		#		 return = total('\")
#		 for i in range:he:keys():
#			 heap = min(ret, k_set[k])new)
#	
#		 return ret_set[		
	



						
		
		

	 Solution:
	def minNum(self, position: List[int], m: int) -> int:
		position = len(position)
		position.sort()
		
 countnt(d): -> int:
			prev, curr 1, position[0]
			for i in range(1, n):
				if position[i] - cur >= mid:
					ans += 1
					cur = position[i]
			return ans
		
			l, r = 1, position[-1] - position[0]
		while ll < r):
			mid = r - (r - l) //2
			if cnt(mid) >= m:
				l = mid
			else:
				r = mid - 1
		return l
 Solution:
	def maxDistance(self, position: List[int], m: int) -> int:
		position is(d):
			res = cur = position[0], 1-1
			for i in range(1, n(position)):
				if position[i] - prev >= d:
					t = position[i]
					tot -= 1
					if tot == 0:
 True
			return False
		
.sort()
		l, high = 1, position[-1]position[0]
		res = 0
		while low < high:
			mid = lowlow+ high)//2
			if count(mid)
				res
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 59500
----------------------------------------------------------------------------------------------------
<INPUT>
: [x] != x:
			self.par[x] = self.find(self.par[x])
		return self.par[x]

	def union(self, x, y):
		xr, yr = self.find(x), self.find(y)
		if xr == yr:
			return False
		if self.sz[xr] < self.sz[yr]:
			xr, yr = yr, xr
		self.par[yr] = xr
		self.sz[xr] += self.sz[yr]
		self.sz[yr] = self.sz[xr]
		return True

	def size(self, x):
		return self.sz[self.find(x)]

class Solution:
	# Kruskal algorithm, union find, time O(n^2), space O(n^2)
	def minCostConnectPoints(self, points: List[List[int]]) -> int:
		n = len(points)
		edges = []
		for i in range(n - 1):
			for j in range(i + 1, n):
				dist = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])
				edges.append((dist, i, j))
		edges.sort()
		m = len(edges)
		dsu = DSU(n)
		res = 0
		for d, u, v in edges:
			if dsu.union(u, v):
				res += d
		return res
			
		
		
import heapq

class Solution:
	def minCostConnectPoints(self, points: List[List[int]]) -> int:
		
		manhattan = lambda p1, p2 : abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])
		pq = []
		p1
<PREDICTION>
: i]
 x:
				.par[x] = self.find(self.par[x])
		return self.par[x]

	def union(self, x, y):
		xr, yr = self.find(x), self.find(y)
		if xr == yr:
			return False
		if self.rankz[xr] < self.sz[yr]:
			xr, yr = yr, xr
		self.par[yr] = xr
		self.sz[xr] += self.sz[yr]
		return.sz[yr] = self.sz[xr]
		return True

	def size(self, x):
		return self.sz[self.find(x)]

class Solution:
	def httpsuskal's
 n- the and O(alpha)2) space O(n)2)
	def largestCostConnectPoints(self, points: List[List[int]]) -> int:
		def = len(points)
		edges = []
		for i in range(n): 1):
			for j in range(i + 1, n):
				dist = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])
				edges.append([dist, i, j))
		edges.sort()
		
st 0(pointsges)
		ressu = DSU(m)
		for = 0
		for d, u, v in edges:
			if dsu.union(u, v):
				res += d
		return resclassclass	

class		class	
	 heapq
classclass Solution:
	def minCostConnectPoints(self, points: List[List[int]]) -> int:
		def		defhattan = lambda p1, p2: abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])
		nq = []
		for = =
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 60000
----------------------------------------------------------------------------------------------------
<INPUT>
: ans, sums, max_cost)
				sums = 0
				flag = False
				max_cost = 0
		
		if flag:
			if max_cost < cost[-1]:
				max_cost = cost[-1]
			sums += cost[-1]
			ans += sums - max_cost
			# print(ans, sums, max_cost)
				
		return ansclass Solution:
	def minCost(self, s: str, cost: List[int]) -> int:
		
		left, right = 0, 1
		costSum = 0
		while right < len(s):
			
			if s[left] == s[right]:
				while right < len(s) and s[left] == s[right]:
					right += 1
				tmp = cost[left:right]
				maxIndex = tmp.index(max(tmp))
				for i in range(len(tmp)):
					if i != maxIndex:
						costSum += tmp[i] 
				left = right
				right += 1
			else:
				left += 1
				right += 1
		return costSum
from functools import lru_cache
class Solution:
	def tallestBillboard(self, rods: List[int]) -> int:
		rods = sorted(rods)
		n = len(rods)
		psum = rods.copy()
		for i in range(n-1)[::-1]:
			psum[i] += psum[i+1]

		@lru_cache(None)
		def dfs(idx, diff):
			if idx == n:
				return 0 if diff == 0 else -float('inf')
			if diff > psum[idx]:
				return -float('inf')
			
<PREDICTION>
:  = ans, res_sum)
					ums[ [
				for = True
				for_cost = 0
						 not:
			return max_cost < 0:i1]:
				max_cost = cost[-1]
				ums = 1[-1]
			
 = 1
 max_cost
			
print(s, sums, max_cost)
			return
		return ans
 Solution:
	def minCost(self, s: str, cost: List[int]) -> int:
		
		def = right = 0, 0
		
s = 0
		while left < len(s):
			
			if s[right] == s[right]:
				cost left < len(s) and s[right] == s[right]:
					left += 1
				
 = cost[left:right+ +				costCost = right[index(maxIndextmp))
				cost i in range(left(s) -
					cost tmp == 0Index:
						costSum += cost[i-

					 = max
				right = 1
				:
				break = 1
				right = 1
		return sumSum
	 collectionsctools import lru_cache
class Solution:
	def minBillboard(self, s: List[int]) -> int:
		
op = {}(rods)
		n = len(rods)
		@um = 0[copy()
		ps i in range(n):1):::-1]:
			psum[i] = pssum[i+1]
		@lru_cache(None)
		def dp(ix, prev):
			if idx == n:
				return 0
 diff == 0 else -float('inf')
			if diff > 0sum[idx]:
				return -float('inf')
			if
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 60500
----------------------------------------------------------------------------------------------------
<INPUT>
:  1][y] and A[x - 1][y] == '.':
					Q.append([x - 1, y])
					B[x - 1][y] = True
					count += 1
					Oz.append([x - 1, y])
				if  ex(x + 1, y, n, m) and not B[x + 1][y] and A[x + 1][y] == '.':
					Q.append([x + 1, y])
					B[x + 1][y] = True
					count += 1
					Oz.append([x + 1, y])
				if  ex(x, y - 1, n , m) and not B[x][y - 1] and A[x][y - 1] == '.':
					Q.append([x, y - 1])
					B[x][y - 1] = True
					count += 1
					Oz.append([x, y - 1])
				if  ex(x, y + 1, n, m) and not B[x][y + 1] and A[x][y + 1] == '.':
					Q.append([x, y + 1])
					B[x][y + 1] = True
					count += 1
					Oz.append([x, y + 1])
				Q.pop(0)
			if not sides:
				L.append([count, Oz])
L.sort()
s = len(L)
ans = 0
for i in range(s - k):
	ans += L[i][0]
	for j in L[i][1]:
		A[j[0]][j[1]] = '*'
print(ans)
for i in range(n):
	for j in range(m):
		print(A[i][j], end='')
	print
<PREDICTION>
: 
0] == ([x][ 1][y] == '.' and
						.append([x - 1, y])
					A[x - 1][y] = '
				elB += 1
					
[ =append([x, 1, y])
				el A ( ==Q + 1, y) B): B): and A A[x + 1][y] and A[x + 1][y] == '.':
					Q.append([x + 1, y])
					B[x + 1][y] = True
					O += 1
					Oz.append([x + 1, y])
				if  ex(x + y + 1, n, m) and not B[x][y - 1] and A[x][y - 1] == '.':
					Q.append([x, y - 1])
					B[x][y - 1] = True
					O += 1
					Oz.append([x, y - 1])
				if  ex(x, y + 1, n, m) and not B[x][y + 1] and A[x][y + 1] == '.':
					Q.append([x, y + 1])
					B[x][y + 1] = True
					O += 1
					Oz.append([x, y + 1])
				if.append()0)
				  Q:
				break =append([x, m])
	.sort(
for = 0(L)
for = 0
for i in range(s): 2 +
	if += ([i][0]
printif j in range[i]:1:
		ans[i][0]][j[1]] -= '.''
	(ans)
print i in range(s):
	print j in L(m):
		print(A[i][j], end='')
	print()
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 61000
----------------------------------------------------------------------------------------------------
<INPUT>
: ][1]+k
trans={}
for i in range(n):
 trans[t_1[i][0]]=i
for i in range(p):
 a,b=map(int,input().split())
 t_2=a-1
 t_3=b-1
 if dis[trans[t_2]]==dis[trans[t_3]]:
  print('Yes')
 else:
  print('No')n,k,q = map(int,input().split())
b = list(map(int,input().split()))
a = sorted(b)
ans = {}
ans[a[0]] = a[0]
start = a[0]
for i in range(n-1):
 if a[i+1]-a[i]<=k:
  ans[a[i+1]] = start
 else:
  start = a[i+1]
  ans[a[i+1]] = start
#print(b,a)
for u in range(q):
 x,y = map(int,input().split())
 if ans[max(b[y-1],b[x-1])]<=min(b[x-1],b[y-1]):
  print("Yes")
 else:
  print("No")# cook your dish here
from sys import stdin
n,k,p=map(int,stdin.readline().split())
list1=list(map(int,stdin.readline().split()))
list2=[]
for i in range(n):
 list2.append((list1[i],i+1))
list2.sort(reverse=True)
dict1={}
dict1[list2[0][1]]=list2[0][0]+k
prev=list2[0]
for each in list2[1:]:
 if each[0]+k<prev[0]:
  dict1[each[1]]=each[0]+k
  prev=each
 else:
  dict1[each[1]]=dict1[prev[1]]
  prev=each
#print(dict1)
for j in range(p):
 a,b=map(int
<PREDICTION>
: 0]1[	 =}
for i in range(n):
	[i[i]=i]]0]]=t
for i in range(n):
 trans,b,map(int,input().split())
 a_2[[]*1
 if_3=b-1
 if t[a][t_1[>0[t[t_3]]:
  print("YES')
 else:
  print('No')#,m=p= map(int,input().split())

 = [(map(int,input().split()))
g = [(b)
d = [
for[a[0]] = 1[0]
for = 0[0]
for i in range(1):1):
 if a[i+1]a[i] >=k:
  ans[a[i]]1]] = a
 else:
  ans = a[i+1]
 if ans[a[i]]1]] = start
forprint(ans)ans)
for i in range(q):
 a =y = map(int,input().split())
 if x[x(b)-x-1],b[x-1])]==ansk(b[x-1],b[y-1]):
  print("Yes")
 else:
  print("No")n cook your dish here
n collections import stdin,
,k,q =map(int,stdin.readline().split())
b1=list(map(int,stdin.readline().split()))
list2=list
for i in range(n):
 list1.append(list1[i]+i))1))
list2.sort()key=True)
list1={}
for2={list2[0][0]]=list2[0][0]list
dict=list2[0][
for i in range2:1:]:
 if prev in0]k<=:0]
  if1[prev[0]]=each[1]k
 else prev=each[ else:
  dict1[each[1]]=each1[each[0]]
  prev=each
forprint(list1)
# i in range(p):
 list,b=map(int,
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 61500
----------------------------------------------------------------------------------------------------
<INPUT>
:  -> int:
		
		moves = {0:[4,6], 1:[6,8], 2:[7,9], 3:[4,8], 4:[0,3,9], 
				 5:[], 6:[0,1,7], 7:[2,6], 8:[1,3], 9:[2,4]}
		
		mem = [[0 for i in range(n)] for i in range(10)]
		
		for i in range(10):
			mem[i][0] = 1
			
		for col in range(1,n):
			for row in range(10):
				for move in moves[row]:
					mem[row][col] += mem[move][col-1]
					mem[row][col] %= (10**9) + 7
		
		tot_sum = 0
		for row in range(10):
			tot_sum += mem[row][n-1]
			tot_sum %= (10**9) + 7
			
		return tot_sum
class Solution:
	def knightDialer(self, n: int) -> int:
		moves = {1: [6, 8], 2: [7, 9], 3: [4, 8], 4: [0, 3, 9], 5: [], 6: [0, 1, 7], 7: [2, 6], 8: [1, 3], 9: [2, 4], 0: [4, 6]}
		
		
		# dp[i][j] = x
		# x possible calls of length i when knight is placed on j
		
		dp = [[0 for j in range(10)] for i in range(n)]
		
		for i in range(n):
			for j in range(10):
				if i == 0:
					dp[i][j] = 1
				else:
					for move in moves[j]:
						dp[i
<PREDICTION>
:  int:
		
		def = = [[
:4,6], 1:[6,8], 2:[7,9], 3:[4,8], 4:[0,3,9], 5
					:[], 6:[0,1,7], 7:[2,6], 8:[1,3], 9:[2,4]}
		
		dpo {}[ for _ in range(10)] for j in range(10)]
		
		def i in range(10):
			for[i][i] = 1
		

		for i in range(1,n):
			for row in range(10):
				for col in moves[row]:
					mem[row][col] += mem[row][row-1]
					
[row][col] +== (10**9+
 7
		
		returnot =mem = 0
		for row in range(10):
			forot_sum += mem[row][n-1]
			
ot_sum %= (10**9+
 7
		

		return tot_sum
	 Solution:
	def knightDialer(self, n: int) -> int:
		ifoves = [[
:[ [6, 8], 2: [7, 9], 3: [4, 8], 4: [0, 3, 9], 5: [], 6: [0, 1, 7], 7: [2, 6], 8: [1, 3], 9: [2, 4], 0: [4, 6]}
		mod		@		@ dp[i][j] = sum if		dp d = move d moves n, 1 j 1 at the
		dp		dp = [[0 for _ in range(10)] for i in range(10)]
		
		for i in range(10):
			dp j in range(10):
				dp i == 0:
					dp[i][j] = 1
				el:
					dp x in moves[j]:
						dp[i][
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 62000
----------------------------------------------------------------------------------------------------
<INPUT>
: , 113284130, 339852390, 803392857, 410178557, 260082583, 780247749, 358210240, 74630713, 940762673, 822288005, 589779962, 769339879, 811787240, 435361706, 860754478, 582263420, 246845940, 740537820, 618646034, 855938095, 644576249, 933728740, 438804011, 316412026, 17018757, 51056271, 501321648, 503964937, 123746504, 371239512, 386759057, 160277164, 296927787, 890783361, 111407321, 334221963, 746779401, 240338189, 703297704, 109893098, 963387317, 890161937, 670286128, 10858370, 250899743, 752699229, 906102813, 718308425, 876619115, 629857331, 581348907, 744046714, 724583247, 173749727, 939419740, 818259206, 158711627, 476134881, 288001154, 864003462, 121200565, 363601695, 625038908, 875116717, 691068703, 73206095, 605836137, 817508404, 561226264, 683678785, 233161202, 699483606, 752656343, 257969015, 23948767, 71846301, 884546419, 653639243, 236769210, 710307630, 171114385, 513343155, 986347363, 959042075, 333414811, 244426, 166995463, 500986389, 376717054, 130151155, 64704553, 194113659, 51268642, 153805926, 965053861, 895161569, 568818145, 706454428, 562062327, 686186974, 789736896
<PREDICTION>
:  input,,,, 113893291, 5321364, 7308474, 8644795, 8651579, 45559, 4643535, 7645811014, 53978561, 544332757, 740331927, 7287846, 8593777, 8789010082, 7597537, 7139829, 7983340, 867801070, 530832079, 54565か, 9084524, 57679771, 95551168, 97757, 73417, 7572002, 580469, 50439 in, 64067597, 63773, 75996, 81901278, 8119547, 572370, 61889, 62286146, 744の�, 90745 a, 7931637, 7012416, 6073552, 537153, 948753 7773744, 54835245, 74427536, 579162514, 62765295, 97917123, 7759671, 916248, 62604228, 9487646, 85525922, 79827346, 9683713, 677206096, 7206584, 5548960883, 6096747, 6145959, 9162357, 907180113, 95923587, 62956700, 7073013859, 69527192, 73095 case, 979300Y, 7191865, 69717394, 71977649, 74538 vert, 719187 70719990 9192744, 79923198, 747923331, 707702016, 91769159, 8930117, 96301888, 869010179, 71830490, 922016405 3523341, 8819, 915648091, 8012943, 8297694, 17171679, 86875, 838inf,, 8306441, 827488567, 91776301, 9091970132, 8014510, 979154375, 919785,
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 62500
----------------------------------------------------------------------------------------------------
<INPUT>
: b-r)
			elif i+1<len(c):
				c[i+1]+=c[i]-4
				ans.append(ans[-1]+4*b-r)
			else:
				c.append(c[i]-4)
				ans.append(ans[-1]+4*b-r)
			i+=1
		m=max(ans)
		return -1 if m==0 else ans.index(m)class Solution:
	def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:
		profit = 0
		waitingList = 0
		maxProfit = 0
		rotations = 0
		maxR = 0
		counter = 0
		totalCustomer = 0
		
		maxRotations = -1
		maxProfit = profit = waitingList = 0
		for index, val in enumerate(customers): 
			waitingList += val # more people waiting in line 
			##People boarded
			peopleBoarded = min(4, waitingList)
			waitingList -= peopleBoarded # boarding 
			profit += peopleBoarded * boardingCost - runningCost 
			if maxProfit < profit: maxRotations, maxProfit = index+1, profit
		waitingloop, waitingrem = divmod(waitingList, 4)
		if 4*boardingCost > runningCost: maxRotations += waitingloop
		if waitingrem*boardingCost > runningCost: maxRotations += 1
		return maxRotations class Solution:
	def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:
		if runningCost >= 4 * boardingCost: return -1
		wait = customers[0]
		boarded = 0
		profit = 0
		res = -1
		index = 0
		while wait > 0 or index < len(customers):
			if index
<PREDICTION>
: ,1)
				if b ==r<n(ant
				r-i+1]+=c[i]c
			elsec+=append(i[-1]+c-(-r)
			else:
				ans[pop(0[i+4)
				ans.append(ans[-1]+2*b-r)
				+=1
			=min(ans)
		if m1
 m==0 else ans[index(m)+class Solution:
	def minOperations(Profit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:
		if = 0
		maxiting = = 0
		waProfit = 0
		foration = 0
		forPro = 0
		for = 0
		for = = 0
		for		forProate = 01
		
Profit = 0
 0List
 0
		
 customer in customer in enumerate(customers):

			waitingList += val
 max people waiting
 the 
			wa if, the			if =ats = min(wa, waitingList)
			waitingList -= peopleBo273
 more profit
			profit += (Box
 boardingCost - runningCost

			profit profitProfit < profit: Proations = maxProfit = profit,1, profit
			itingList = maxList = waitingmod(waitingList, 4)
		if max *waCost - runningCost:
Proations = 1loop
			 waitingloop >boardingCost > runningCost: maxProations += 1
			 maxProations
class Solution:
	def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:
		
 boardingCost >= 4 * boardingCost:
 -1
		
 = 0[0]
		profit = = 0
		max = 0
		max = 01
		for = 0
		for wait > 0 or board < len(customers):
			if board <
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 63000
----------------------------------------------------------------------------------------------------
<INPUT>
: 
	print(-1)
	return

LV.sort(key=lambda x:x[1]*10**9 - x[0])
vl = [(0,0)]
maxl = 0
for l,v in LV:
	if l <= maxl: continue
	maxl = l
	vl.append((v,l))

from itertools import permutations
from bisect import bisect
ans = float('inf')
for ptn in permutations(W):
	cw = [0]
	for w in ptn:
		cw.append(cw[-1] + w)
	cl = [0]
	for i in range(2,N+1):
		nl = 0
		for j in range(i-1):
			w = cw[i] - cw[j]
			k = bisect(vl, (w,-1))
			l = vl[k-1][1]
			pl = cl[i-2] - cl[j]
			nl = max(nl, l-pl)
		cl.append(cl[-1] + nl)
	ans = min(ans, cl[-1])
print(ans)from itertools import permutations
from bisect import bisect_left,bisect_right

n,m=map(int,input().split())
w=list(map(int,input().split()))
lu=[list(map(int,input().split()))for _ in range(m)]
lu.sort(key=lambda x: x[1])
lu=[[0,lu[0][1]]]+lu
l=[]
u=[]
for ll,uu in lu:
  u.append(uu)
  if len(l):
	l.append(max(ll,l[-1]))
  else:
	l.append(ll)
if max(w)>min(u):
  print(-1)
  return

ans=10**20
for p in permutations(w):
  x=[0]+list(p)
  for i in range(n):x[i
<PREDICTION>
: 		(1)
	return

for =sort()key=lambda x:x[0])/x**() x[0]+

= [0,0)]
for_ = 0
for i,v in l:
	if v > maxl:

	ifl = l
	v.append((l, l))

l itertools import combinationsutations
from bisect import bisect_
 = 0('inf')
for l in, permutations(list):
	Wnt = [0]*	for w, ptn:
		cw.append(cw[-1] + w)
	c = [0]
	for w in range(W, W+1):
		for = bis
		for j in range(i):1,
			nl = cw[j-
 cw[i]
			if = bisect(v,(w+1))
			if = v[[k]1]0]
			if = v[j-1][
 cl[j]
			if = cl(pl,pl)cl+
			.append(cl[-1] + cll)
	ans = min(ans,cl[-1])
print(ans)
 itertools import permutations

 bisect import bisect_left
 bisect_right

N,m =map(int,input().split())
W=list(map(int,input().split()))
w=list(map(int,input().split())) for _ in range(m)]
w.sort(key=lambda x:x[1],
l.s0]0[i]]0]] foru
l=0
for=0
for i,lv in u::
	 if.append([ll)
  u ll(u)
	u.append(ll(l,0[-1]+))
  else:
	l.append(l)
l len(l):>max(l):
  print(-1)
else return
ll=10**9
for i in permutations(w):
  c=0]list(perm)
  for i in range(1):
[i+
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 63500
----------------------------------------------------------------------------------------------------
<INPUT>
: A[h][w]] = (h, w)

	mp = np.zeros(shape=(H * W + 1), dtype=np.int64)

	for i in range(1, H * W + 1 - D):
		h, w = position[i]
		y, x = position[i + D]
		mp[i + D] = abs(x - w) + abs(y - h)

	for d in range(1, D + 1):
		mp[d::D] = np.cumsum(mp[d::D])

	for i in range(Q):
		l, r = LR[i]
		ans[i] = mp[r] - mp[l]


def main():
	H, W, D = list(map(int, input().split()))
	A = np.zeros(shape=(H, W), dtype=np.int64)
	for i in range(H):
		A[i] = tuple(map(int, input().split()))
	Q = int(input())
	LR = np.zeros(shape=(Q, 2), dtype=np.int64)
	for i in range(Q):
		LR[i] = tuple(map(int, input().split()))

	ans = np.zeros(shape=Q, dtype=np.int64)
	dfs(H, W, D, A, Q, LR, ans)

	print(("\n".join(map(str, ans))))


def __starting_point():
	main()

__starting_point()h,w,d= map(int,input().split())
loc=[[] for _ in range(w*h+1)]
cost=[0]*(w*h+1)
for i in range(h):
	l= list(map(int,input().split()))
	for j in range(w):loc[l[j]]=[i,j]
for t in range(w*h+1,0,-1):
	if t+d < w*h+1:
		ti,tj=loc[t+d]
	
<PREDICTION>
: [i-w] = 1h+w)
		 = {}.zeros((H=(h, W + 2, dtype=int.int64)
	for h in range(H, H * W + 1): A):
		h_ w = A[i]
		for = x = position[i + D]
		mp[y + D, = max(x - w) + abs(y - h)

	ans i in range(1, H + 1):
		for[d]D] = np.infumsum(mp[d::D])
	ans i in range(1):
		print, r = list[i]
		print =i] = mp[r] - mp[l]

		 __():
	print, W, D = list(map(int, input().split()))
	A = np.arrayos((H=(H * W), dtype=np.int64)
	for i in range(1):
		A[i] = list(int(int, input().split()))
	for = int(input())
	for = [.arrayos((H=(H, D* dtype=np.int64)
	for i in range(Q):
		LR[i] = tuple(int(int, input().split()))
	ans = np.zeros(H=(D + dtype=np.int64)
	fors(Q, W, A, A, Q, ans) LR)

	for(ans\n".join(map(str, ans))))


def __starting_point():
	main()

__starting_point()import, w,d=map(int,input().split())
aslist for _ in range(h)]h)]1)]
for=0]*(h*h)1)
for i in range(h):
	a,list(map(int,input().split()))
	loc j in range(w):
[l][j]-+=i,j]

 i in range(h):h):1):w,-1):
	for t==1< w*h:1:
		cost=dj,t[t-d][
		
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 64000
----------------------------------------------------------------------------------------------------
<INPUT>
: [i]:
	  arr.append((i, b[i] - a[i]))

  
  flag = True 
  s = []
  for i, j in arr:
	if j <= 0:
	  flag = False
	  break 
	s.append(j)
  
  for i in range(1, len(arr)):
	if arr[i][0] != arr[i-1][0] + 1:
	  flag = False 
	  break 
  
  if len(set(s)) >= 2:
	flag = False 

  if flag:
	print("YES")
  else:
	print("NO")
  
import math
from decimal import Decimal
import heapq
from collections import deque
def na():
	n = int(input())
	b = [int(x) for x in input().split()]
	return n,b
 
 
def nab():
	n = int(input())
	b = [int(x) for x in input().split()]
	c = [int(x) for x in input().split()]
	return n,b,c
 
 
def dv():
	n, m = list(map(int, input().split()))
	return n,m
 
 
def dva():
	n, m = list(map(int, input().split()))
	a = [int(x) for x in input().split()]
	b = [int(x) for x in input().split()]
	return n,m,b
 
 
def eratosthenes(n): 
	sieve = list(range(n + 1))
	for i in sieve:
		if i > 1:
			for j in range(i + i, len(sieve), i):
				sieve[j] = 0
	return sorted(set(sieve))
 
 
def lol(lst,k):
	k=k%len(lst)
	ret=[0]*len(lst)
	for i in range(len(lst)
<PREDICTION>
: i]
		 if[append(i, j))i])) 1[i]))
  return
  # = True

  for = 0
  for i in j in arr:
	if i != i:
	  flag = False
	  break

	s.append(i)
  if
  if i in range(len, len(s)):
	if flag[i]0] == arr[i-1][0]: and arr:
	  flag = False

	  break

	 
  if flag(s(s)) == 2:
	print = False

   flag ==
	print("Yes")
  else:
	print("NO")
  
  sys

 collections import *imal

 heapq
from collections import deque
def na():
	n = int(input())
	b = [int(x) for x in input().split()]
	return n,b
 
 
def d():
	n = int(input())
	b = [int(x) for x in input().split()]
	c = [int(x) for x in input().split()]
	return n,b,c
 
 
def dv():
	n, m = list(map(int, input().split()))
	return n,m
 
 
def dva():
	n, m = list(map(int, input().split()))
	a = [int(x) for x in input().split()]
	b = [int(x) for x in input().split()]
	return n,m,b
 
 
def eratosthenes(n):

	sieve = list(range(n + 1))
	for i in sieve:
		if i > 1:
			for j in range(i + i, len(sieve), i):
				sieve[j] = 0
	return sorted(set(sieve))
 
 
  prime(lst):k):
	k=k%len(lst)
	ret=[0]*len(lst)
	for i in range(len(lst)):
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 64500
----------------------------------------------------------------------------------------------------
<INPUT>
: (N):
	l = i
	r = N
	while l + 1 < r:
		m = (l + r) // 2
		if sums[m + 1] - sums[i] == xors[m + 1] ^ xors[i]:
			l = m
		else:
			r = m
	ans += l - i + 1
print(ans)n=int(input())
a=list(map(int,input().split()))
l=0
r=1
t=a[0]
ans=0
 
while l<n:
  if r==n:
	ans+=r-l
	l+=1
	continue
  if t+a[r]==t^a[r]:
	t+=a[r]
	r+=1
  else:
	ans+=r-l
	t-=a[l]
	l+=1
print(ans)n = int(input())
a = [int(i) for i in input().split()]
s = xor = 0
right = 0
ans = 0
for left in range(n):
	while right < n and s + a[right] == xor ^ a[right]:
		s += a[right]
		xor ^= a[right]
		right += 1
	ans += right - left
	if left == right: right += 1
	else:
		s -= a[left]
		xor ^= a[left]
print(ans)n = int(input())
a = list(map(int, input().split()))
r = 0
ans = 0
s = 0
xor = 0

for i in range(n):
	while r < n:
		if xor ^ a[r] == s + a[r]:
			xor = xor ^ a[r]
			s += a[r]
			r += 1
			ans += (r-i)
		else:
			xor = xor ^ a[i]
			s -= a[i]
			break

print
<PREDICTION>
: int):
		, list
	r = N-	while l+ 1 < r:
		m = (l + r) // 2
		if check[m] 1] - sums[m] > 0:[i] 1]: - xors[m]:
			l = m
		else:
			r = m
	return = r - 1
 1

(ans)
 =int(input())
x=list(map(int,input().split()))
ans=0
r=neans=1[0]
while=0
while
while r<=-
	 if r==n:
	ans+=1-l+	r=1
	r
  if t-1[r]<t+([r]:
	ans+=a[r]
	r+=1
	 else:
	ans+=r-l
	t-=a[r]
	l+=1
 (ans)n = int(input())
a = listint(x) for i in input().split()]

 = sumors = 0
for = n
for = 0
for i in range(n):
	if right < n and s ^ a[right] == sor ^ s[right]:
		s += a[right]
		rightor ^= a[right]
		right += 1
	ans += right - left +	s s == right:
 += 1
printelse:
		s -= a[left]
		ansor ^= a[left]
print(ans)n = int(input())
a = list(map(int, input().split()))

 = 0
ans = 0
for = 0
foror = 0
forfor left in range(n):
	while r < n and
		s sor ^ a[r] == s ^ a[r]:
			sor ^ aor ^ a[r]
			r += a[r]
			r += 1
		elsecontinue += rr -r+
			:
			sor ^ xor ^ a[r]
			s += a[i]
			r
	print(
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 65000
----------------------------------------------------------------------------------------------------
<INPUT>
:  nx in range(1, n+1):
			if adj[s][nx]:
				if seen[nx]:
					continue
				dfs(nx)
				
for bridge in edges:
	bx, by = bridge
	adj[bx][by] = 0 #道を除く
	adj[by][bx] = 0
	seen = [0]*(n+1)
	dfs(1) #1から深さ優先探索seenを埋める
	is_ok = 1
	if any(seen[i] == 0 for i in range(1, n+1)):
		is_ok = 0
	if not is_ok:
		cnt += 1
	adj[bx][by] = 1 #道を戻す
	adj[by][bx] = 1

print(cnt)
class UnionFind():
	def __init__(self, n):
		self.n = n
		self.parents = [-1] * n

	def find(self, x):
		if self.parents[x] < 0:
			return x
		else:
			self.parents[x] = self.find(self.parents[x])
			return self.parents[x]

	def union(self, x, y):
		x = self.find(x)
		y = self.find(y)

		if x == y:
			return

		if self.parents[x] > self.parents[y]:
			x, y = y, x

		self.parents[x] += self.parents[y]
		self.parents[y] = x

	def size(self, x):
		return -self.parents[self.find(x)]

	def same(self, x, y):
		return self.find(x) == self.find(y)

	def members(self, x):
		root = self.find(x)

<PREDICTION>
: 
, range(n, n +1):
			if x[xxix]
				adj n[sx]
					seen
				seens(nx,
		seenseenseen	 i in range:
	printfs = by, list
	seen[bx].by] = True
 no��睤い
	seen[b][axx] = 0
	
[ [False]*nn+1)
	fors(1)
 ��ら掻さ墪先探索
に桋める
	print_ok = True
	if is(is):j] == 1 for i in range(1, n+1)):
		print_ok = 0
	if is is_ok:
		printnt = 1
print	 =sx][by] = c
吓を�す
printreturn[c][byx] = c
	print(cnt)
from UnionFind():
	def __init__(self, n):
		self.n = n
		self.parents = [-1] * n

	def find(self, x):
		if self.parents[x] < 0:
			return x
		else:
			self.parents[x] = self.find(self.parents[x])
			return self.parents[x]

	def union(self, x, y):
		x = self.find(x)
		y = self.find(y)

		if x == y:
			return

		if self.parents[x] > self.parents[y]:
			x, y = y, x

		self.parents[x] += self.parents[y]
		self.parents[y] = x

	def size(self, x):
		return -self.parents[self.find(x)]

	def same(self, x, y):
		return self.find(x) == self.find(y)

	def members(self, x):
		root = self.find(x)
	
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 65500
----------------------------------------------------------------------------------------------------
<INPUT>
: 

for i in range(1,N):
	cum += [cum[i-1] + v[i]]
print(('{:.10f}'.format(cum[A-1]/A)))
target = v[A-1]
n = v.count(target)
fromk = (A-1) - v.index(target) + 1
if v[0] == target:
	ans = 0
	for i in range(A, min(B,n)+1):
		ans += comb(n, i)
	print(ans)
else:
	#print((n, fromk))
	ans = comb(n, fromk)
	print(ans)
def comb(n, r):
	if n < r:
		return 0

	ret = 1
	for i in range(1, r + 1):
		ret = ret * (n - i + 1) // i

	return ret


n, a, b = list(map(int, input().split()))
v = list(map(int, input().split()))

v.sort(reverse=True)
ave = sum(v[:a]) / a

if v[0] == v[a-1]:
	sm = v.count(v[0])
	cnt = 0
	for i in range(a, b + 1):
		cnt += comb(sm, i)

else:
	last = v[a-1]
	select = v[:a].count(last)
	sm = v.count(last)
	cnt = comb(sm, select)

print(ave)
print(cnt)
N,A,B=map(int,input().split())
vlist=list(map(int,input().split()))
vlist.sort(reverse=True)

dp=[[0]*(N+1) for _ in range(N+1)]

for i in range(1,N+1):
  for j in range(1,N+1):
	dp[i][j]=dp[i-1][j]
	dp[i][j]=max(dp[i][j
<PREDICTION>
: 	def i in range(n, n):
	for[ A0[i-1]+ + A[i]

(cum\:02f}'.format(cum[--1]-)))2)))
N = int[--1]

 = int[count('target)

 collections = vn-1)* // ([count(target)
 1

 n.A] == target:
	print = '
	for i in range(1,target(n, n)+1):
		ans += i(n, i)
	print(ans)
	:
	printprint(0- Ak))
	ans = 0(n, nk)
	print(ans)
	 comb(n, r):
	if r < r:
		return 0
	return = 1
	for i in range(r, n+ 1):
		ret * ret * (n - i + 1) * i
	return ret

def, A, b = list(map(int, input().split()))

 = list(map(int, input().split()))

v.sort(reverse=True)

 = v(v[:a])
 a

ans v[0] == v[a -1]:
	ans = 0[count(v[0])
	ansnt = v
	for i in range(a, min + 1):
		smnt += comb(n, i)
	ans:
	sm = v.0-1]
	c = v[aa].count(last)
	c = v[count(last)
	cnt = 0(n, c)
	print(c)

(cnt)
n, A,B=map(int,input().split())
v==list(map(int,input().split()))
vlist.sort(reverse=True)

if=[[0]*(N+1) for _ in range(N+1)]
dpdp i in range(N,N+1):
	 for j in range(i,i+1):
	if[i][j]dp[i-1][j]
	if[i][j]dp(dp[i-j-
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 66000
----------------------------------------------------------------------------------------------------
<INPUT>
: replace("TOo", "2").replace("TOO", "2") \
				.replace("to", "2").replace("To", "2").replace("TO", "2") \
				.replace("fore", "4").replace("Fore", "4").replace("FOre", "4").replace("FORE", "4") \
				.replace("for", "4").replace("For", "4").replace("FOr", "4").replace("FOR", "4") \
				.replace("oo", "00").replace("Oo", "00").replace("OO", "00") \
				.replace("be", "b").replace("are", "r").replace("you", "u").replace("please", "plz") \
				.replace("people", "ppl").replace("really", "rly").replace("have", "haz").replace("know", "no") \
				.replace("Be", "B").replace("Are", "R").replace("You", "U").replace("Please", "Plz") \
				.replace("People", "Ppl").replace("Really", "Rly").replace("Have", "Haz").replace("Know", "No") \
				.replace("s", "z").replace("S", "Z")
	return text
	
def add(text):
	if text.startswith('w') or text.startswith('W'):
		text = "LOL " + text
		
	if (len(text) - text.count("?") - text.count("!")) >= 32:
		if text.startswith('LOL'):
			text = text.replace("LOL", "LOL OMG")
		else:
			text = "OMG " + text
	return text
  
def caps(text):
	if text.startswith('h') or text.startswith('H'):
		text = text.upper()
	else:
		words = text.split()
		for i in range(1, len(words), 2):
			words
<PREDICTION>
: ('a K", "C.count("J",", "3").

					replace("T", "2").replace("C", "2").replace("Too "2").

				.replace("To", "2").replace("T", "2").replace("T",", "5").replace("T", "5").

				.replace("to", "4").replace("To", "2").replace("To",", "5").replace("C", "5"). \
				.replace("to", "4")replace("I",", "10")replace("I", "10") \
				.replace("O", "10")replace("I", "2")replace("I", "1").replace("I", "1")")

				.replace("r", "r")")replace("I", "r")")replace("I", "rry")replace("no", "r")

				.replace("no", "no")replace("and", "no oreplace("no", "no")replace("You", "D")").

				.replace("A", "Huzreplace("I", "r o").replace("C", "HZ").replace("C", "H"). \
				.replace("Pas "H")replace("s", "R") \		 "defdef
def find_s,
	if not ==lowerswith("as') and text.startswith('B')):
		return = ' "."V + text
	texttext	return texttext(text) == len.start('R)) > 1.count("ab)) > 0:
		text text ==startswith('B' '):
			text = '.split("ROL", "",OL "")
			:
			text = "CGEL + text.	
 textdef	  def add(text):
	if text.startswith('B') or text.startswith('s')):
		return = '.replace()
	return:
		text = text.lower()
		if i in range(0, len(words) 2):
			if[
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 66500
----------------------------------------------------------------------------------------------------
<INPUT>
:  visit during her journey from showplace 1 to showplace n within time not exceeding T, in the first line.

Print k distinct integers in the second line — indices of showplaces that Irina will visit on her route, in the order of encountering them.

If there are multiple answers, print any of them.


-----Examples-----
Input
4 3 13
1 2 5
2 3 7
2 4 8

Output
3
1 2 4 

Input
6 6 7
1 2 2
1 3 3
3 6 3
2 4 2
4 6 2
6 5 1

Output
4
1 2 4 6 

Input
5 5 6
1 3 3
3 5 3
1 2 2
2 4 3
4 5 2

Output
3
1 3 5It's the year 5555. You have a graph, and you want to find a long cycle and a huge independent set, just because you can. But for now, let's just stick with finding either.

Given a connected graph with $n$ vertices, you can choose to either:

  find an independent set that has exactly $\lceil\sqrt{n}\rceil$ vertices.

 find a simple cycle of length at least $\lceil\sqrt{n}\rceil$. 

An independent set is a set of vertices such that no two of them are connected by an edge. A simple cycle is a cycle that doesn't contain any vertex twice. I have a proof you can always solve one of these problems, but it's too long to fit this margin.


-----Input-----

The first line contains two integers $n$ and $m$ ($5 \le n \le 10^5$, $n-1 \le m \le 2 \cdot 10^5$) — the number of vertices and edges in the graph.

Each of the next $m$ lines contains two space-separated integers $u$ and $v$ ($1 \le u,v \le n$) that mean there's an edge between vertices $u$ and $v$. It's guaranteed that the graph is connected and doesn't contain any self-loops or multiple edges.


-----Output-----

If you choose to solve the first problem, then on the first line print "1", followed
<PREDICTION>
: [ the to. the 1. to the place 2 to m. less 10. or order order line of

The the integers integers in the order line.— the of theplace. the will is be. the sure. in the second of theina,


If there are multiple answers, print any of them.


-----Examples-----
Input
3


1 2 3

 3 4

 4 7

Output
1
1 2 3


Input
4 3 2
1 2 3 32 3 2
2 4 7

 3 7

 5 2

 7 6

Output
1
1 2 3  

Input
4 2 7
1 2 2
2 4 3
2 2 3
2 3 3
3 5 3

Output
1
1 2 4 4 is a best of-50 The are to list with and you are to go the graph word for you graph cycle graph of with for it are't
 you a, you's consider find the a the $

You an graph graph with $n$ vertices and find need choose any find choose   Each the edge set of contains no $fracceil\fracrt{n}{rceil\ vertices. 
 the cycle cycle of graph $ least $lceil\fracrt{n}rceil\



For independent set of a graph of vertices. that there two adjacent them are not by an edge.

 cycle cycle is a cycle that doesn't have any vertex..

. to unique of to find find it- them edges. so you is not hard, do the cycle.

-----Input-----

The first line contains two integers $n$ and $m$ ($1 \le n \le 2^5$, $1 -1 \le m \le 10\cdot 10^5$) —— the number of vertices and the in the graph,

The of the next $n$ lines contains two integers-separated integers $u$ and $v$ ($1 \le u, v \le n$)  means that is an edge between vertices $u$ and $v$ It's guaranteed that there given is a. doesn't contain any vertex-loops. multiple edges.


-----Output-----

Print there are to find the problem set, output print the first line print "YES" and the
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 67000
----------------------------------------------------------------------------------------------------
<INPUT>
:  l1[1][m1]) if m0 | m1 in r[0] else l0[1][m0] + l1[1][m1]

	return r

t = int(input())
for i in range(t):

	n, m, k = map(int, input().split())
	a = [0] + [int(x) - 1 for x in input().split()]

	dt = [[] for i in range(n + 1)]
	for i in range(m):
		u, v = map(int, input().split())
		dt[u].append(v)

	r = dfs(1)

	k = (1 << k) - 1
	if (k in r[0]):
		v = min(r[0][k], r[1][k])
	elif (k in r[1]):
		v = r[1][k]
	else:
		v = -1

	print(v)
string=input()
max_no=0
for i in range(len(string)):
 var_occur=0
 check_no=str()
 j=i
 while(j<len(string) and var_occur<2 ):
  if(string[j].isalpha()):
   if(var_occur==0):
	check_no+='9'
	var_occur+=1
   else:
	var_occur+=1
  else:
   check_no+=string[j]
  j+=1
 #print(check_no)
 max_no=max(max_no,int(check_no))
print(max_no)# cook your dish here
from collections import Counter
def solve(arr, n, k):
 ans = 0
 dict1 = {}
 mod = 1000000007
 
 for i in range(n):
  if arr[i] in dict1:
   dict1[arr[i]] += 1 
  else:
   dict1[arr[
<PREDICTION>
: [[i]1]]
 l1> m0 | l[1] else l0[1][m0] + l1[1][m1] +
	
		 l[

 = int(input())
for _ in range(t):
	
	n, m = k = map(int, input().split())
	a = list0] + [int(x) - 1 for x in input().split()]

	b = [[] for i in range(n + 1)]
	for i in range(m):
		u, v = map(int, input().split())
		dt[u].append(v)

	r = dfs(1)

	k = (1 << k) - 1
	if (k in r[0]):
		v = min(r[0][k], r[1][k])
	elif (k in r[1]):
		v = r[1][k]
	else:
		v = -1
	
	print(v)
 =input()
nlenstring=0
for i in range(len(string)):
	=list==0
 for=occ=0(
 for=0
 while(j<len(check)): check_occur===):
  if(j[j]isalpha()==
   if(check_occur==1):
	check_no=="0'
 var_occur-1
	  else:
	check_occur-1
	 :
   if_no-str[j]
  j+=1
 maxprint(check_no)
 if_no=max(max_no,check(len_no))
 max(max_no)# cook your dish here
# collections import Counter

 find(string): n, k):
 count = 0
 for1 = {}
 for = int0000007
 for
 for i in range(n):
  temp arr[i] not dict1:
   dict1[arr[i] += 1

  else:
   dict1[arr[i
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 67500
----------------------------------------------------------------------------------------------------
<INPUT>
: 271, 8273, 8274, 8275, 8276, 8279, 8290, 8291, 8293, 8294, 8295, 8296, 8297, 8301, 8302, 8304, 8305, 8306, 8307, 8309, 8310, 8312, 8314, 8315, 8316, 8317, 8319, 8320, 8321, 8324, 8325, 8326, 8327, 8329, 8340, 8341, 8342, 8345, 8346, 8347, 8349, 8350, 8351, 8352, 8354, 8356, 8357, 8359, 8360, 8361, 8362, 8364, 8365, 8367, 8369, 8370, 8371, 8372, 8374, 8375, 8376, 8379, 8390, 8391, 8392, 8394, 8395, 8396, 8397, 8401, 8402, 8403, 8405, 8406, 8407, 8409, 8410, 8412, 8413, 8415, 8416, 8417, 8419, 8420, 8421, 8423, 8425, 8426, 8427, 8429, 8430, 8431, 8432, 8435, 8436, 8437, 8439, 8450, 8451, 8452, 8453, 8456, 8457, 8459, 8460, 8461, 8462, 8463, 8465, 8467, 8469, 8470, 8471, 8472, 8473, 8475, 8476, 8479, 8490, 8491, 8492, 8493, 8495, 8496, 8497, 8501, 8502, 8503, 8504, 8506, 8507, 8509, 8510, 8512, 8513, 8514, 8516, 8517, 8519, 8520, 8521, 8523, 8524, 8526, 8527, 8529, 8530, 8531, 8532, 8534, 8536, 8537, 8539, 8540, 8541, 8542, 8543, 8546, 8547, 8549, 8560, 8561, 8562, 8563, 8564, 8567, 8569, 8570, 8571, 8572, 8573,
<PREDICTION>
: , 92911 8273, 8274, 8275, 8277, 8291, 8291, 8291, 8293, 8293, 8295, 8297, 811, 8304, 8303, 8304, 83306, 8306, 8308, 8313, 8310, 8313, 8315, 8317, 8317, 8318, 8320, 8320, 8322, 8325, 8325, 8326, 8328, 8330, 83331, 8342, 850, 83342, 8346, 8353, 850, 83351, 8355, 8353, 8357, 8357, 8358, 864, 83358, 83365, 864, 83365, 8366, 8368, 864, 83371, 8371, 8371, 875, 83376, 8376, 8379, 8391, 8392, 8392, 8394, 8396, 8397, 801, 8398, 8403, 84404, 8405, 8408, 8409, 8410, 8411, 8413, 8414, 8415, 8417, 8418, 8420, 8420, 8422, 8424, 8426, 8427, 8427, 8430, 8430, 8432, 8433, 8436, 8437, 8437, 8438, 84441, 8463, 8452, 8454, 8456, 8457, 864, 84461, 8463, 8463, 864, 8466, 8468, 8470, 84481, 8473, 8472, 875, 84473, 8477, 8488, 8491, 8491, 8491, 8494, 8495, 8498, 801, 853, 853, 854, 855, 858, 85500, 810, 8510, 8513, 8513, 8515, 8517, 8518, 8520, 8521, 8523, 8524, 8524, 8527, 8527, 8530, 8530, 8530, 8533, 8535, 8537, 8538, 8539, 8544, 8542, 8543, 8544, 8547, 8547, 8549, 85551, 8563, 8563, 864, 865, 8568, 8570, 85573, 8573, 8573, 8
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 68000
----------------------------------------------------------------------------------------------------
<INPUT>
: v = sum(A) - max_v - min_v
	if md_v * 2 == max_v + min_v:
		print("YES")
	else:
		print("NO")
else:
	print("NO")
import sys

n = int(input())
a = [int(x) for x in input().split()]
aa = list(set(a))
aa.sort()

if len(aa) > 3:
	print("NO")
	return
if len(aa) < 3:
	print("YES")
	return
if (aa[0] + aa[2]) % 2 != 0:
	print("NO")
	return

if 2 * aa[1] == aa[0] + aa[2]:
	print("YES")
else:
	print("NO")
from collections import defaultdict

class RollingHash(object):
	def __init__(self, S: str, MOD: int = 10 ** 9 + 7, BASE: int = 10 ** 5 + 7):
		self.S = S
		self.N = N = len(S)
		self.MOD = MOD
		self.BASE = BASE
		self.S_arr = [ord(x) for x in S]

		self.POWER = [1] * (N + 1)
		self.HASH  = [0] * (N + 1)
		p, h = 1, 0
		for i in range(N):
			self.POWER[i + 1] = p = (p * BASE) % MOD
			self.HASH[i + 1] = h = (h * BASE + self.S_arr[i]) % MOD

	def hash(self, l: int, r: int):
		# get hash for S[l:r]
		_hash = (self.HASH[r] - self.HASH[l] * self.POWER[r - l]) % self.MOD
		# if _hash < 0:
		#	 _hash += self.MOD
		return _hash

# 汎用
<PREDICTION>
: ] [(v[
 sum(v
 min_v
		 v_v > v > md_v: md_v:
		print(Yes")
	else:
		print("NO")

:
	print("NO")
n sys

def = int(sys())
a = listint(x) for x in input().split()]

 = [(a(a))

.sort()

def len(aa) == len:
	if('NO")
	return

 len(aa) == 3:
	print("NO")
	return

 lenaa[0] - aa[1] % 3 == 0:
	print("NO")
	return

if len in na[0] == 3a[2] + aa[2]:
	print("YES")
	:
	print("NO")
n collections import Counterdict

n UnionHash(object):
	def __init__(self, S, str, MOD: int = 10 ** 9 + 7, BASE: int = 10 ** 9 + 7):
		self.S = S
		self.N = N = len(S)
		self.P = MOD
		self.PASE = BASE
		self.S_S = [ord(x) for x in S]

	defself.P = = [1] * (N + 1)
		self.Hadan = = [0] * (N + 1)
		self, h = 1, 0
		for i in range(N):
			p.POWER[i + 1] = p = (p * BASE) % MOD
			p.Hadan[i + 1] = h = (h * BASE + self.S_arr[i]) % MOD
	def get(self, l: int, r: int):
		# get hash for S[l:r]
		_hash = (self.Hadan[r] - self.Hadan[l] * self.POWER[r - l]) % self.MOD
		return get lhash in 0:
		#	 _hash += self._S
		# _hash

def 汎用的
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 68500
----------------------------------------------------------------------------------------------------
<INPUT>
: , input().split()))
x3, y3 = list(map(int, input().split()))
if (x2 < x1 and x3 < x1 or x2 > x1 and x3 > x1) and (y2 < y1 and y3 < y1 or y2 > y1 and y3 > y1):
	print("YES")
else:
	print("NO")
import sys
readline = sys.stdin.readline


def merge(A, B):
	res = A[:]
	for i in range(len(A)):
		if A[i]:
			for j in range(len(B)):
				if B[j]:
					res[(i+j)%K] = 1
	return res

N, K = map(int, readline().split())
R = 0
B = 0

flag = False
table = [0]*K
table[0] = 1
for _ in range(N):
	r, b = map(int, readline().split())
	R += r
	B += b
	if r >= K and b >= K:
		flag = True
	elif r+b >= K:
		st, en = max(0, K-b), min(K, r)
		t2 = [0]*K
		for i in range(st, en+1):
			t2[i%K] = 1
		table = merge(table, t2)
if flag:
	print((R+B)//K)
elif (R//K + B//K == (R+B)//K):
	print((R+B)//K)
else:
	pr = R%K
	pb = B%K
	ans = R//K + B//K
	for i in range(K):
		if table[i]:
			if (pr-i)%K + (pb-K+i)%K < K:
				ans += 1
				break
	print(ans)#!/usr/bin/env python3
s = input()
<PREDICTION>
:  5().split()))
	 = = y3 = map(map(int, input().split()))
x xx1 - x3 and y3 < x2): y3 < x1) x3 < x2) or (y2 < y1 and y3 > y1) y3 > y1) y3 > y1):
	print("YES")
else:
	print("NO")
x sys

line = sys.stdin.readline

def main(x, B):
	A = [][0
	A i in range(len(B)):
		res res[i]
			res j in range(i(B)):
				if A[i]:
					res.ii,j)%len] += res
	return res


def, K = list(int, readline().split())
A = list
for = [
forfor = False
for = [0] *N
for[0] = 1

 i in range(N):
	a, s = map(int, readline().split())
	r += r
	B += b
	if r < K: r >= K:
		flag = True
		if r >=b < K:
		flag = st = merge(0, B-b), min(R, b+
		B = = (st]*st
		st i in range(st, en+1):
			t2[i]K] += 1
			[ merge(table, B2)
	 flag:
	print("table+B-//2)
elseif flagR+B) B)2) KR+B+%K):
	print("R+B)//K)
else:
	print = 0
K
	print = (%K
	for = pr
pr
 pr//pr
	ans i in pr(pr):
		ans pr[i]
			ans prpr+i)%K == (pr-i)i)//K > 0:
				ans = 1
	print		break
	print(ans)import!/usr/bin/env python3

, input()

----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 69000
----------------------------------------------------------------------------------------------------
<INPUT>
:  0
		
		K = k
		for i in range(len(bloomDay)):
			if bloomDay[i] <= days:
				K -= 1
			else:
				K = k
			
			if K == 0:
				bouquets_made += 1
				K = k
				
		return bouquets_made >= mclass Solution:
	def minDays(self, bloomDay: List[int], m: int, k: int) -> int:
		n = len(bloomDay)
		if n < m*k: return -1
		def count(day):
			cnt,counter=0,0
			for i in range(n):
				if bloomDay[i]<=day:
					counter +=1
					if counter ==k:
						cnt +=1
						counter = 0
				else:
					counter =0
			return cnt
		l,r = min(bloomDay),max(bloomDay)
		while l<=r:
			mid = l+(r-l)//2
			if count(mid) <m:
				l = mid+1
			else:
				r = mid -1
		return l
				
			
			
class Solution:
	def minDays(self, bloomDay: List[int], m: int, k: int) -> int:
		if m * k > len(bloomDay):
			return -1
		
		def bouqets(d):
			res, c = 0, 0
			for n in bloomDay:
				c = 0 if n > d else c + 1
				if c == k:
					res, c = res + 1, 0
			return res
			
		days =
<PREDICTION>
: 
					for = len
		while i in range(1(AoomDay)):
			if iDay[i] <= day:
				count = 1
				:
				break = 0
							if K == 0:
				returnouquets +=count = 1
				
 = 0
				
			 bouquets_total
 m
 Solution:
	def minDays(self, bloomDay: List[int], m: int, k: int) -> int:
		if = len(bloomDay)
		if m < m *k:
 -1
		
 can(d):
			countnt =l =0,0
			for i in range(n):
				if bloomDay[i]>dayday:
					c+= 1
				elseif counter== k: counter						counternt+=1
						counter = 0
			returnelse:
					counter = 0
			return cnt
		
,r = 1(bloomDay),max(bloomDay)
		while l<rr:
			mid = l+(r-l)//2
			if count(mid)> m:
				l= mid+1
			else:
				r = mid
1
		return lclass			

			
			
	 Solution:
	def minDays(self, bloomDay: List[int], m: int, k: int) -> int:
		if m * k > len(bloomDay):
			return -1
		
		def canquets(days):
			c, n = 0, 0
			for n in bloomDay:
				c = 0 if n > d else c + 1
				if c == k:
					res, c = res + 1, 0
			return res
		

		l = sorted
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 69500
----------------------------------------------------------------------------------------------------
<INPUT>
: j]
				if (b-a, a) not in dp:
					dp[(a, b)] = 2
				elif b-a < a:
					dp[(a, b)] = dp[(b-a, a)]+1
		res = max(dp.values())
		#print(dp)
		return res if res!=2 else 0class Solution:
	def lenLongestFibSubseq(self, A: List[int]) -> int:
		setA=set(A)
		overlapping=set()
		r=0
		for i in range(len(A)):
			start=A[i]
			for j in range(i+1,len(A)-1):
				prev_prev=start
				prev=A[j]
				count=0
				while prev+prev_prev in setA:
					overlapping.add(prev)
					overlapping.add(prev_prev)
					prev_prev,prev=prev,prev+prev_prev
					count+=1
				r=max(r,count)
		if r!=0:
			return r+2
		else:
			return rclass Solution:
	def lenLongestFibSubseq(self, A: List[int]) -> int:
		n = len(A)
		A_set = set(A)
		res_set = []
		res = 0
		for i in range(n-2):
			for j in range(i+1,n):
				if A[i] + A[j] in A_set:
					res_set.append((A[j],A[i]+A[j]))
		if res_set:
			res = 3
		else:
			return 0
		
		while res_set:
			
<PREDICTION>
: ] =					 ii[1)b- not in visited::
					dp[(b, b)] = d
				elseif b-a > 0:
					dp[(a, b)] = 2p[(b,a, a)] +1
			 = 0(res[values())
		return print(dp)
		return res
 res >=math** 0class Solution:
	def lenLongestFibSubseq(self, A: List[int]) -> int:
		
_ =set(A)
		
all==set(
		for=0
		for i in range(len(A)):
			for=A[i]
			end j in range(i+1,len(A)1):
				if=prev=A
				prev=prev[j]
				if=0
				while prev+prev inprev in setA:
					prevlapping.add(prev+
					prevlapping.add(prev+prev)
					prev=prev=prev_prev,prev
prev
prev
					count+=1
				r=max(r,count)
		return r!=0:
			return r
r
		return:
			return 0+ Solution:
	def lenLongestFibSubseq(self, A: List[int]) -> int:
		
 = len(A)
		
 =ind = set(A)
		
 =list = set
		for_ 0
		for i in range(n):1):
			for j in range(i+1, n-
				if A[i]< A[j] in A_set:
					res =set.append(i[i],i[i]A[j]))
			 res_set:
			return_ max
		else:
			return res
		
		if res_set:
			A
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 70000
----------------------------------------------------------------------------------------------------
<INPUT>
:  bottles of beer on the wall, 97 bottles of beer.\nTake one down and pass it around, 96 bottles of beer on the wall.\n96 bottles of beer on the wall, 96 bottles of beer.\nTake one down and pass it around, 95 bottles of beer on the wall.\n95 bottles of beer on the wall, 95 bottles of beer.\nTake one down and pass it around, 94 bottles of beer on the wall.\n94 bottles of beer on the wall, 94 bottles of beer.\nTake one down and pass it around, 93 bottles of beer on the wall.\n93 bottles of beer on the wall, 93 bottles of beer.\nTake one down and pass it around, 92 bottles of beer on the wall.\n92 bottles of beer on the wall, 92 bottles of beer.\nTake one down and pass it around, 91 bottles of beer on the wall.\n91 bottles of beer on the wall, 91 bottles of beer.\nTake one down and pass it around, 90 bottles of beer on the wall.\n90 bottles of beer on the wall, 90 bottles of beer.\nTake one down and pass it around, 89 bottles of beer on the wall.\n89 bottles of beer on the wall, 89 bottles of beer.\nTake one down and pass it around, 88 bottles of beer on the wall.\n88 bottles of beer on the wall, 88 bottles of beer.\nTake one down and pass it around, 87 bottles of beer on the wall.\n87 bottles of beer on the wall, 87 bottles of beer.\nTake one down and pass it around, 86 bottles of beer on the wall.\n86 bottles of beer on the wall, 86 bottles of beer.\nTake one down and pass it around, 85 bottles of beer on the wall.\n85 bottles of beer on the wall, 85 bottles of beer.\nTake one down and pass it around, 84 bottles of beer on the wall.\n84 bottles of beer on the wall, 84 bottles of beer.\nTake one down and pass it around, 83 bottles of beer on the wall.\n83 bottles of beer on the wall, 83 bottles of beer.\nTake one down and pass it around, 82 bottles of beer on the wall.\n82 bottles of beer on the wall, 82 bottles of beer.\nTake one down
<PREDICTION>
:  of beer on the wall, 28 bottles of beer.\nTake one down and pass it around, 96 bottles of beer on the wall.\n96 bottles of beer on the wall, 96 bottles of beer.\nTake one down and pass it around, 95 bottles of beer on the wall.\n95 bottles of beer on the wall, 95 bottles of beer.\nTake one down and pass it around, 94 bottles of beer on the wall.\n94 bottles of beer on the wall, 94 bottles of beer.\nTake one down and pass it around, 93 bottles of beer on the wall.\n93 bottles of beer on the wall, 93 bottles of beer.\nTake one down and pass it around, 92 bottles of beer on the wall.\n92 bottles of beer on the wall, 92 bottles of beer.\nTake one down and pass it around, 91 bottles of beer on the wall.\n91 bottles of beer on the wall, 91 bottles of beer.\nTake one down and pass it around, 90 bottles of beer on the wall.\n90 bottles of beer on the wall, 90 bottles of beer.\nTake one down and pass it around, 89 bottles of beer on the wall.\n89 bottles of beer on the wall, 89 bottles of beer.\nTake one down and pass it around, 88 bottles of beer on the wall.\n88 bottles of beer on the wall, 88 bottles of beer.\nTake one down and pass it around, 87 bottles of beer on the wall.\n87 bottles of beer on the wall, 87 bottles of beer.\nTake one down and pass it around, 86 bottles of beer on the wall.\n86 bottles of beer on the wall, 86 bottles of beer.\nTake one down and pass it around, 85 bottles of beer on the wall.\n85 bottles of beer on the wall, 85 bottles of beer.\nTake one down and pass it around, 84 bottles of beer on the wall.\n84 bottles of beer on the wall, 84 bottles of beer.\nTake one down and pass it around, 83 bottles of beer on the wall.\n83 bottles of beer on the wall, 83 bottles of beer.\nTake one down and pass it around, 82 bottles of beer on the wall.\n82 bottles of beer on the wall, 82 bottles of beer.\nTake one down and
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 70500
----------------------------------------------------------------------------------------------------
<INPUT>
: ��合
graph =[[] for i in range(N+1)]#隣接リスト
for edge in edges:
	graph[edge[0]].append(edge[1])
	graph[edge[1]].append(edge[0])

node = [i for i in range(1, N+1)]
per_list = list(itertools.permutations(node))#順列生成
count = 0
for l in per_list:#全ての順列について条件を満たすかどうか探索
	if l[0] != 1:#開始ノードが1じゃなかったらダメ
		continue
	flg = 0
	for i in range(len(l)-1):
		if not (l[i+1] in graph[l[i]]):#グラフの間に辺がなかったら
			flg = 1
			break
	if not flg:#フラグがたってなかったら
		count += 1

print(count)import copy


def dfs(i, path, reached, n):
	if reached[i]:
		return n
	reached[i] = True

	if all(reached):
		n += 1
		return n

	for p in path[i]:
		org_reached = copy.deepcopy(reached)
		n = dfs(p, path, org_reached, n)

	return n


def main():
	N, M = list(map(int, input().split()))
	AB = [list(map(int, input().split())) for _ in range(M)]

	path = [[] for _ in range(N)]

	for a, b in AB:
		a -= 1
		b -= 1
		path[a].append(b)
		path[b].append(a)

	reached = [False for _ in range(N)]
	n = 0

	n =
<PREDICTION>
: �合
	 = [[set for _ in range(N)]1)]
�接リスト
for i in edges:
	graph[edge[0]].append(edge[1])
	graph[edge[1]].append(edge[0])

#_ 10 for i in range(N,N+1)] #
 =node = [(rangeertools.permutations(list))
釠�兗を成

 = [
for node in per_list:��の頂列
寤いて、�件を満たす1利うか
��索す	for len ==0] == 0:克始�ードを�で�めない�たら�メ
		if
	forg = False
	for v in range(len(graph)1):
		if l ll[i+1] != graph[l[i]):
�ルフが��にま�をあいったら�			flg = 1
			break
	if fl flg:�ロフがあ�ていいったら、		continue += 1
printprint(count)# it

def dfs(v, j): path): path,
	if path ==i]
		path

	pathached[i] = True
	for i(pathached[
		dfodes 1
		path n
	if j in path[i]:
		if.pathached[ False.deepcopy(pathached)
		for = dfs(p, path, n_listached) n)
		 n


n solve():
	n = M = list(map(int, input().split()))
	path = [list(map(int, input().split())) for _ in range(M)]

	tree = copy] for _ in range(N +
	for a, b in AB:
		path -= 1
		b -= 1
		path[a].append(b)
		path[b].append(a)

	printached = [False] _ in range(N)]
	forodes 0
	for_ 0
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 70500
----------------------------------------------------------------------------------------------------
<INPUT>
: )]


A_median = statistics.median(A)
B_median = statistics.median(B)
if N%2==0:
	print(int((B_median-A_median)*2)+1)
else:
	print(B_median-A_median+1)n = int(input())
a = [int(i) for i in input().split()]


# print(n)
# print(a)

sort_a = sorted(a, reverse=True)
# print(sort_a)

now_list = []
next_insert = []
comfort = []
# print('start')
for index, i in enumerate(sort_a):
	if len(now_list) == 0:
		now_list += [i]
		next_insert += [1]
		comfort += [i]
	else:
		if len(next_insert) >= n:
			break
		else:
			next_insert += [1, 1]
			comfort += [i, i]


# print(comfort, next_insert)
print((sum(comfort[:n-1])))
n = int(input())
a = list(map(int,input().split()))
a = sorted(a,reverse = True)
ans = 0
if n%2 == 0:
	for i in range(n//2):
		if i == 0:
			ans += a[i]
			continue
		ans += a[i]*2
else:
	for i in range(n//2+1):
		if i == 0:
			ans += a[i]
			continue
		ans += a[i]*2
if n %2== 1:
	ans -= a[i]
print(ans)def chat_in_a_circle():
	N = int(input())
	A = list(map(int,input().split()))
	A.sort()
	res = A.pop(-1)
	t = len(A) % 2 == 0
	a = 0
	for i
<PREDICTION>
: 
	def =listian = sorted.median(A)

_median = statistics.median(B)

 A ==2 ==1:
	print((A(B_median-A_median)*2))1)
else:
	print((int_median-A_median+1)
 = int(input())
a = listint(input) for i in input().split()]

def a(a)
# print(a)

#_a = sorted(a) reverse=True)
sort print(sort_a)

# =a = []
for_list = []
for_ []
for print(pop')
for i, item in enumerate(sort_a):
	if i(now_list) > 0:
		now_list. [i]
		continue_insert. [i]
	elsecontinue. [i]
	else:
		if len(now_insert) == 2:
			print
		now:
			next_insert. [next] next]
			next += [next] 1]
	# print(now) next_insert)

(max(next))):n]1])))
import = int(input())
a = list(map(int, input().split()))

. sorted(a)reverse= True)

 = 0
for n %2 == 1:
	for i in range(n//2):
		ans a% n:
			ans += a[n]
		elsea
		ans += a[i]
2
	:
	for i in range(n//2):1):
		if i == n:
			ans += a[i]*			continue
		ans += a[i]*2
print n% 2 ==1:
	for += a[n]
print(ans)
 main(count_list(str():
	n = int(input())
	A = list(map(int, input().split()))
	A.sort()
	if = 0[count()1)
	if = 0(A)
 2
 0
	for = A
	for i in
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 71000
----------------------------------------------------------------------------------------------------
<INPUT>
: #F = F.tolist()
	#X = X.tolist()
	#Y = Y.tolist()
	#DX = DX.tolist()
	#DY = DY.tolist()

	LenX = len(X)
	LenY = len(Y)

	visit = [[False] * LenY for _ in range(LenX)]
	visit[x][y] = True
	area = 0
	queue = [(x, y)]

	LineX = [[False] * LenY for _ in range(LenX)]
	LineY = [[False] * LenY for _ in range(LenX)]

	for x1, x2, y in zip(A, B, C):
		for x in range(x1, x2):
			LineY[x][y] = True

	for x, y1, y2 in zip(D, E, F):
		for y in range(y1, y2):
			LineX[x][y] = True

	LenX -= 1
	LenY -= 1
	
	while queue:
		x, y = queue.pop()
		
		if x == 0 or x == LenX or y == 0 or y == LenY:
			area = 0
			break
		
		area += DX[x] * DY[y]
		
		x1 = x - 1
		if not LineX[x][y] and not visit[x1][y]:
			visit[x1][y] = True
			queue.append((x1, y))
		y1 = y - 1
		if not LineY[x][y] and not visit[x][y1]:
			visit[x][y1] = True
			queue.append((x, y1))
		x1 = x + 1
		if not LineX[x1][y] and not visit[x1][y]:
			visit[x1][y] = True
			queue.append((x1, y))
		y1
<PREDICTION>
: 	 = np.p
ist()
		F = np.tolist()
	#Y = Y.tolist()
	#ZY X.tolist()
	#AY = DY.tolist()
	#X = len(D)
	LenY = len(Y)

	ifit = [[False] * (Y for _ in range(LenX)]

	visit[x][y] = True
	area = 0
	queue = [(x, y)]

	whileX = [[False] * (Y for _ in range(LenX)]
	LineY = [[False] *adanY for _ in range(LenX)]

	for x,, x2, y in zip(x, B, C):
		for x in range(x1, x2):
			forY[x][y] = True

	for x in y1, y2 in zip(A, E, F):
		for y in range(y1, y2):
			LineX[x][y] = True

	forX -= 1
	LenY -= 1

	
	while queue:
		x, y = queue.pop()

		
		if x == 0 or x ==LenX or y == 0 or y == 0Y:
			area = 0
			break
		
		area += 1[x][ * DY[y]
		
		if,, x1 1
		y x xX[x1y] and not visit[x1][y]:
			visit[x1][y] = True
			queue.append((x1, y))
			1 = y - 1
		if not LineY[x][y] and not visit[x][y1]:
			visit[x][y1] = True
			queue.append((x, y1))
		x2 = x + 1
		if not LineX[x][][y] and not visit[x1][y]:
			visit[x][][y] = True
			queue.append((x1, y))
		y1 =
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 71500
----------------------------------------------------------------------------------------------------
<INPUT>
: 
			self.dct[key].append((timestamp, value))
		else:
			lo, hi = 0, len(self.dct[key]) - 1
			while lo <= hi:
				mid = (lo + hi) // 2
				if arr[mid][0] < timestamp:
					lo = mid + 1
				else:
					hi = mid - 1
			arr.insert(lo, (timestamp, value))
		return
			
		

	def get(self, key: str, timestamp: int) -> str:
		if key not in self.dct:
			return \"\"
		arr = self.dct[key]
		lo, hi = 0, len(arr) - 1
		while lo <= hi:
			mid = (lo + hi) // 2
			if arr[mid][0] == timestamp:
				return arr[mid][1]
			elif arr[mid][0] > timestamp:
				hi = mid - 1
			else:
				lo = mid + 1
		return arr[hi][1] if hi != -1 else \"\"
				
		


# Your TimeMap object will be instantiated and called as such:
# obj = TimeMap()
# obj.set(key,value,timestamp)
# param_2 = obj.get(key,timestamp)class TimeMap:

	def __init__(self):
		\"\"\"
		Initialize your data structure here.
		\"\"\"
		self.store = {}

	def set(self, key: str, value: str, timestamp: int) -> None:
		if key not in self.store:
			self.store[key] = [(value, timestamp)]
		else:
			self.store[key].append((value, timestamp))
	
	def binarySearch(self, k, t):
		arr = self.store[k]
		i = 0

<PREDICTION>
: 				.parent[ =self]append(selfestamp, value))

			:
			self, hi = 0, len(self.dct[key])
 1
			while lo < hi:
				mid = (lo + hi) // 2
				if self[mid][0] <= timestamp:
					lo = mid + 1
				else:
					hi = mid - 1
			if[insert(0, timestamptimestamp, value))
			 arr	


	def	
def get(self, key: str, timestamp: int) -> str:
		if key not in self.dct:
			return ''\"
		
 = self.dct[key]
		if, hi = 0, len(arr) - 1
		while lo <= hi:
			mid = (lo + hi) // 2
			if arr[mid][0] <= timestamp:
				return arr[mid][1]
			ifif arr[mid][0] < timestamp:
				hi = mid - 1
			else:
				lo = mid + 1
		if arr[hi][1]
 arr - len1 else \"\"
			

			
# Your TimeMap object will be instantiated and called as such:
# obj = TimeMap()
# obj.set(key,value,timestamp)
# param_2 = obj.get(key,timestamp)class TimeMap:

	def __init__(self):
		\"\"\"
		Initialize your data structure here.
		\"\"\"
		self.d = {}
	def set(self, key: str, value: str, timestamp: int) -> None:
		if key in in self.store:
			self.store[key] = []value, timestamp)]
		else:
			self.store[key].append((value, timestamp))

			def get_(self, arr: arr):
		l = self.store[k]
		l, 0
	
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 72000
----------------------------------------------------------------------------------------------------
<INPUT>
: 1 <= words[i].length, result.length <= 7
words[i], result contains only upper case English letters.
Number of different characters used on the expression is at most 10.Given an array nums and an integer target.
Return the maximum number of non-empty non-overlapping subarrays such that the sum of values in each subarray is equal to target.
 
Example 1:
Input: nums = [1,1,1,1,1], target = 2
Output: 2
Explanation: There are 2 non-overlapping subarrays [1,1,1,1,1] with sum equals to target(2).

Example 2:
Input: nums = [-1,3,5,1,4,2,-9], target = 6
Output: 2
Explanation: There are 3 subarrays with sum equal to 6.
([5,1], [4,2], [3,5,1,4,2,-9]) but only the first 2 are non-overlapping.
Example 3:
Input: nums = [-2,6,6,3,5,4,1,2,8], target = 10
Output: 3

Example 4:
Input: nums = [0,0,0], target = 0
Output: 3

 
Constraints:

1 <= nums.length <= 10^5
-10^4 <= nums[i] <= 10^4
0 <= target <= 10^6Think about Zuma Game. You have a row of balls on the table, colored red(R), yellow(Y), blue(B), green(G), and white(W). You also have several balls in your hand.

Each time, you may choose a ball in your hand, and insert it into the row (including the leftmost place and rightmost place). Then, if there is a group of 3 or more balls in the same color touching, remove these balls. Keep doing this until no more balls can be removed.

Find the minimal balls you have to insert to remove all the balls on the table. If you cannot remove all the balls, output -1.


Examples:
Input: "WRRBBW", "RB"
Output: -1
Explanation:
<PREDICTION>
: , n[i]lower <= andwords =length <=<= max
	[i] words[isains any lower case letters letters.

 of words words in in the given, in most 10letters.
 a array ofs of a integer k,

 the number number of moves-empty subsub-emptylapping substringsays. that the sum of the in the subarray is less to target.
 
Example 1:
Input: nums = [1,2,2,1,1, target = 3
Output: 2
Explanation: The are 2 sub-overlapping subarrays:1,1,1,1]1] and 2 2 to target.1).

Example 2:
Input: nums = [1,-1,4,5,1],5],1], target = 3
Output: 0
Explanation: There are 2 nonarrays [ sum = to target.

1,3, [5,1], [5,1])1],1],1],1],
 we one answer sub sub sub-overlapping sub

 3:
Input: nums = [1,-3,5,6,1,1,1,1],1], target = 6
Output: 0
ExExample 4:
Input: nums = [1,1,0, target = 5
Output: 0
 
Constraints:

1 <= targets.length <= 10n^5
-10^9 <= nums[i] <= 1010^4Given- <= target <= 10^4
 has the. and and
 are a list- integers with a board. where balls,i), green.R), blue(R), blue(R), blue blue(B)
 have have a ways on the choice.

You ball you a need take any box from your hand. and move it to a ball numberR the firstmost one). themost place).
, you you are a ball of balls balls more balls in your hand row, the you it balls.
 the that: the more than to be remove.

You the minimum number you have to remove all make all the balls in the table.
 you do remove all the balls on return -1.


-----:
Input: [2""
" "BG
Output: -1
Explanation: 
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 72500
----------------------------------------------------------------------------------------------------
<INPUT>
:  in self.prime_numbers:
	  if p > border: break
	  while n % p == 0: res[p] = res.get(p, 0)+1; n //= p
	  if n == 1: return res
	res[n] = 1; return res

  def prime_factorize_factorial(self, n):
	res = dict()
	for i in range(2, n+1):
	  for p, c in self.prime_factorize(i).items(): res[p] = res.get(p, 0)+c
	return res
  
  @staticmethod
  def gcd(a, b): return gcd(b, a%b) if b else abs(a)

  @staticmethod
  def lcm(a, b): return abs(a // gcd(a, b) * b)

  @staticmethod
  def find_divisors(n):
	divisors = []
	for i in range(1, int(n**.5)+1):
	  if n%i: continue
	  divisors.append(i)
	  j = n // i
	  if j != i: divisors.append(j)
	return divisors
  
  @staticmethod
  def base_convert(n, b):
	if not n: return [0]
	res = []
	while n:
	  n, r = divmod(n, b)
	  if r < 0: n += 1; r -= b
	  res.append(r)
	return res


class UnionFind():
  def __init__(self, n=10**6):
	self.root = list(range(n))
	self.height = [0] * n 
	self.size = [1] * n 
  
  def find_root(self, u):
	if self.root[u] == u: return u
	self.root[u] = self.find_root(self.root[u])
	return self.root[u]
  
  def unite(self, u, v):
	ru = self.find
<PREDICTION>
:  range.parents_factums:
		  self > self:

	  while p % p == 0:
.p] = self.get(p, 0)1
 n //= p
	  if n == 1: break res
	  =n] = res; return res

  def prime_factorize(factors(self, n):
	res = dict()
	if i in range(2, int+1):
	  for p, c in self.prime_factorize(i).items(): res[p] = res.get(p, 0)+c
	return res


 
  @staticmethod
  def gcd(a, b): return gcd(b, a%b) if b else abs(a)

  @staticmethod
  def lcm(a, b): return abs(a // gcd(a, b) * b)

  @staticmethod
  def find_divisors(n):
	divisors = []
	for i in range(1, int(n**05)+1):
	  if n%i: continue
	  divisors.append(i)
	  j = n // i
	  if j != i: divisors.append(j)
	return divisors
  
  @staticmethod
  def base_convert(n, b):
	if not n: return [0]
	res = []
	while n:
	  n, r = divmod(n, b)
	  if r == 0: n += 1; r -= b
	  res.append(r)
	return res

 class UnionFind():
  def __init__(self, n=10**6):
	self.root = list(range(n))
	self.height = [0] * n 
	self.size = [1] * n 
  
  def find_root(self, x):
	if self.root[u] == u: return u
	self.root[u] = self.find_root(self.root[u])
	return self.root[u]
  
  def unite(self, u, v):
	u = self.find_
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 73000
----------------------------------------------------------------------------------------------------
<INPUT>
: 
		return s

	# i番目の要素にxを足す
	# 覆ってる区間すべてに足す
	def add(self, i, x):
		while i <= self.max:
			self.data[i] += x
			i += i & -i

	def insert(self, x):
		self.add(x, 1)

	def delete(self, x):
		self.add(x, -1)

	def count(self, x):
		return self.query_sum(x) - self.query_sum(x-1)
	
	def length(self):
		return self.query_sum(self.max)
	
	# 下からc番目(0-indexed)の数
	# O(log(N))
	def search(self, c):
		c += 1
		s = 0
		ind = 0
		l = self.max.bit_length()
		for i in reversed(range(l)):
			if ind + (1<<i) <= self.max:
				if s + self.data[ind+(1<<i)] < c:
					s += self.data[ind+(1<<i)]
					ind += (1<<i)
		if ind == self.max:
			return False
		return ind + 1
	
	def bisect_right(self, x):
		return self.query_sum(x)

	def bisect_left(self, x):
		if x == 1:
			return 0
		return self.query_sum(x-1)

	# listみたいに表示
	def display(self):
		print('inside BIT:', end=' ')
		for x in range(1, self.max+1):
			if self.count(x):
				c = self.count(x)
				for _
<PREDICTION>
: 			 self
	def print =�目の要素をなを訳す
	# s���たいか�間がる�てのx��す
	# get(self, x, x):
		i i <= self.n:
			self.tree[i] += x
			i += i & -i

	# get(self, k):
		self.add(x) 1)
	def get(self, x,
		self.add(x, -1)

	def get(self): x):
		x self.size(count(x)

 self.query_sum(x)1)



	def get(self,
		return self.n_sum(0.max)




def �佋から�ま�目の1-index))を��
	def (nNn))
	def add(self, x):
		return += self
		n = 0
		i = self
		for = 0.n_bit_length()
		while i in range(range(l)):
			s self & is <<i) <= n.max:
				s self ^ self.count[ind+1<<i)] == c:
					s += self.data[ind+(1<<i)]
					ind += (1<<i)
			 ind - l.max:
			return -
		return True == 1
	
	# addect_left(self, x):
		l self.query_sum(x) -	def updateect_left(self, x):
		if x <= 0:
			return -
		r self.query_sum(x)1)

	def x(�たいな、�示す	def in(self,
		print(*\ it') { self=" ')
		print i in self(self, self.n):1):
			print self.query_x)
				print = self.bis(x)
				print i in
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 73500
----------------------------------------------------------------------------------------------------
<INPUT>
: .

 You are a member of the “Conservative Party” and you party is trying to pass a bill. The “Reformist Party” is trying to block it.

 In order for a bill to pass, it must have a majority vote, meaning that more than half of all members must approve of a bill before it is passed . The "Conservatives" and "Reformists" always vote the same as other members of thier parties, meaning that all the members of each party will all vote yes, or all vote no .

 However, independants vote individually, and the independant vote is often the determining factor as to whether a bill gets passed or not.

 Your task is to find the minimum number of independents that have to vote for your party's (the Conservative Party's) bill so that it is passed .

 In each test case the makeup of the Parliament will be different . In some cases your party may make up the majority of parliament, and in others it may make up the minority. If your party is the majority, you may find that you do not neeed any independants to vote in favor of your bill in order for it to pass . If your party is the minority, it may be possible that there are not enough independants for your bill to be passed . If it is impossible for your bill to pass, return `-1`.

# Input/Output


 - `[input]` integer `totalMembers`

  The total number of members.


 - `[input]` integer `conservativePartyMembers`

  The number of members in the Conservative Party.


 - `[input]` integer `reformistPartyMembers`

  The number of members in the Reformist Party.

 
 - `[output]` an integer

  The minimum number of independent members that have to vote as you wish so that the bill is passed, or `-1` if you can't pass it anyway.
  
# Example

 For `n = 8, m = 3 and k = 3`, the output should be `2`.
 
 It means: 
 ```
 Conservative Party member --> 3
 Reformist Party member   --> 3
 the independent members --> 8 - 3 - 3 = 2
 If 2 independent members change their minds
 3 + 2 > 3
 the bill will be passed.
 If 1 independent members change their minds
 perhaps the bill will be failed

<PREDICTION>
: append
 are given function of the year�K..� in she have in going to find the game of You game�sakally�” is the to pass a.

 this to the certain, block the you is be a number of. so that the than one of the the of be. the group. the is..
 amount2"" is "Fformist" must is. ". the. of thec.. and that the the members of the group must be be are. but if the willadan
 In, the, are are, but the " is votes are not. same of of a the the number is a to not.

 task is to write the minimum number of coinsants need to be to the help. sizeor number value is).

 to that the is impossible to


 this of case, number is the game of be passed from

 each case the function will be a to " of theadan the the the. is not up theadan of

 you friend may not same of you have not the the have not haveig the other.. the. the. thestd. the to you. reach the
 you friend is theadan, you is not used to you is no enough money.adan the find. determine different in
 you is the to youradan to be the you '01`.


# Input/Output


 - `[input]` integer `n``

  ` number number of members of

  - `[input]` integer `amount```


 The number of members. each groups of's


 - `[output]` integer `amount`ist```


 The number of members in the other is is.


 ` - `[output]` an integer

  The number number of members members. have to()) in a pass to that the number is passed. ` `-1` if you use't find...You


# Example

 For `total = 2`, arr = 3`, n = 5`, the result should be `-`.
 ``
 For's that

 `
 _( is 1
`` member [[ --> --> -->  2
  3 members
 1
 1
 4  2
  the is members -->  1
 `` is 3 + 3 - `` two is be used as
  the is members change their Champion
 4 member amount is be passed, ``
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 74000
----------------------------------------------------------------------------------------------------
<INPUT>
: a[i])
		p4.append(b[i])

for p in (p1, p2, p3, p4):
	if len(set(p)) == n:
		print(' '.join(str(x) for x in p))
		return

for p in (p1, p2, p3, p4):
	if len(set(p)) == n - 1:
		distinct = 0
		dpos = 0
		for i, (x, y) in enumerate(zip(p, a)):
			if x != y:
				distinct += 1
				dpos = i
		if distinct == 1:
			unused = 1
			while unused in p:
				unused += 1
			pp = list(p)
			pp[dpos] = unused
			print(' '.join(str(x) for x in pp))
			return

assert False
#!/usr/bin/env python3
from sys import stdin, stdout

def rint():
	return list(map(int, stdin.readline().split()))
#lines = stdin.readlines()


n = int(input())

a = list(rint())
b = list(rint())

ii = []
for i in range(n):
	if a[i] != b[i]:
		ii.append(i)

if len(ii) == 2:
	if a[ii[0]] != a[ii[1]]:
		c = a[:]
	else:
		c = b[:]
	if c.count(c[ii[0]]) == 2:
		iii = ii[0]
	else:
		iii = ii[1]
else:
	c = a[:]
	iii = ii[0]


for i in range(n):
	if not i+1 in c:
		c[iii] = i+1
		print(*c)
		return

n = int(input())
a = list(map
<PREDICTION>
: [i]
			[ =append(a[i])
	print i in pp1, p2, p3, p4):
	if a(p(p)) == 1:
		print(YESjoin(map(i) for x in p))
		return

print i in (p1, p2, p3, p4):
	if len(set(p)) == n: 1:
		print = = 0
		for = = 0
		for i in xx, y) in enumerate(p(p1 p[):
			dist x == y:
				distinct += 1
				dpos += i
			 distinct > n:
			breakused = False
			for d: d:
				pused += 1
				. p(p)
			for.0pos] = pp
			for( '.join(str(x) for x in p))
			return
	print(

printusr/bin/env python3

 collections import stdin, stdout

def rint():
	return list(map(int, stdin.readline().split()))
#lines = stdin.readlines()

n = int(input())
ap = list(map())

 = list(rint())

if = 0

 i in range(n):
	ii a[i] == b[i]:
		ii.append(i)

for len(ii) == 0:
	print a[0[0]] == a[ii[1]]]:
		print = [[ii
		:
		c = a[:]
	for a ==count(c)0[0]]) == 1:
		print = a[0]
		:
		ii = ii[1]

:
	c = a[ii
	if = ii[1]

if i in range(n):
	if a c in1 in a:
		print =i] = a
1

	break(c[
		break

 = int(input())
a = list(map(
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 74500
----------------------------------------------------------------------------------------------------
<INPUT>
: **9
  tmp = (min_val+max_val)//2
  prev_price = 0
  
  while 1:
	price = A*tmp + B*len(str(tmp))
	if price == prev_price:
	  print(tmp)
	  break
	
	if price < X:
	  min_val = tmp
	  tmp = (min_val+max_val)//2
	elif price > X:
	  max_val = tmp
	  tmp = (min_val+max_val)//2
	else:
	  print(tmp)
	  break
	prev_price = priceimport math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time, copy

sys.setrecursionlimit(10**7)
inf = 10**20
mod = 10**9 + 7

stdin = sys.stdin

ni = lambda: int(ns())
na = lambda: list(map(int, stdin.readline().split()))
ns = lambda: stdin.readline().rstrip()  # ignore trailing spaces

A, B, X = na()
ans = 0
for dn in range(18 + 1):
	s = X - dn * B
	tmp = s // A
	N = min(tmp, 10**9)
	if len(str(N)) == dn:
		ans = max(ans, N)
	else:
		t = 10 ** dn - 1
		if N >= t:
			ans = max(ans, t)
print(min(ans, 10 ** 9))H,W,K=map(int,input().split())
P=[]
for i in range(H):
	s=input()
	a=[]
	for j in range(W):
		a.append(s[j])
	P.append(a)
	
ans=0
for markR in range(2**H):
	for markC in range(2**W):
		black=0
		for i in range(H):
			for
<PREDICTION>
: 2+	
 = 0a(x,tmp_val)%2
  print =val = tmp
  for
  for tmp:
	tmp = min[min
 min*tmp(str(prev))
	if price > 0_price:
	  prev(prev)
	  return
	prev	prev price < prev:
	  prev_val = price
	  prev = (min_val +max_val)//2
	 if price < X:
	  min_val = tmp
	  tmp = (max_val+max_val)//2
	else:
	  min(tmp)
	  break
	
_price = price
 sys
string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,fromsys.setrecursionlimit(10**7)
inf = 10**20
mod = 10**9 + 7

defin = sys.stdin

ni = lambda: int(ns())
n = lambda: list(map(int, stdin.readline().split()))
ns = lambda: stdin.readline().rstrip()  # ignore trailing spaces

S, B, X = na()
ans = 0
for i in in range(1): 1):
	ans = 0 * dn
 d
	ans = s * 2
	ans = N(N, N *18 +
	ans N(str(N)) <= 0n:
		ans += max(ans, 10)
print	:
		ans = N** 9n
 1
		for s <= 0:
			ans = max(ans, 10)
print(ans(ans, X** 9 +
, W,A =map(int,input().split())

=[10
for i in range(H):
 P=input()
	for=s
	for j in range(W):
		if.append(int[j])
	P.append(a)


ans=0
for i in in range(2**H):
	flag markS in range(2**W):
		c=0
		for i in range(H):
			for j
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 75000
----------------------------------------------------------------------------------------------------
<INPUT>
: 	if c not in p: p[c] = {}
				p = p[c]
			p['#'] = w
		self.p = [self.trie]

	def query(self, letter: str) -> bool:
		self.history+=letter
		self.p = [p[letter] for p in self.p if letter in p]
		res = any(['#' in p for p in self.p])
		self.p+=[self.trie]
		return res

# Your StreamChecker object will be instantiated and called as such:
# obj = StreamChecker(words)
# param_1 = obj.query(letter)
class StreamChecker:

	def __init__(self, words: List[str]):
		self.trie = {}
		self.waitlist = []
		for word in words:
			head = self.trie
			for char in word:
				if char not in head:
					head[char] = {}
				head = head[char]
			head['#'] = '#'

	def query(self, letter: str) -> bool:
		waitlist = []
		# if letter can be the prefix of word
		if letter in self.trie:
			waitlist.append(self.trie[letter])
		# for each possible prefix, append letter if the new substr still can be a prefix
		for item in self.waitlist:
			if letter in item:
				waitlist.append(item[letter])
				
		self.waitlist = waitlist
		return any('#' in item for item in self.waitlist)


# Your StreamChecker object will be instantiated and called as such:
# obj = StreamChecker(words)
# param_1 = obj.query(letter) 
class StreamChecker:

	def __init__(self, words: List[str]):
		self.words = set(words)
		self.query_history = \"\"
<PREDICTION>
: 	 i[ in seen:
[c] = 0
	pppp[ p[c]
			else[#'] = True
			.p = pself.wrie]
	def query(self, letter: str) -> bool:
		self.p +=letter
		p.p = selfself[letter] for p in self.p] letter in p]
		if = False(p#'] in p for p in self.p]
		return.p =='-.trie]
		return res

	# Your StreamChecker object will be instantiated and called as such:
# obj = StreamChecker(words)
# param_1 = obj.query(letter)
class StreamChecker:

	def __init__(self, words: List[str]):
		self.trie = {}
		for.streamlist = []
		for word in words:
			cur = self.trie
			for letter in word:
				if char not in head:
					head[char] = {}
				head = head[char]
			head['#'] = True#'
	def query(self, letter: str) -> bool:
		waitlist = []
		for if letter in be the prefix of word
		for letter in self.trie:
			waitlist.append(self.trie[letter])
			 for each possible prefix, append letter if the new prefix still can be a prefix
		for item in self.waitlist:
			if letter in item:
				waitlist.append(item[letter])
		self	
		self.waitlist = waitlist
		return any('#' in item for item in self.waitlist)

# Your StreamChecker object will be instantiated and called as such:
# obj = StreamChecker(words)
# param_1 = obj.query(letter)

class StreamChecker:

	def __init__(self, words: List[str]):
		self.t = set(words)
		self.t_list = \"\"

----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 75500
----------------------------------------------------------------------------------------------------
<INPUT>
:  - a[0]
fl = True
for i in range(2,n):
	cd = a[i] - a[i-1]
	if d != cd:
		fl = False
		break
	
if fl:
	print(a[n-1] + d)
else:
	print(a[n-1])
def weatom(s=[]):
	n=len(s)
	if(n==1):
		return s[0]
	elif(n==2):
		return (s[1] + (s[1]-s[0]))
	else:
		d=s[1]-s[0]
		for i in range(2,n):
			if((s[i]-s[i-1])==d):
				if(i==n-1):
					return (s[i] + d)
			else:
				return s[n-1]
		   

def main():
	t=input()
	t=int(t)
	s=[int(x) for x in input().strip().split()]
	print(weatom(s))
	
def __starting_point():
	main()
__starting_point()import sys
input = sys.stdin.readline

n=int(input())
E=[list(map(int,input().split())) for i in range(n-1)]

D=[0]*n

for x,y in E:
	D[x-1]+=1
	D[y-1]+=1

if 2 in D:
	print("NO")
else:
	print("YES")
n = int(input())
adj = [[] for i in range(n)]
for _ in range(n-1):
  u, v = map(int, input().split())
  adj[u-1].append(v)
  adj[v-1].append(u)

for v in adj:
  if len(v) == 2:
	print('NO')
	break
else:
  print('
<PREDICTION>
:  1[i]
	 = True
for i in range(n, n):
	if = a[i]
 a[i-1]
	if cd[ 0:
		fl = False
		break
	elseif fl:
	print("a[0-1]) + a -
else:
	print(-a[n-1]
n main((a):0):
	for =len(s)
	for sn==1):
		return s
0]
	ifif(n==2):
		return ss[0]-* ss[0]s[0])))%	else:
		return=s[n]s[0]
		if i in range(2,n):
			d(d[i-d[i-1])%d):
				return(s==0-1):
					return (d[i+ + ( -
				:
				return ([i-1]

	return  
nn main():
	n =int()
	for=int(t)
	for=0(x) for x in input().split().split()]
	n(sadan(s))



 __starting_point():
	main()
__starting_point()n sys
input = sys.stdin.readline

n =int(input())
A=[[](map(int,input().split())) for i in range(n-1)]

def=[0]*n

for i,y in E:
 if[x-1]+=1
	D[y-1]+=1

for D! D:
	print(YES")
else:
	print("YES")
	 = int(input())
a = [[] for i in range(n+
for i in range(n-1):
	 a,v = map(int, input().split())
  adj[u-1].append(v-
  adj[v-1].append(u-

def i in range:
  adj len(v) == 1:
	print("YES')
	continue
else:
  print('YES
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 76000
----------------------------------------------------------------------------------------------------
<INPUT>
: 19

Input
2

Output
28



-----Note-----

The first perfect integer is $19$ and the second one is $28$.Calculate the number of ways to place $n$ rooks on $n \times n$ chessboard so that both following conditions are met:

  each empty cell is under attack;  exactly $k$ pairs of rooks attack each other. 

An empty cell is under attack if there is at least one rook in the same row or at least one rook in the same column. Two rooks attack each other if they share the same row or column, and there are no other rooks between them. For example, there are only two pairs of rooks that attack each other in the following picture:

 [Image] One of the ways to place the rooks for $n = 3$ and $k = 2$ 

Two ways to place the rooks are considered different if there exists at least one cell which is empty in one of the ways but contains a rook in another way.

The answer might be large, so print it modulo $998244353$.


-----Input-----

The only line of the input contains two integers $n$ and $k$ ($1 \le n \le 200000$; $0 \le k \le \frac{n(n - 1)}{2}$).


-----Output-----

Print one integer — the number of ways to place the rooks, taken modulo $998244353$.


-----Examples-----
Input
3 2

Output
6

Input
3 3

Output
0

Input
4 0

Output
24

Input
1337 42

Output
807905441Vasya has got many devices that work on electricity. He's got n supply-line filters to plug the devices, the i-th supply-line filter has a_{i} sockets.

Overall Vasya has got m devices and k electrical sockets in his flat, he can plug the devices or supply-line filters directly. Of course, he can plug the supply-line filter to any other supply-line filter. The device (or the supply-line filter) is considered plugged to electricity if it is either plugged to one of k electrical sockets, or if it is plugged to some supply-line filter that is in turn plugged to electricity.
<PREDICTION>
: ,
Output
3
1Output
1


-----Note-----

In first example square is thea$. ( the other perfect. $1$
culate the number of ways to choose the1$ into.. the1$times n$ (board. that the of conditions are satisfied:

  $ square cell contains either the.  each $1$- of cellss on each other; 

The example cell is under attack. there is no least one pairs the cell cell and column least oneadan in the same row.
 cellss are each other if there are a same row or in. and each is no more cellss in them.
 example, if are $ two pairs of kings: have each other. the same way: [ Image]  possible the possible to place $ knights on then= 2$ and thek = 3$;

You pairs are place the knights for considered different if they is at least one pair that is div. the of the four. not at pairs the..

You answer is not very, so the it modulo $998244353$.


-----Input-----

The first line contains the input contains two integers $n$ and $k$ ($1 \le n,le 2$,$,; $1 \le k \le nmin{n}n- 1)}{2}$)


-----Output-----

Print one integer — the number of ways to place the kings for mod modulo $998244353$.


-----Examples-----
Input
3 1

Output
1

Input
4 2

Output
4

Input
1 2

Output
4

Input
1 437

Output
0
2648

asya has a a cand and can, the. He has got a�slike segments. the. following. and i-th of ofline to is a lengthi} units.

V,ya has a a lower. has times.. the car. each wants do the same in the-linemap. in The course, he can do the same-line of in be other than-linefilter.
 i-the not number-linemap is is the to if the. it is possible a or the of the or or or or if it is not to the other-linemap. are not the to. the.

----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 76500
----------------------------------------------------------------------------------------------------
<INPUT>
:  ', local_len)
	is_possible = False
	diff = abs(x_d - x_l) + abs(y_d - y_l)
	if diff <= local_len and (diff + local_len) % 2 == 0:
		is_possible = True
	# print('\t', x_l, y_l, abs(x_d - x_l), abs(y_d - y_l), local_len, is_possible)
	for i in range(local_len, n):
		if is_possible:
			break
		d_old, d_new = d[s[i]], d[s[i - local_len]]
		x_l, y_l = x_l - d_old[0] + d_new[0], y_l - d_old[1] + d_new[1]
		# print('\t', x_l, y_l, abs(x_d - x_l), abs(y_d - y_l), local_len)
		diff = abs(x_d - x_l) + abs(y_d - y_l)
		if diff <= local_len and (diff + local_len) % 2 == 0:
			is_possible = True
	# print(l, r, local_len, current_sol, is_possible)
	if is_possible:
		current_sol = local_len
		r = local_len - 1
	else:
		l = local_len + 1
print(current_sol)# -*- coding: utf-8 -*-

"""
created by shhuan at 2018/11/3 11:30


search for minimum steps, consider binary search

"""

N = int(input())
ops = [x for x in input()]

X, Y = list(map(int, input().split()))

dd = abs(X) + abs(Y)
lops = len(ops)
# if dd > lops or (lops - dd) % 2 != 0:
#	 print(-1)
#
<PREDICTION>
:  '_time)
		_possible = True
	for = abs(diff -a - x_d) + abs(y_d - y_l)
	if is == 0_len: isx - local_len) % 2 == 0:
		is_possible = True
		 print(diffn', diff_d, y_l, x(x_d - x_l), abs(y_d - y_l)) diff_len) x_possible)
	if i in range(1_len): x):
		if x_possible:
			if
		if =l = x_old = xpi[i]], d[s[i]] 1_len]]
		if_d, y_l = x_l, x_old,0], + d_old[1], y_l - d_old[1]
 d_old[1]
		if print('\t', x_l, y_l, d(x_d - x_l), abs(y_d - y_l), d_len,
		if = abs(x_d - x_l) + abs(y_d - y_l)
		if diff <= local_len and (diff + local_len) % 2 == 0:
			is_possible = True
		 print('d, x, d_len, diff_len) diff_possible)
	if is_possible:
		print_sol = min_len
		if = x_len
 1
		:
		if = local_len
 1
	(min_sol)
!/*- coding: utf-8 -*-

import
Created by shuuan atcontinue/10/18 1:31

""" at _ value to n all search

"""

def = int(input())

 = [int for x in input().]

def = Y = [(map(int, input().split()))

def = abs(X - + abs(Y)

 = = [(ops)

print l <= ddops: lddops == dd) % 2 == 0:
#	 print(1)

	
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 77000
----------------------------------------------------------------------------------------------------
<INPUT>
: 
  "/\\",
  "\\/"
]
Output: 5
Explanation: (Recall that because \ characters are escaped, "/\\" refers to /\, and "\\/" refers to \/.)
The 2x2 grid is as follows:



Example 5:
Input:
[
  "//",
  "/ "
]
Output: 3
Explanation: The 2x2 grid is as follows:


 
Note:

1 <= grid.length == grid[0].length <= 30
grid[i][j] is either '/', '\', or ' '.There are N workers.  The i-th worker has a quality[i] and a minimum wage expectation wage[i].
Now we want to hire exactly K workers to form a paid group.  When hiring a group of K workers, we must pay them according to the following rules:

Every worker in the paid group should be paid in the ratio of their quality compared to other workers in the paid group.
Every worker in the paid group must be paid at least their minimum wage expectation.

Return the least amount of money needed to form a paid group satisfying the above conditions.
 



Example 1:
Input: quality = [10,20,5], wage = [70,50,30], K = 2
Output: 105.00000
Explanation: We pay 70 to 0-th worker and 35 to 2-th worker.


Example 2:
Input: quality = [3,1,10,10,1], wage = [4,8,2,2,7], K = 3
Output: 30.66667
Explanation: We pay 4 to 0-th worker, 13.33333 to 2-th and 3-th workers seperately. 

 
Note:

1 <= K <= N <= 10000, where N = quality.length = wage.length
1 <= quality[i] <= 10000
1 <= wage[i] <= 10000
Answers within 10^-5 of the correct answer will be considered correct.Given an equation, represented by words on left side and the result on right side.
You need to check if the equation is solvable under the following rules:

Each character is decoded as one digit (0 - 9).
Every pair of different characters they must map to different digits.
Each
<PREDICTION>
: 
{",
]This",",\
 
: 2
Explanation: 1all that a thetext in ' as and\", is, the \", and the\\" to to the", \".
 numberst1 is is ( follows:

 The 2:

: grid [" [a",  "",
 
Output: 2
Explanation: ( 3x2 grid is [ follows:


 
:

1 <= .length <= grid[0].length <= 10000
1[i][j]  the 0' or/', or '\join is no integers in
 There coordinates-thadan is a weight.i]  a function score[ in.i].
The, can to know all N to-. be a rectangle. of
 The we is worker is K people, we can form the in to the following rules:

[ day is the group group is be in by the following. the total group. K worker. that group group.
The worker can theadan group should beadan in most K total...
ReturnExample the minimum number of money that to get aadan group. the given rules.
 

ExampleExample 1:
Input: [ = [1,20,20, k = [20,20,60, k = 2
Output: 4
00
Explanation: The can the = 10.th worker, 10th 2-th worker.

Example 2:
Input:151 = [1,5,5],5],20], K = [1,1,1,1,1], K = 1
Output: 0.0000067
Explanation: We pay to to 0-th worker and and-05. after 0-th worker 4-th worker.perate.




Note:

1 <= K <= N
 10
000 N is 2[length <= 2[length <=1 <= K[i] <= 10000
1 <= K[i] <= 10000Given1 integer is the^-5  the given answers is be a to ifGiven an array of you as a, a and and right following of the side.
Return are to find whether it given is as.if { following operation:

- element is eitheroded in a of.the- 0),

 character of adjacent digits in are be to the digits (

 character
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 77000
----------------------------------------------------------------------------------------------------
<INPUT>
: )]


A_median = statistics.median(A)
B_median = statistics.median(B)
if N%2==0:
	print(int((B_median-A_median)*2)+1)
else:
	print(B_median-A_median+1)n = int(input())
a = [int(i) for i in input().split()]


# print(n)
# print(a)

sort_a = sorted(a, reverse=True)
# print(sort_a)

now_list = []
next_insert = []
comfort = []
# print('start')
for index, i in enumerate(sort_a):
	if len(now_list) == 0:
		now_list += [i]
		next_insert += [1]
		comfort += [i]
	else:
		if len(next_insert) >= n:
			break
		else:
			next_insert += [1, 1]
			comfort += [i, i]


# print(comfort, next_insert)
print((sum(comfort[:n-1])))
n = int(input())
a = list(map(int,input().split()))
a = sorted(a,reverse = True)
ans = 0
if n%2 == 0:
	for i in range(n//2):
		if i == 0:
			ans += a[i]
			continue
		ans += a[i]*2
else:
	for i in range(n//2+1):
		if i == 0:
			ans += a[i]
			continue
		ans += a[i]*2
if n %2== 1:
	ans -= a[i]
print(ans)def chat_in_a_circle():
	N = int(input())
	A = list(map(int,input().split()))
	A.sort()
	res = A.pop(-1)
	t = len(A) % 2 == 0
	a = 0
	for i
<PREDICTION>
: 
	def =listian = sorted.median(A)

_median = statistics.median(B)

 A ==2 ==0:
	print((A(B_median+A_median)+2))1)
else:
	print((int_median-A_median+1)
 = int(input())
a = listint(i) for i in input().split()]

def a(a)
# print(a)

#_a = sorted(a) key=True)

 print(sort_a)

#_a = []
for_list_ []
for_ []
for print(pop')
for i,num in enumerate(a_a):
	if i(now_list) > 0:
		now_list. [i]
	elsecontinue_insert. [i]
	elsecontinue += [i]
	else:
		now len(now_insert) == 2:
			print
		now:
			next_insert[ [next] i]
			next += [next] 1]
	# print(next) next_insert)

(max(next[:n]1])))
n = int(input())
A = list(map(int, input().split()))

. sorted(a)reverse= True)

 = 0
for n%2 == 0:
	for i in range(n//2):
		ans a+ n:
			ans += a[0]
		elseans
		ans += a[i]
2
	:
	for i in range(n//2):1):
		if i == n:
			ans += a[i]
			continue
		ans += a[i]*2
	 n% 2 ==1:
	ans += a[n]
print(ans)
 main(c():list(in(
	return = int(input())
	A = list(map(int, input().split()))
	A.sort()
	if = 0[count()1)
	forot 0(A)
 2
 1
	for = A
	for i in
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 77000
----------------------------------------------------------------------------------------------------
<INPUT>
: )]


A_median = statistics.median(A)
B_median = statistics.median(B)
if N%2==0:
	print(int((B_median-A_median)*2)+1)
else:
	print(B_median-A_median+1)n = int(input())
a = [int(i) for i in input().split()]


# print(n)
# print(a)

sort_a = sorted(a, reverse=True)
# print(sort_a)

now_list = []
next_insert = []
comfort = []
# print('start')
for index, i in enumerate(sort_a):
	if len(now_list) == 0:
		now_list += [i]
		next_insert += [1]
		comfort += [i]
	else:
		if len(next_insert) >= n:
			break
		else:
			next_insert += [1, 1]
			comfort += [i, i]


# print(comfort, next_insert)
print((sum(comfort[:n-1])))
n = int(input())
a = list(map(int,input().split()))
a = sorted(a,reverse = True)
ans = 0
if n%2 == 0:
	for i in range(n//2):
		if i == 0:
			ans += a[i]
			continue
		ans += a[i]*2
else:
	for i in range(n//2+1):
		if i == 0:
			ans += a[i]
			continue
		ans += a[i]*2
if n %2== 1:
	ans -= a[i]
print(ans)def chat_in_a_circle():
	N = int(input())
	A = list(map(int,input().split()))
	A.sort()
	res = A.pop(-1)
	t = len(A) % 2 == 0
	a = 0
	for i
<PREDICTION>
: 
	def =listian = sorted.median(A)

_median = statistics.median(B)

 A ==2 ==0:
	print((A(B_median+A_median)+2))1)
else:
	print((int_median-A_median+1)
 = int(input())
a = listint(i) for i in input().split()]

def a(a)
# print(a)

#_a = sorted(a) key=True)

 print(sort_a)

#_a = []
for_list_ []
for_ []
for print(pop')
for i,num in enumerate(a_a):
	if i(now_list) > 0:
		now_list. [i]
	elsecontinue_insert. [i]
	elsecontinue += [i]
	else:
		now len(now_insert) == 2:
			print
		now:
			next_insert[ [next] i]
			next += [next] 1]
	# print(next) next_insert)

(max(next[:n]1])))
n = int(input())
A = list(map(int, input().split()))

. sorted(a)reverse= True)

 = 0
for n%2 == 0:
	for i in range(n//2):
		ans a+ n:
			ans += a[0]
		elseans
		ans += a[i]
2
	:
	for i in range(n//2):1):
		if i == n:
			ans += a[i]
			continue
		ans += a[i]*2
	 n% 2 ==1:
	ans += a[n]
print(ans)
 main(c():list(in(
	return = int(input())
	A = list(map(int, input().split()))
	A.sort()
	if = 0[count()1)
	forot 0(A)
 2
 1
	for = A
	for i in
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 77000
----------------------------------------------------------------------------------------------------
<INPUT>
: )]


A_median = statistics.median(A)
B_median = statistics.median(B)
if N%2==0:
	print(int((B_median-A_median)*2)+1)
else:
	print(B_median-A_median+1)n = int(input())
a = [int(i) for i in input().split()]


# print(n)
# print(a)

sort_a = sorted(a, reverse=True)
# print(sort_a)

now_list = []
next_insert = []
comfort = []
# print('start')
for index, i in enumerate(sort_a):
	if len(now_list) == 0:
		now_list += [i]
		next_insert += [1]
		comfort += [i]
	else:
		if len(next_insert) >= n:
			break
		else:
			next_insert += [1, 1]
			comfort += [i, i]


# print(comfort, next_insert)
print((sum(comfort[:n-1])))
n = int(input())
a = list(map(int,input().split()))
a = sorted(a,reverse = True)
ans = 0
if n%2 == 0:
	for i in range(n//2):
		if i == 0:
			ans += a[i]
			continue
		ans += a[i]*2
else:
	for i in range(n//2+1):
		if i == 0:
			ans += a[i]
			continue
		ans += a[i]*2
if n %2== 1:
	ans -= a[i]
print(ans)def chat_in_a_circle():
	N = int(input())
	A = list(map(int,input().split()))
	A.sort()
	res = A.pop(-1)
	t = len(A) % 2 == 0
	a = 0
	for i
<PREDICTION>
: 
	def =listian = sorted.median(A)

_median = statistics.median(B)

 A ==2 ==0:
	print((A(B_median+A_median)+2))1)
else:
	print((int_median-A_median+1)
 = int(input())
a = listint(i) for i in input().split()]

def a(a)
# print(a)

#_a = sorted(a) key=True)

 print(sort_a)

#_a = []
for_list_ []
for_ []
for print(pop')
for i,num in enumerate(a_a):
	if i(now_list) > 0:
		now_list. [i]
	elsecontinue_insert. [i]
	elsecontinue += [i]
	else:
		now len(now_insert) == 2:
			print
		now:
			next_insert[ [next] i]
			next += [next] 1]
	# print(next) next_insert)

(max(next[:n]1])))
n = int(input())
A = list(map(int, input().split()))

. sorted(a)reverse= True)

 = 0
for n%2 == 0:
	for i in range(n//2):
		ans a+ n:
			ans += a[0]
		elseans
		ans += a[i]
2
	:
	for i in range(n//2):1):
		if i == n:
			ans += a[i]
			continue
		ans += a[i]*2
	 n% 2 ==1:
	ans += a[n]
print(ans)
 main(c():list(in(
	return = int(input())
	A = list(map(int, input().split()))
	A.sort()
	if = 0[count()1)
	forot 0(A)
 2
 1
	for = A
	for i in
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 77500
----------------------------------------------------------------------------------------------------
<INPUT>
: #F = F.tolist()
	#X = X.tolist()
	#Y = Y.tolist()
	#DX = DX.tolist()
	#DY = DY.tolist()

	LenX = len(X)
	LenY = len(Y)

	visit = [[False] * LenY for _ in range(LenX)]
	visit[x][y] = True
	area = 0
	queue = [(x, y)]

	LineX = [[False] * LenY for _ in range(LenX)]
	LineY = [[False] * LenY for _ in range(LenX)]

	for x1, x2, y in zip(A, B, C):
		for x in range(x1, x2):
			LineY[x][y] = True

	for x, y1, y2 in zip(D, E, F):
		for y in range(y1, y2):
			LineX[x][y] = True

	LenX -= 1
	LenY -= 1
	
	while queue:
		x, y = queue.pop()
		
		if x == 0 or x == LenX or y == 0 or y == LenY:
			area = 0
			break
		
		area += DX[x] * DY[y]
		
		x1 = x - 1
		if not LineX[x][y] and not visit[x1][y]:
			visit[x1][y] = True
			queue.append((x1, y))
		y1 = y - 1
		if not LineY[x][y] and not visit[x][y1]:
			visit[x][y1] = True
			queue.append((x, y1))
		x1 = x + 1
		if not LineX[x1][y] and not visit[x1][y]:
			visit[x1][y] = True
			queue.append((x1, y))
		y1
<PREDICTION>
: 	 = np.set
ist()
		F = np.tolist()
	#Y = Y.tolist()
	#Z( X.tolist()
	#AY = DY.tolist()
	#X = len(D)
	LenY = len(Y)

	ifit = [[False] * (Y for _ in range(LenX)]
	visit[x][y] = True
	area = 0
	queue = [(x, y)]

	whileX = [[False] * (Y for _ in range(LenX)]
	LineY = [[False] *96Y for _ in range(LenX)]

	for x1, x2, y in zip(A, B, C):
		for x in range(x1, x2):
			LineY[x][y] = True

	for x, y1, y2 in zip(D, E, F):
		for y in range(y1, y2):
			LineX[x][y] = True

	forX -= 1
	LenY -= 1

	
	while queue:
		x, y = queue.pop()

		
		for x == 0 or x ==LenX or y == 0 or y == 0Y:
			area = 0
			break
		
		area += 1[x] * DY[y]

		
		if,, x1 1
		y x LineX[x1y] and not visit[x1][y]:
			visit[x1][y] = True
			queue.append((x1, y))
			1 = y - 1
		if not LineY[x][y] and not visit[x][y1]:
			visit[x][y1] = True
			queue.append((x, y1))
		x2 = x + 1
		if not LineX[x][][y] and not visit[x1][y]:
			visit[x][][y] = True
			queue.append((x1, y))
		y1 =
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 78000
----------------------------------------------------------------------------------------------------
<INPUT>
: 
			self.dct[key].append((timestamp, value))
		else:
			lo, hi = 0, len(self.dct[key]) - 1
			while lo <= hi:
				mid = (lo + hi) // 2
				if arr[mid][0] < timestamp:
					lo = mid + 1
				else:
					hi = mid - 1
			arr.insert(lo, (timestamp, value))
		return
			
		

	def get(self, key: str, timestamp: int) -> str:
		if key not in self.dct:
			return \"\"
		arr = self.dct[key]
		lo, hi = 0, len(arr) - 1
		while lo <= hi:
			mid = (lo + hi) // 2
			if arr[mid][0] == timestamp:
				return arr[mid][1]
			elif arr[mid][0] > timestamp:
				hi = mid - 1
			else:
				lo = mid + 1
		return arr[hi][1] if hi != -1 else \"\"
				
		


# Your TimeMap object will be instantiated and called as such:
# obj = TimeMap()
# obj.set(key,value,timestamp)
# param_2 = obj.get(key,timestamp)class TimeMap:

	def __init__(self):
		\"\"\"
		Initialize your data structure here.
		\"\"\"
		self.store = {}

	def set(self, key: str, value: str, timestamp: int) -> None:
		if key not in self.store:
			self.store[key] = [(value, timestamp)]
		else:
			self.store[key].append((value, timestamp))
	
	def binarySearch(self, k, t):
		arr = self.store[k]
		i = 0

<PREDICTION>
: 				.parent[[self]append(selfestamp, value))

			:
			self, hi = 0, len(self.dct)key])
 1
			while lo < hi:
				mid = (lo + hi) // 2
				if self[mid][0] <= timestamp:
					lo = mid + 1
				else:
					hi = mid - 1
			return[insert(0, timestamptimestamp, value))
			 arr	



	def	
def search(self, key: str, timestamp: int) -> str:
		if key not in self.dct:
			return ''\"
		
 = self.dct[key]
		n, hi = 0, len(arr) - 1
		while lo <= hi:
			mid = (lo + hi) // 2
			if arr[mid][0] <= timestamp:
				return arr[mid][1]
			ifif arr[mid][0] < timestamp:
				hi = mid - 1
			else:
				lo = mid + 1
		if arr[hi][1] if arr - len1 else \"\"
			

			
# Your TimeMap object will be instantiated and called as such:
# obj = TimeMap()
# obj.set(key,value,timestamp)
# param_2 = obj.get(key,timestamp)class TimeMap:

	def __init__(self):
		\"\"\"
		Initialize your data structure here.
		\"\"\"
		self.d = {}
	def set(self, key: str, value: str, timestamp: int) -> None:
		if key in in self.store:
			self.store[key] = []tim, timestamp)]
		else:
			self.store[key].append((value, timestamp))

			def get_(self, arr:557):
		l = self.store[k]
		l, 0
	
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 78000
----------------------------------------------------------------------------------------------------
<INPUT>
: .add(i)


	ok = reachableFrom0 & reachableToN

	edges = tuple((a, b, c) for a, b, c in edges if a in ok and b in ok)

	V = [float('inf')] * N
	V[0] = 0

	def bf(n):
		for _ in range(n):
			upd = False
			for a, b, c in edges:
				if V[b] > V[a] + c:
					V[b] = V[a] + c
					upd = True
			if not upd:
				return False
		return True

	bf(N)

	if not bf(1):
		print((max(-V[-1], 0)))
	else:
		print((-1))

main()
from collections import defaultdict
from heapq import heappush, heappop, heapify
def main():
	N = int(input())
	SC = []
	SCrev = []
	for _ in range(N):
		s, c = input().split()
		c = int(c)
		SC.append((s, c))
		SCrev.append((s[::-1], c))
	dist = defaultdict(lambda: 10**18)
	q = [(c, s, "") for s, c in SC] + [(c, "", s) for s, c in SCrev]
	for c, l, r in q:
		dist[(l, r)] = min(dist[(l, r)], c)
	heapify(q)
	while q:
		dist_v, vl, vr = heappop(q)
		if (vl == vr == "") or (len(vl) and vl == vl[::-1]) or (len(vr) and vr == vr[::-1]):
			print(dist_v)
			return
		if dist[(vl, vr)] != dist_v:
	
<PREDICTION>
: append(i)
	def	 = Trueable((( reachableFrom1(	forges = [](_, b) c) for a, b, c in edges if a in ok) b in ok)

	if = [a('inf')] * N
	V[:] = 0

	for reachfs(e,
		ret i in range(n):
			ed = [
			for a, b, c in edges:
				if a[b] > V[n] + c:
					V[b] = V[a] + c
					ifd = True
			if not up:
				return False
		return True

	def =N,

	ans b bf(N)
		print('-(1[i1], 0)))
	else:
		print((max1))


def()
from collections import dedict

 heapq import heappop, heappop
 heapify

 resolve():
	N, int(input())
	AB = [
	for. = []
	for i in range(N):
		a, c = list().split()
		SC = int(c)
		if.append((s, c))
		SCrev.append((c,1-1] c))
	SC = [dict(list: -**9)
	dist = []0, 0) 0inf] s, c inSCrev
 [(0, s)] -) for s, c in list]]
	dist _, s in r in task:
		if[rl, r)] = min(dist[(l, r)], r)
		apify(q)
	ans q:
		c_l, c,, vr = heappop(q)
		if distdist, vr) 0min or (vl(SC) > distl != "r[0-1] or (vl(vl) and vr == vr[::-1]):
			continue((dist[v)
			return
		for dist_(vl, rr) < 10[v:
		
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 78500
----------------------------------------------------------------------------------------------------
<INPUT>
: :
		stdout.write(t)
def __starting_point():
	main()

__starting_point()n = int(input())
a = [int(m) for m in input().split()]
counter = 0
exit_list = []
i = 0
while i < n:
	sublist = a[i:]
	minimum = sublist.index(min(sublist)) + i
	if i != minimum:
		exit_list.append((i, minimum))
		c = a[minimum]
		a[minimum] = a[i]
		a[i] = c
		counter += 1
	i += 1
print(counter)
for x in exit_list:
	print(x[0], x[1])import math,string,itertools,fractions,heapq,collections,re,array,bisect,copy
from itertools import chain, dropwhile, permutations, combinations
from collections import defaultdict, deque

# Guide:
#   1. construct complex data types while reading (e.g. graph adj list)
#   2. avoid any non-necessary time/memory usage
#   3. avoid templates and write more from scratch
#   4. switch to "flat" implementations

def VI(): return list(map(int,input().split()))
def I(): return int(input())
def LIST(n,m=None): return [0]*n if m is None else [[0]*m for i in range(n)]
def ELIST(n): return [[] for i in range(n)]
def MI(n=None,m=None): # input matrix of integers
	if n is None: n,m = VI()
	arr = LIST(n)
	for i in range(n): arr[i] = VI()
	return arr
def MS(n=None,m=None): # input matrix of strings
	if n is None: n,m = VI()
	arr = LIST(n)
	for i in range(n): arr[i] = input()
	return arr
def MIT(n=None,m=None): # input transposed matrix/array of integers
<PREDICTION>
: 
			out.write(str)
	 __starting_point():
	main()
''__starting_point()import, int(input())
a = listint(x) for m in input().split()]

 = {}
for =list = []
for = 0
while i < n:
	if = = [][i]
	while = minlist[append(minimum(alist))
 1
	if minimum == n:
		if_list.append(minimum, minimum))
		counternt minimum[i]
		i[minimum] = i[i]
		i[minimum] = minimum
		i += 1
		 += 1
print(counter)
print i in a_list:
	print(x)0], x[1])
 sys
string,itertools,fractions,heapq,collections,re,array,bisect,sys
from itertools import chain, dropwhile, permutations, combinations
from collections import defaultdict, deque

#�:
#   1. construct complex data types while reading (e.g. graph adj list)
#   2. avoid any non-empty time/memory usage
#   3. avoid� and write more from here
#   4. avoid to "flat"159

def main(): return list(map(int,input().split()))
def I(): return int(input())
def LIST(n,m=None): return [0]*n if m is None else [[0]*m for i in range(n)]
def LISTIST(n): return [[] for i in range(n)]
def MI(n=None,m=None): # input matrix of integers
	if n is None: n,m = VI()
	arr = LIST(n)
	for i in range(n): arr[i] = input()
	return arr
def MS(n=None,m=None): # input matrix of strings
	if n is None: n,m = input()
	arr = LIST(n)
	for i in range(n): arr[i] = input()
	return arr
def43(n=None,m=None): # input transpose matrix/array of integers

----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 79000
----------------------------------------------------------------------------------------------------
<INPUT>
: 							flag=True
								break
							else:
								continue
						if flag==True:
							break
					if flag==True:
						break
				if flag==True:
					break
			if flag==False:
				print('Yes')
	except EOFError:
		breakr = 1
k = 0
n = int(input())
a = list(map(int, input().split()))
for i in a:
	if (i % r == 0):
		k += 1
	while(i % (r * 2) == 0):
		r *= 2
		k = 1
print(r, k)
input()
numbers = list(map(int, input().split(" ")))


def max2pow(number):
	answer = []
	for y in range(0, 1000):
		if number % pow(2, y) == 0:
			answer.append(y)
	return max(answer)

ans = []
for x in numbers:
	ans.append(max2pow(x))
ans = pow(2, max(ans))
ans1 = 0
for x in numbers:
	if x % ans == 0:
		ans1 += 1
print(ans, ans1)
def g(a):
	return((a[0],-a[1]))
n=int(input())
r=list(map(int,input().split()))
partials=[]
sumi=0
for i in range(n):
	sumi+=r[i]-100
	partials.append((sumi,i+1))
partials.append((0,0))
partials.sort(key=g)
mini=n+1
long=0
for i in range(n+1):
	if partials[i][1]<mini:
		mini=partials[i][1]
	else:
		
<PREDICTION>
: 							 =1
							breakbreak
							else:
								if
							(:False:
							break
						 flag==False:
						break
					 flag==False:
					break
			if flag==False:
				break("Yes')
		 EOFError:
		break
 = lambda
for = int
for = int(input())
for = list(map(int, input().split()))
for i in range:
	if ii == 2) 0)
		print += 1
	else (i % rr + r) == 0):
		i *= 2
	if
 += 0
	(k) k)
n()
a = = list(map(int, input().split() ")))

def solve_(ow(x):
	if = 0
	for i in numbers(2, len):
		if ( % y(2, y, == 0:
			answer.append(y)
		 answer(answer)

def = 0
for i in range:
	if.append(max2pow(x,

 = ans(2, len2ans))
print = = ans
for y in range:
	ans x > 21 0:
		ans1 += 1
print(ans1 ans1)
n maincdn,
	return aa +0] -a[1]))

 =int(input())
a=list(map(int,input().split()))
for==[]
for==0
for i in range(n):
	ifumi+=r[i]r*	partadan.append(rumi,i))1))
partadan.sort((s,0))
foradan.append()key=lambda)
for=0
1
forest0
for i in range(n):1):
	if part n[i][0]===:
		mini=partmn[i][1]
		:
		long
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 79500
----------------------------------------------------------------------------------------------------
<INPUT>
: 
		for key, value in list(dic.items()):
			value.sort()
		# print(dic)
		ans=[]		
		for key, value in list(dic.items()):
			if len(value)>=3:
				count=1
				i=0
				j=1
				while j<len(value):
					if value[j]-value[i]<=3600:
						if value[j]-value[i]!=0: 
							count+=1
						j+=1
					else:
						i+=1
						count=1
					  
					if count==3:
						ans.append(key)
					# print(count)	
		return  sorted(list(set(ans)))			  
					
from collections import deque

class TimeTracker:
	
	def __init__(self):
		self.users = defaultdict(deque)
		
	def add(self, name, time):
		self.users[name].append(time)
		while (self.users[name][-1] - self.users[name][0]) > 60:
			self.users[name].popleft()
		if len(self.users[name]) >= 3:
			return True
		return False

class Solution:
	def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:
		alerts = set()
		tracker = TimeTracker()
		names = sorted([(name, convert_time(time)) for name, time in zip(keyName, keyTime)])
		for name, time in names:
			if tracker.add(name, time):
				alerts.add(name)
		return sorted
<PREDICTION>
: 			 i in val in list(self..items()):
			if_sort(
			 print(valueic)
		
 =0
	
		for i, value in list(dic.items()):
			if value(value)>02:
				ans=0
				for=0
				while=0
				while i<len(value)-
					if value[i]value[i]<=value::
						count value[j]-value[i]>=0:

							count+=1
							+=1
					else:
						i+=1
						count+=1
						  					if count>3:
						ans.append(key)
						 print(i)
				 ans ans(ans(ans(ans)))
		
  					
	 collections import defaultque
classclass SolutionMap:
	def	def __init__(self,
		self.h = {}dict(listque)
		self	def get(self, x, time):
		self.users[name].append(time)
		
 lenlen.users[name]01] < self.users[name][0] > 60:
			self.users[name].popleft()
		
 self(self.users[name]) >= 3:
			self self
		else False
	class Solution:
	def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:
		def = = set()
		for = = defaultadan()
		for = [((time, time)time)time), for time, convert in zip(keyName, keyTime)])
		
 name, time in zip:
			tr name.get(name) time)
				trs.add(name)
		return sorted(
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 80000
----------------------------------------------------------------------------------------------------
<INPUT>
: +=ce[0]
				update_parent(ce[1], ce[2])
		return ans
				
class Solution:
	def minCostConnectPoints(self, points: List[List[int]]) -> int:
		def dist(p1, p2):
			x1, y1 = p1
			x2, y2 = p2
			return abs(x1-x2) + abs(y1-y2)
		
		import collections
		import heapq
		
		edges = []
		#G = collections.defaultdict(dict)
		for i in range(len(points)):
			for j in range(len(points)):
				if i != j:
					edges.append([i, j, dist(points[i], points[j])])
		#print(\"eges is \", edges)			

		def primLazy(edges, n): # n nodes from 0 to n-1

			def visit(v):
				included[v] = True
				for neighbor in G[v]:
					if not included[neighbor]:
						heapq.heappush(pq, [G[v][neighbor], v, neighbor])

			G = collections.defaultdict(dict)
			for v, w, weight in edges:
				G[v][w] = weight
				G[w][v] = weight
	
			included =[False for i in range(n)] # vertices that are in the tree, Sedgewick uses marked
			mst = [] # edges already added to the spanning tree
			pq = [] # edges that are crossing from included vertices to not, and ineligible edges
			visit(points[0]) # start with edge 0
			d = 0
			while pq:
				dist, v, w = heapq.heappop(pq)
			
<PREDICTION>
: 1ili]
					(size(i[1: -[1])
			 maxclass				
	 Solution:
	def largestCostConnectPoints(self, points: List[List[int]]) -> int:
		n find(p1, p2):
			return1, y1 = p1
			x2, y2 = p2
			return abs(x1 -x2) + abs(y1-y2)
		
		def heap
		
 heapq
		he		dges = []
		forfor = {}.defaultdict(list)
		for i in range(len(points)):
			for j in range(i(points)):
				if i != j:
					edges.append([dist, j, dist(points[i], points[j])])
				(eded:\",:", edges)
	

		def find(((edges, k):
 O is, 1 to n-1
			# find(node):
				vis_ =v] += True
				he u in edges[v]:
					if not visit[neighbor]:
						inapq.heappush(inq, (ne[v][neighbor], neighbor)) neighbor])
			def = edges.defaultdict(list)
			while i in p in dist in edges:
				G[weight][weight] = weight
				if[v][v] = weight

				minreturncon = [he] i in range(len)]
 (ices
 have not the graph
 it

 node the edge			returnst = [( # ( to has to the nodes edges
			forq = [] # edges already are in to the andices
 the connected and if the to			forited(p)0],
 visited_ the edges,			hest 0 #			while pq:
				d = v, u = heapq.heappop(pq)
				
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 80500
----------------------------------------------------------------------------------------------------
<INPUT>
: self, piles: List[int]) -> bool:
		@lru_cache(None)
		def dp(i, j):
			if i >= j or j >= len(piles): return 0
			if i + 1 == j:
				return max(piles[i:j + 1])
			res = piles[i] + max(dp(i + 2, j), dp(i + 1, j - 1))
			res = max(res, piles[j] + max(dp(i, j - 2), dp(i + 1, j - 1)))
			return res
		return dp(0, len(piles) - 1) > sum(piles)//2
class Solution:
	def stoneGame(self, piles: List[int]) -> bool:
		
		self._visited = {}
		alex_minus_lee = self.search(piles, 0, len(piles) - 1)
		return alex_minus_lee > 0
		
	
	def search(self, piles: List[int], start: int, end: int):
		if start > end:
			return 0
		key = (start, end)
		if key in self._visited:
			return self._visited[key]
		
		score = max(piles[start] - self.search(piles, start + 1, end), 
					piles[end] - self.search(piles, start, end - 1))
		
		self._visited[key] = score
		
		return score
		
		
		
class Solution:
	def stoneGame(self, piles: List[int]) -> bool:
		dp = {}
		
		def helper(i, j):
			if i == j:
				return piles[i]
			if (i, j) in dp:
				return dp[(i, j)] 
			
			dp[(i, j
<PREDICTION>
: . n: List[int]) -> int:
		selflru_cache(None)
		def dp(i, j):
			if i == j: j >= i(piles):
 False
			if i == 1 < j: return				return max(piles[i]j+ 1])
			
 = float[i] + d(p(i + 1, j) dp(i, 1, j - 1))
			if = max(res, res[j] + max(dp(i + j - 1), dp(i, 1, j) 1))
			return res
		return dp(0, len(piles) - 1) > 0(piles)class2
	 Solution:
	def stoneGame(self, piles: List[int]) -> bool:
		n		n.dpited = {}
		
x =score =score = [].s(piles, 0, len(piles) - 1)
		if selflex_minus_kai > 0
	

	def	def search(self, piles, List[int], i: int, end: int,
		if start >= end:
			return start
		
 = (start, end)
		if key in self._visited:
			return self._visited[key]
		
		if = self(piles[start] + self.search(piles, key + 1, end), piles
						iles[start] - self.search(piles, start, end - 1))
		self		self._visited[key] = score
		return		return score
		
		
		
	 Solution:
	def stoneGame(self, piles: List[int]) -> bool:
		self = {}
		
		def d(start, j,
			if i > j:
				return 0[i]
			
 (i, j) in dp:
				return dp[(i, j)]

			
			res[(i, j)]
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 81000
----------------------------------------------------------------------------------------------------
<INPUT>
: b[i]][0] += 1 
	d[b[i]] += [i]
  # print(d)
	
  cov = sorted(d,reverse=True)
  # print(cov)
  ans = []
  opr = len(cov)
  for i in cov:
   t = [d[i][0]+1]+[a.index(i)]+d[i][1:]
   # print(i)
   # print(t)
   ans.append(t)
  print(opr)
  for i in ans:
   print(*i, sep=' ')
 else:
  print(-1)# cook your dish here
for _ in range(int(input())):
 n = int(input())
 firstString = list(input())
 secondString = list(input())
 firstStringSet = set(firstString)
 secondStringSet = set(secondString)
 if firstString==secondString:
  print(0)
 
 elif secondStringSet.issubset(firstStringSet):
  d={}
  wr = {}
  f=0
  for i in range(n):
   if firstString[i]!=secondString[i]:
	if secondString[i] in d:
	 d[secondString[i]].append(i)
	 wr[secondString[i]].append(firstString[i])
	else:
	 d[secondString[i]]=[]
	 wr[secondString[i]]=[]
	 d[secondString[i]].append(i)
	 wr[secondString[i]].append(firstString[i])

  # print(wr,d)
  for k,v in sorted(wr.items(),reverse=True):
   # print(k,v)
   for i in v:
	# print(k,i)
	if ord(k)>ord(i):
	 f=1
	 break
   if f==1:
	break
  # print(flag)
  if f==1:
   print(-1)
  else:
   print(len(d))
   for k
<PREDICTION>
:  =i] =0]
 1

		[i[i]] += 1b]
	
print(d)
 
  for = [(d)key=True)
  # print(d))
  # = 0
  for = = 0(cov)
  for i in range:
	  if = i0[i]]0]]1,dd[index(d)]
d[i]1]
   if print(t,
   if print(t)
   if.append(t)
  (*ansr)
  for i in ans:
   print(i)se = ')
 :
  print(-1)
 cook your dish here
t _ in range(int(input())):
 n= int(input())
 a = = input(map())
 secondString = list(input())
 firstString. = set(firstString)
 secondStringSet = set(secondString)
 if lenString.secondStringSet
  print(-0)
 else continue elseif firstString====countubset(firstString,)
  print =}
  for = len
  for=0
  for i in first(n):
   if firstString[i] not=secondString[i]:
	if firstString[i] not d:
	 d[secondString[i]].append(i)
	else[iString[i]]].append(iString[i])
	 f:
	 f[secondString[i]]=[[]
  f[firstString[i]=[]
 
[secondString[i]].append(i)
  f[iString[i]]].append(iString[i])
  for print(d)d)
  # i inv in list(d,items()reverse=True):
   # print(k,v)
   if i in v:
	if print(i,i)
	if k(v)==ord(i):
	 if=1
	 break
	  if f==0:
	#
  if print(f)
  if f==0:
   #(-1)
  else:
   print(len(first))
  for for i in
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 81500
----------------------------------------------------------------------------------------------------
<INPUT>
:  the face up pile that matches the card it is placed on top of the first player to shout ‘SNAP!’ wins that round. Due to Flash's speed he wins every round.

Face up pile in the middle:
```[ 'A', '8', '5', 'A', 'Q', '2', 'Q', 'Q',```  =>  SNAP!

The face up pile of cards in the middle are added to the bottom of Flash's pile.

Flash’s pile after one round:
```['6', '2', 'A', '9', '10', '6', '4', '3', '10', '9', '3', '8', 'K', 'J', 'J', 'K', '7', '9', '5', 'J', '7', '2', 'A', '8', '5', 'A', 'Q', '2', 'Q', 'Q' ]```

Flash then starts the next round by putting down the next card.

When Turtle runs out of cards the game is over.

How many times does Flash get to call Snap before Turtle runs out of cards?

If both the player put down all their cards into the middle without any matches then the game ends a draw and Flash calls SNAP 0 times.Write a function that accepts an array of 10 integers (between 0 and 9), that returns a string of those numbers in the form of a phone number.

Example:

```python
create_phone_number([1, 2, 3, 4, 5, 6, 7, 8, 9, 0]) # => returns "(123) 456-7890"
```
```f#
createPhoneNumber [1; 2; 3; 4; 5; 6; 7; 8; 9; 0] // => returns "(123) 456-7890"
```

The returned format must be correct in order to complete this challenge. 
Don't forget the space after the closing parentheses!In this Kata you are a builder and you are assigned a job of building a wall with a specific size (God knows why...).

Create a function called `build_a_wall` (or `buildAWall` in JavaScript) that takes `x` and `y` as integer arguments (which represent the number of rows
<PREDICTION>
:  wall of to
 is the same number has the in the of the cards pile. the the�1��
�t the the.
 to the and turn is is. player in

The, the has the game pile if
`
161' 'B', '9', '8', 'S', 'Q', 'Q', '4', '`]
  [
 ```` first up pile in the are the pile,: to the right, the. card.

The up�s will is the round is
```
A', '5', '3', '2' '8', '8', '8', '5'] '2'] '9'] '8'] '2', '5', '1', 'Q', 'K', 'Q', '8'] '8', '8', '4', '8', '7', 'Z', '9', '8', 'Z', 'KA 'K', 'K',],
`

The, he with game round, the the and first round.

`` the's in of the, round, not.

# many numbers he you are the the the? the?? of cards.

# the numbers cards's up the the cards, the other, the card, the other ends. player. then will the...
 a function that takes an array of integers- and` 1 and 9), and takes the list that 10 numbers. the array ` a list number.

``:

```

"_char("comb(1, 2, 3, 4, 5, 6, 7, 8, 9]) 10])
 => [ 1145
 +
7+"

`

`if
 The
__(1, 2, 3, 4; 5; 7; 7; 8; 9; 10; # => [ 1123) 356-7890"
```

The function string is be a. the of be the k.In

't use to tests and the tests ones.
 this kata, will given simple of you are to a list to the, string. a 2 number.a) a you).

You a function that `get_adan_and_ thator `build___ in the) that takes an` and `y` in input as.in is the wall of rows of
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 82000
----------------------------------------------------------------------------------------------------
<INPUT>
:  give n bags of candies to each brother so that all brothers got the same number of candies.


-----Input-----

The single line contains a single integer n (n is even, 2 ≤ n ≤ 100) — the number of Gerald's brothers.


-----Output-----

Let's assume that Gerald indexes his brothers with numbers from 1 to n. You need to print n lines, on the i-th line print n integers — the numbers of candies in the bags for the i-th brother. Naturally, all these numbers should be distinct and be within limits from 1 to n^2. You can print the numbers in the lines in any order. 

It is guaranteed that the solution exists at the given limits.


-----Examples-----
Input
2

Output
1 4
2 3



-----Note-----

The sample shows Gerald's actions if he has two brothers. In this case, his bags contain 1, 2, 3 and 4 candies. He can give the bags with 1 and 4 candies to one brother and the bags with 2 and 3 to the other brother.One of Arkady's friends works at a huge radio telescope. A few decades ago the telescope has sent a signal $s$ towards a faraway galaxy. Recently they've received a response $t$ which they believe to be a response from aliens! The scientists now want to check if the signal $t$ is similar to $s$.

The original signal $s$ was a sequence of zeros and ones (everyone knows that binary code is the universe-wide language). The returned signal $t$, however, does not look as easy as $s$, but the scientists don't give up! They represented $t$ as a sequence of English letters and say that $t$ is similar to $s$ if you can replace all zeros in $s$ with some string $r_0$ and all ones in $s$ with some other string $r_1$ and obtain $t$. The strings $r_0$ and $r_1$ must be different and non-empty.

Please help Arkady's friend and find the number of possible replacements for zeros and ones (the number of pairs of strings $r_0$ and $r_1$) that transform $s$ to $t$.


-----Input-----

The first line contains a string $s$ ($2 \le |
<PREDICTION>
:  the times from theies. the other. that the the are the same number of candies.

-----Input-----

The first line contains integer single integer n (1 is even) number ≤ n ≤ 10).  the number of cand. friends.


-----Output-----

Print the number that the has of than are the from 1 to n,

 can to print the lines. each the i-th line of the space. the numbers of candies in the i. the i-th .

, the the numbers are be distinct. are equal the. 1 to n.2.

 can print the numbers of any following in the order. If

The is guaranteed that the answer exists. least given one.


-----Examples-----
Input
3

Output
1

1 1


-----Note-----

In first input the 1 possible in the has no cand with
 this case, the answer will the and 2, 3, 4.ies.
 will choose the number of numbers and 2 candies. the of. the other with 2 and 4 cand the other one.
 day theassert is house are in the big game..
 friend days are, same is been to new ofn$- the $,.. The, are got a new ton$- is are to the the non $ the $
 first is has to be out they number ist$ is inside to thet$

The first $ iss$ is given bit of $eros and ones,i, the the number is a same ofand).).
 first string iss$ the, the not have like follows to thek$ $ the first is't have a to
 can ass$ times the string of z letters. the that thet$ is a to $s$. if $ can make $ oferos with $s$, by $ number (t$,1$ to $ of with $r$. with some string characters $r_1$ and all $r$.
 resulting $t_1$ and $s_1$ are be equal, are-empty strings

The, thedef find friends, find the minimal of ways sequences of theer. z.i first of possible of z $t_0$ and $r_1$ are in can thes$ into $s$


-----Input-----

The first line contains one single $s$ ($| \le |s
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 82500
----------------------------------------------------------------------------------------------------
<INPUT>
:  map(int, input().split())
	a = list(map(int, input().split()))
	r1 = 0
	for i in range(n - 1):
		m = 0
		for j in range(i + 1, n):
			if a[i] > a[j]:
				m += 1
		r1 += m
	a.sort()
	last, r2 = 0, 0
	for i in range(n):
		if a[i] != a[i - 1]:
			r2 += i
			last = i
		else:
			r2 += last
	r = r1 * k + (k * (k - 1) * r2) // 2
	print(r)# cook your dish here
# import bisect
# def recur(s_i, e_i, end_i):
#	 # if end_i in dp[s_i] and e_i in dp[s_i][end_i]:
#	 #	 return dp[s_i][end_i][e_i]
		
#	 inside = 0
#	 for i in range(s_i+1, e_i):
#		 if b_l[i] < k:
#			 if e_i not in dp[i]:
#				 dp[i][e_i] = 0
#				 bi_i = bisect.bisect_left(b_inv[b_l[i]+k], i)
#				 for ind in b_inv[b_l[i]+k][bi_i:]:
#					 if i < ind < e_i:
#						 dp[i][e_i] = max(dp[i][e_i], recur(i, ind, e_i))
#			 inside = max(inside, dp[i][e_i])
#	 outside = 0
#	 for i in range(e_i+1,
<PREDICTION>
: (int, input().split())

		 = list(map(int, input().split()))
	b = = 0
	r i in range(n): 1):
		if = max
		for j in range(i, 1, n):
			m a[j] > a[j]:
				m = 1
			1 = m
	print[sort()
	print = r = = 0, n
	for i in range(n):
		if a[i] > last[i - 1]:
			last2 += 1 +
			last = i
	print	:
			last2 += n
	print2 02 + r rlast - (k - 1)) * (2) 2
	print(r) cook your dish here
for cook mathect
# import solve((arr,i, e_i, end_i):
#	 for print end_i in dp[s_i] and s_i in dp[s_i][end_i]:
#	 #	 return dp[s_i][end_i][e_i]
#	
#	 #= 0
#	 for i in range(s_i +1, e_i):
#		 if end[b[i] < b:
#			 inside b_i not in dp[s]:
#				 insidep[i][e_i] = 0
#				 bi_i = bisect.bisect_left(b_inv[b_l[i]+k], i)
#				 for ind in b_inv[b_l[i]+k][bi_i:]:
#					 if e < ind < e_i:
#						 dp[i][e_i] = max(dp[i][e_i], recur(i, ind, e_i))
#				 = max( inside, dp[i][e_i])
#		 = 0
#	 for i in range(e_i+1, min
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 83000
----------------------------------------------------------------------------------------------------
<INPUT>
: :
								valid = True
								break
						if valid:
							intervals_dict[row][0][0] <= col <= intervals_dict[row][0][1]
							seen.add((row, col))
							if (row, col) == (endK[0], endK[1]):
								return moves
							queue.append((row, col))

		return -1


soln = Solution()
print(soln.solve())

I=lambda:map(int,input().split())
n,p=I()
a=list(I())
b=list(I())
r=a[p-1]+b[0]
s=0
for i in range(p-1):
	if r>=b[-1]+a[i]:
		s+=1
		del b[-1]
print(p-s)n,p=list(map(int,input().split()))
a=list(map(int,input().split()))
b=list(map(int,input().split()))
x=a[p-1]+b[0]
z = p-2
c=0
for i in range(1,n):
	if b[i]+a[z]<=x:
		c+=1
		z-=1
	if z<0:
		break
print(max(p-c,1))			

3

import array
import math
import os
import sys


DEBUG = 'DEBUG' in os.environ


def inp():
	return sys.stdin.readline().rstrip()


def dprint(*value, sep=' ', end='\n'):
	if DEBUG:
		print(*value, sep=sep, end=end)


def solve(N, M, G):
	if N == 2:
		return [0, 1]

	degv = [set() for _ in range(5)]

<PREDICTION>
: 
									_ True
								break
							 valid:
								vals.set[(][col]col] = row and r_dict[row][0][0]
							inter.add(row, col))
							if (row, col) not (row_,0], endK[1])):
								valid True
							if.append((row, col))
			 []1
		olve = []()

(ssteps)getolve(

=input:list(int,input().split())
n,k=I()
a=list(I())
b=list(I())
c=list.p-1]b[p]
for=set
for i in range(n-1):
	if a<=n[i1]:b[i]
		s=1
	elser b[-1]
	(s-s)n, p=map(map(int,input().split()))
a=list(map(int,input().split()))
b=list(map(int,input().split()))

=a[p-1]+b[0]
y= a-1
fornt0
for i in range(p,n):
	if a[i]a[i]<xx:
		c+=1
		del ==b
	else z===:
		z
if(c(c-c,0))
	

	

import sys
import math
import os
import sys


DEBUG = 'DEBUG' in os.enpr


def inp():
	return sys.stdin.readline().rstrip()


def dprint(*value, sep=' ', end='\n'):
	if DEBUG:
		print(*value, sep=sep, end=end)


def solve(N, M, A):
	if N == 1:
		return [0, 1]
	G = = [0() for _ in range(N)]
	
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 83500
----------------------------------------------------------------------------------------------------
<INPUT>
: print(ans)#!/usr/bin/env python3
import sys
from itertools import combinations_with_replacement,product
def input(): return sys.stdin.readline().rstrip()


def main():
	D,G=list(map(int, input().split()))
	problem=[]
	for i in range(1,D+1):
		p,c=list(map(int, input().split()))
		problem.append([i,p,c])
	ans=10000000
	for bit in list(product([0,1],repeat=D)):
		pnum=0
		nokori=G
		notcomp=[]
		for i in range(D):
			if bit[i]==1:
				pnum+=problem[i][1]
				nokori-=problem[i][2]+problem[i][1]*problem[i][0]*100
			else:
				notcomp.append(problem[i])
		while nokori>0 and notcomp:
			score,p,c=notcomp.pop()
			if score*(p-1)*100<=nokori:
				nokori-=score*(p-1)*100
				pnum+=p-1
			else:
				tmp=score*100
				pnum+=(nokori+tmp-1)//tmp
				nokori=0
		if nokori<=0:
			ans=min(ans,pnum)
	print(ans)
	


def __starting_point():
	main()


__starting_point()n = int(input())

x = [0] * n
y = [0] * n
h = [0] * n

for i in range(n):
	x[i], y[i], h[i] = map(int, input().split())

for cx in range(101):
	for cy in range(101):
		H = -1
	
<PREDICTION>
: (ans)
 cookusr/bin/env python3

 sys
from collectionsertools import accumulate
with_replacement
 product,from input(): return sys.stdin.readline().stripstrip()

def main():
	n, H =list(map(int, input().split()))
	G=[[
	for _ in range(D,D):1):
		problem=c=list(map(int, input().split()))
		problem.append((c,p,c])

	problem=0

	for i in range(problem_0,1], repeat=D)):
		if,=0
		for=ori=0-		forok=1
		for i in range(D):
			if bit[1]==1:
				num+=1[i][1]
				nokori-=problem[i][1]1[i][2]
p[i][2]
problem
				:
				ncomp.append(problem[i][
		if notokori>0: notcomp:
			n=n,c=procomp%pop()
			n score>100p-1)100+=Gokori:
				ansokori-=problem*100p-1)*100
				num+=score
1
				:
				break=0*100
				num+==(nokori-1)*1)*//tmp
				nokori-tmp
			 nokori*GG:
			break=min(ans,pum)
	print(ans)




def __starting_point():
	main()


starting_point()#, int(input())

ans = [0] * n
y = [0] * n

 = [0] * n

for i in range(n):
	x[i], y[i] h[i] = map(int, input().split())

ans i in range(1):
	for cy in range(101):
		if = h1
		
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 84000
----------------------------------------------------------------------------------------------------
<INPUT>
:  node.left is not None:
				temp = (value*2) +1
				self.result.append(temp)
				q.append((node.left, temp))
				
				
			if node.right is not None:
				temp = (value*2) +2
				self.result.append(temp)
				q.append((node.right, temp))
		print((self.result))
		
	def find(self, target: int) -> bool:
		return True if target in self.result else False
		
		




# Definition for a binary tree node.
# class TreeNode:
#	 def __init__(self, val=0, left=None, right=None):
#		 self.val = val
#		 self.left = left
#		 self.right = right


# first attempt
# below code almost looks ok , but it doesn't pass all test cases.

# class FindElements:
#	 result = []
#	 def __init__(self, root: TreeNode):
#		 #result = []
		
#		 # fill using top down approach
#		 def helper(root, value):
#			 #base
#			 if root.left is None and root.right is None:
#				 self.result.append(value)
#			 #recursion
#			 elif root.left is not None:
#				 self.result.append(value)
#				 temp = (value*2) +1
#				 helper(root.left, temp )
#				 #print(\"left not null\")
#				 #print(\"self.result \", self.result)
#			 elif root.right is not None:
#				 self.result.append(value)
#				 temp = (value*2) +2
#				 helper(root.right, temp )
#				 #print(\"
<PREDICTION>
: .val: not None:
					 = selfnode +() + (
				if.stack.append(temp)
				self.append(value.left, value*
				self				
				 node.right: not None:
				temp = (value*2) +2
				self.result.append(temp)
				q.append((node.right, temp))
			(self.result))
		return		 get(self, x: int) -> bool:
		return target if target in self.result else False
		
		



# Your for sing binary tree node.
# class TreeNode:
#	 def __init__(self, val=0, left=None, right=None):
#		 self.val = val
#		 self.left = left
#		 self.right = right

def class_
# find





 we it's't work it of cases.
## class SolutionElements:
#	 def = []
#	 def __init__(self, root: TreeNode):
#		 self find = []
#	
#		 def while the the left solution
#		 top d(root, val):
#			 iffind case#			 if not isleft is None and root.right is None:
#				 return.result.append(value)
#				printursive
#			 #if root.left is None None:
#				 self.result.append(value)
#			 # # = helpervalue*2) +1
#				 helper(root.left, temp)
#				 helperprint(\" \\", in\")
#				 #print(\"right.result\",", self.result)
					if root.right is not None:
#				 self.result.append(value)
#				 # = (value*2) +2
#				 helper(root.right, temp )
#				 #print(\"temp
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 84500
----------------------------------------------------------------------------------------------------
<INPUT>
: ans = 0
for i in cost:
  ans = (ans+sum(i))%mod
ans = ans*pow(2,mod-2,mod)%mod
ans = ans*cmb(n*m-2,k-2)%mod
print(ans)n,m,k=map(int,input().split())
mod=pow(10,9)+7


# コンビネーション、さらに高速。あらかじめO(N)の計算をすることでのちの計算が早くなる
def cmb(n,r,mod):
  if (r<0 or r>n):
	return 0
  r=min(r,n-r)
  return g1[n]*g2[r]*g2[n-r]%mod
g1=[1,1] # g1[i]=i! % mod　:階乗
g2=[1,1] # g2[i]=(i!)^(-1) % mod　:階乗の逆元
inverse=[0,1]
for i in range(2,n*m+1):
  g1.append((g1[-1]*i)%mod)
  inverse.append((-inverse[mod%i]*(mod//i))%mod)
  g2.append((g2[-1]*inverse[-1])%mod)

ans=0
for d in range(1,n):
  tmp=d*(n-d)*m**2
  tmp%=mod
  tmp*=cmb(n*m-2,k-2,mod)
  ans+=tmp
  ans%=mod
for d in range(1,m):
  tmp=d*(m-d)*n**2
  tmp%=mod
  tmp*=cmb(n*m-2,k-2,mod)
  ans+=tmp
  ans%=mod
print(ans)##mod,nについての制約は�
<PREDICTION>
:  = 0
	 i in range:
	 if += maxans +i(i))%mod
print = (*pow(2,n-2,mod)%mod
print = ans*pmb(N,m-2,n-2,%mod
print(ans)import,m,k =map(int,input().split())
mod=10ow(10,9)+7

defn�ンプネーション
1らに吠速し
りかか�め、(1^。計算を�る
とで���計算が�くかる
# cmb(n,r,mod):
	 if (r<0 or r>n):
	return 0
  r=min(r,n-r)
  return g1[n]*g2[r]*g2[n-r]%mod

1=[1,1]  �1[i]=iの�% mod
�""" g�乗
g2=[1,1] # g2[i]==(i!)^(-1)% mod
� 階乗
��元
invverse=[0,1] #for i in range(2,n+m+1):
  g1.append((g1[-1]*i)%mod)
  inverse.append((-inverse[mod%i]*(mod//i))%mod)
  g2.append((g2[-1]*inverse[-1])%mod)

ans=0
for i in range(1,n*
  ans=c*(n-d)(
2
  ans%=mod
  ans*=cmb(n*m-2,k-2,mod)
  tmp+=tmp
  ans%=mod
print d in range(1,m):
  tmp=d*(m-d)*n**2
  tmp%=mod
  tmp*=cmb(n*m-2,k-2,mod)
  ans+=tmp
  ans%=mod
print(ans)import -=Numpyついて、��約�自
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 85000
----------------------------------------------------------------------------------------------------
<INPUT>
:  'YES')# cook your dish here
t=int(input())
for i in range(t):
 N,K=list(map(int,input().split()))
 rest=N/K
 if rest%K==0:
  print("NO")
 else:
  print("YES")



for test in range(int(input())):
 n,k=list(map(int,input().split()))
 if k==1:
  print("NO")
 else:
  a=n//k
  if a%k==0:
   print('NO')
  else:
   print('YES')
# cook your dish here
def temple(n,arr):
 s=sum(arr)
 left=[0]*n
 right=[0]*n 
 left[0]=1 
 right[-1]=1 
 
 maxHeight=0
 
 for i in range(1,n):
  left[i]=min(left[i-1]+1,arr[i])
 #print(*left)
 
 for i in range(n-2,-1,-1):
  right[i]=min(right[i+1]+1,arr[i])
 #print(*right)
 
 for i in range(n):
  maxHeight=max(maxHeight,min(left[i],right[i]))
 
 print(s-maxHeight**2)
 
 
 
for _ in range(int(input())):
 temple(int(input()),list(map(int,input().split())))
t = int(input())

for _ in range(t):
 n = int(input())
 h = list(map(int, input().split()))
 
 s = sum(h)
 
 h[0] = 1
 for i in range(1,n):
  if h[i] > h[i-1]+1:
   h[i] = h[i-1]+1
 h[n-1] = 1
 
 for i in range(n-2,-1,-1):
  if h[i] > h[i+1]+1:
   h[i] = h[i+1
<PREDICTION>
: 0'
 cook your dish here
for=int(input())
for _ in range(t):
 n=K=map(map(int,input().split()))
 if=K//K
 if rest%2==0:
  print("YES")
 else:
  print("YES")



 _ in range(int(input())):
 n,k=map(map(int,input().split()))
 if n%1:
  print("YES")
 else:
  print=k//k
  b a%k==0:
   print("YES')
  else:
   print("YES')

  cook your dish here
for check(a,k):
 if=0(arr)
 if=0 for*(
 right=[0]*n

 for[0]=s 
 right[-1]=1

 for
 fora=s  for
 for i in range(1,n):
  if[i]=left(left[i-1],arr,left[i])
 print(left)
 for
 for i in range(n-2,-1,-1):
  right[i]=min(right[i+1]+1,arr[i])
 #print(*right)
 
 for i in range(n-
  rightHeight=max(maxHeight,left(left[i],right[i]))
 #
 #(max-maxHeight)2+
 
      _ in range(int(input())):
 n(n(input()))0(map(int,input().split())))# n= int(input())
forfor _ in range(t):
 n, int(input())
  = list(map(int,input().split()))
 
 if = 0(h)
 
 if.0] = h
 for i in range(1, n):
  h h[i] == h[i-1]+1:
   h[i] = h[i-1]+1
  =n-1] = 1
 
 for i in range(n-2,-1,-1):
  if h[i] > h[i+1]+1:
   h[i] = h[i+1]+
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 85500
----------------------------------------------------------------------------------------------------
<INPUT>
:  "149.431.10", "0.99" and "123.05" are valid prices,  ".333", "3.33.11", "12.00", ".33", "0.1234" and "1.2" are not valid. 

Write a program that will find the total price of all purchases in the given bill.


-----Input-----

The only line of the input contains a non-empty string s with length not greater than 1000 — the content of the bill.

It is guaranteed that the bill meets the format described above. It is guaranteed that each price in the bill is not less than one cent and not greater than 10^6 dollars.


-----Output-----

Print the total price exactly in the same format as prices given in the input.


-----Examples-----
Input
chipsy48.32televizor12.390

Output
12.438.32

Input
a1b2c3.38

Output
6.38

Input
aa0.01t0.03

Output
0.04Let's denote a m-free matrix as a binary (that is, consisting of only 1's and 0's) matrix such that every square submatrix of size m × m of this matrix contains at least one zero. 

Consider the following problem:

You are given two integers n and m. You have to construct an m-free square matrix of size n × n such that the number of 1's in this matrix is maximum possible. Print the maximum possible number of 1's in such matrix.

You don't have to solve this problem. Instead, you have to construct a few tests for it.

You will be given t numbers x_1, x_2, ..., x_{t}. For every $i \in [ 1, t ]$, find two integers n_{i} and m_{i} (n_{i} ≥ m_{i}) such that the answer for the aforementioned problem is exactly x_{i} if we set n = n_{i} and m = m_{i}.


-----Input-----

The first line contains one integer t (1 ≤ t ≤ 100) — the number of tests you have to construct.

Then t lines follow, i-th line containing one integer x_{i} (0 ≤ x_{i} ≤ 10
<PREDICTION>
:  ""2,index" "14.5.
 "00.0", are not.. as
99. "0.0"22", "4.10", "333. "4.00",", are "12.01. are not. prices 

You a function that will find the maximum number of all the of the given order.


-----Input-----

The first line contains the input contains one single-empty string s ( length from more than 10.— the number of the bill.


The is guaranteed that the total is't problem given in.

 is guaranteed that the character is the bill is a greater than 1000 of amount the greater than 1000 6..


-----Output-----

Print a total price of of the given order. in of in the input.


-----Examples-----
Input
100
..
......
.
Output
0.0.66

Input
s.
.b3
0.
Output
0.66.
Input
a.b0b0
0t
Output
0.0.'s call the function-adan number with a set matrixm is, a of m integers) and 0's). and. that each row ismatrix of size m is n, length matrix is exactly least one element or


Let the following m for

- are given a integers n and m, You need to find a array-free matrix matrix with size n × m. that: sum of sub's in the matrix is the possible.
 the number possible number of 1's in the a.


If can't need to minimize the problem.

 of you can to print an m more. you.


You have be given n lines a_1, x_2, ..., x_{t}

 each rowi \in [1 ] t]$, you the arrays $ andi} and m_{i} (1_{i} � 1_{i} that that the sum is all i matrix is maximum $\_{i} + there can it_{ x.i} - m_{ x_{i}


-----Input-----

The first line contains two integer t (1 ≤ t ≤ 10). — the number of test. have. find.

Each t lines follow, each-th of contains two integer m_{i} (1 ≤ x_{i} ≤ 100^
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 86000
----------------------------------------------------------------------------------------------------
<INPUT>
: ect_right(l, x[0] - 1)
				if idx >= 1:
					ans = max(ans, x[1] - l_idx[idx - 1])
		
		return ans
		
class Solution:
	def maxSatisfied(self, customers: List[int], grumpy: List[int], k: int) -> int:
		n=len(customers)
		res=sum([customers[i]*(1-grumpy[i]) for i in range(n)])	# the customers you can obtain while non grumpy
		best_gain=sum([customers[i]*grumpy[i] for i in range(k)])	# first window
		gain=best_gain
		for i in range(k,n):
			gain+=customers[i]*grumpy[i]-customers[i-k]*grumpy[i-k]  # add new, kick out old
			best_gain=max(gain,best_gain)	
		return res+best_gainclass Solution:
	def maxSatisfied(self, customers: List[int], grumpy: List[int], X: int) -> int:
		max_satisfaction = sum(customers)
		actual_satisfaction = sum(int(not g) * s for g,s in zip(grumpy, customers))
		
		max_s_x = sum(customers[:X])
		actual_s_x = sum(int(not g) * s for g,s in zip(grumpy[:X], customers[:X]))
		
		ans = actual_satisfaction - actual_s_x + max_s_x
		print(max_satisfaction, actual_satisfaction)
		print('sssssssss')
		for i in range(X, len(customers)):
			print(max_s_x, actual_s_x, customers[i], customers[i - X])
			max_s_x += customers[i] - customers[
<PREDICTION>
: _left
self, r)i])): x)
					 lx < len:
					l += max(ans, l[id] - x[listx[idx - 1]
					return ans
				 Solution:
	def longestSumatisfied(self, customers: List[int], grumpy: List[int], X: int) -> int:
		if =len(customers)
		if=0(customers[i]*customgr-grumpy[i]) for i in range(n)])
	n sum can can get
 only-umpy[		for=at=0([customers[i]*(umpy[i] for i in range(n)])
	 the group
		for=sum_12-		for i in range(n):n):
			if+=customers[i]-*grumpy[i-customers[i-k]
(umpy[i-1]

 the the number and the

			res_12=max(best,best_ and)
				 best
max_able
 Solution:
	def maxSatisfied(self, customers: List[int], grumpy: List[int], k: int) -> int:
		
_satisfied = 0(customers)
		if_sumatisfied = sum(custom(c gr) for X for g, s in zip(customumpy, gr))
		s		for_satisfs = max(customers[iX])
		max_satisfs = sum(custom(not g) * s for g,s in zip(customumpy[:X], gr[:X]))
		
		for = max_s_action
 max_s_x
 max_s_x
		
(max_s_action) actual_s_action)
		
({',sssss',
		
 i in range(X,len(customers)):
			if(max_s_x, max_s_x, actual[i]) customers[i]) X])
			
_s_x = customers[i] * customers[i
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 86500
----------------------------------------------------------------------------------------------------
<INPUT>
:  and s[N-1] == 'o') or (ans[N-1] == 'W' and s[N-1] == 'x')) and (ans[N-2] == ans[0])) or (((ans[N-1] == 'S' and s[N-1] == 'x') or (ans[N-1] == 'W' and s[N-1] == 'o')) and (ans[N-2] != ans[0]))) and ((((ans[0] == 'S' and s[0] == 'o') or (ans[0] == 'W' and s[0] == 'x')) and (ans[N-1] == ans[1])) or (((ans[0] == 'S' and s[0] == 'x') or (ans[0] == 'W' and s[0] == 'o')) and (ans[N-1] != ans[1]))):
				print(''.join(ans))
				return
print(-1)import sys
n=int(input())
s = list(input())
l = list(0 for i in range(n))
l[0]='S'
l[1]='S'
for i in range(1,n-1):
	if l[i]=='S':
		if l[i-1]=='S':
			if (s[i]=='o'):
				l[i+1]='S'
			else:
				l[i+1]='W'
		else:
			if s[i]=='o':
				l[i+1]='W'
			else:
				l[i+1]='S'
	else:
		if l[i-1]=='S':
			if (s[i]=='o'):
				l[i+1]='W'
			else:
				l[i+1]='S'
		else:
			if s[i]=='o':

<PREDICTION>
:  the[i-1] == '1' or (s[N-1] == 'S' and ans[N-2] == 'o'): or (ans[N-2] == '[N]): or (ansans[N-1] == 'W' and ans[N-1] == 'x' or (ans[N-1] == 'W' and s[N-1] == 'o'))): (ans[N-2] == '[0]):): (ansans[N] == 'W' and s[N] == 'o' or (ans[N] == 'W' and s[0] == 'x'))) or (ans[N-1] == '[0])) or ((ansans[N] == 'W' and s[0] == 'o' or (ans[N] == 'W' and s[0] == 'o')))): (ans[N-1] == ans[N]):):
	printprintansans((NOjoin(ans))
				return
print((1)
 sys
input =int(input())
s= input(input())

= len(map for x in range(n)
for.0] =S'
l[-]='W'
l i in range(1,n):1):
	if s[i]=='S'
		l l[i-1]=='S':
			l ll[i-=='o' and
				l[i]1]='W'
				:
				l[i+1]='W'
		else:
			if ([i-=='o':
				l[i+1]='S'
			else:
				l[i+1]='S'
	else:
		if l[i]1]=='S':
			l ls[i]=='o'):
				l[i+1]='S'
			else:
				l[i+1]='S'
		else:
			if ([i]=='o':
	
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 87000
----------------------------------------------------------------------------------------------------
<INPUT>
: vowels[self.replace_vowels(q.upper())]
		
		return \"\"
	
	def replace_vowels(self, q):
		return q.replace(\"A\", \"!\").replace(\"E\", \"!\").replace(\"I\", \"!\").replace(\"O\", \"!\").replace(\"U\", \"!\")
class Solution:
	def spellchecker(self, wordlist: List[str], queries: List[str]) -> List[str]:
		
		vowels = set('aeiou')
		
		# Map lowercase words to word
		w = collections.defaultdict(list)
		for word in wordlist:
			w[word.lower()].append(word)
			
		# Map (vowel_count, len_word) to lowercase vowel-less words : word
		v = collections.defaultdict(list)
		vl = collections.defaultdict(list)
		for k in w:
			vowel_less = ''.join(char for char in k if char not in vowels)
			v[(len(vowel_less), len(k))].append(vowel_less)
			vl[vowel_less].append(k)
		
		res = []
		for q in queries:
			
			# 1. Case sensitive check
			k = q.lower()
			if k in w:
				res.append(q if (q in w[k]) else w[k][0])
				continue
				
			# 2. Vowel check
			vowel_less = ''.join(char for char in k if char not in vowels)
			if vowel_less in v[(len(vowel_less), len(k))]:
				for word in vl[vowel_less]:
					if len(word) == len(k):
						for a,b in
<PREDICTION>
: ]el =i.n(vowels[word,index(), +
					return '\
			def is_vowels(self, q,
		
 \" incount(q\\" \"A\ )replace(\"A\", \"\\").replace(\"C\", \")\").replace(\"M\", \")\").replace(\"M\", \"!\"")
	 Solution:
	def spellchecker(self, wordlist: List[str], queries: List[str]) -> List[str]:
		def		defowels = {}()aeiouy
		word		def key the case letters, u list		wordet {}.defaultdict(list)
		for q in wordlist:
			w[word[lower()].append(word)
			
		# for towordowelsimlower, word(word)
 wordcase letters_by-
 1
		
ow w.defaultdict(int)
		forow collections.defaultdict(int)
		for word, w:
			forowel_count = kaejoin(w not char in w) char in in vowels)
			v[klen_vowel_less) len(v))]append(vowel_less)
			
[(owel_less]append(k)
					# = []
		for query in queries:
			q			# q. find length
:			l = q.lower()
			if k in wl
				res.append(q) wkow w elsek] else w[k])::])
				

			

			# 2.7owel-
			forowel_less = w'.join(char for char in k if char not in vowels)
			v len_less == vowowklen(vowel_less) len(k)]
				res k in vowow[(owel_less[
					if word(word) == len(v):
						continue i in word in zip
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 87500
----------------------------------------------------------------------------------------------------
<INPUT>
:  j in range(len(L)):
		if L[j]==1:
			a.append(j)
	for k in range(len(a)-1):
		b.append(a[k+1]-a[k])
	for l in range(len(b)):
		if b[l]<6:
			print("NO")
			break
	else:
		print("YES")
# cook your dish here
for _ in range(int(input())):
	n=int(input())
	a=list(map(int,input().split()))
	pos=[]
	for i in range(len(a)):
		if a[i]==1:
			pos.append(i)
	for i in range(1,len(pos)):
		if pos[i]-pos[i-1]<6:
			print('NO')
			break
	else:
		print('YES')# cook your dish here
for _ in range(int(input())):
	N=int(input())
	inp_lst=tuple(i for i in input().strip().split(' '))
	idx_lst=[]
	printStr='YES'
	for i in range(N):
		if(inp_lst[i]=='1'):
			idx_lst.append(i)
			
	for i in range(1,len(idx_lst)):
		if(idx_lst[i]-idx_lst[i-1]<6):
			printStr='NO'
			break
		
	print(printStr)
	
# cook your dish here

t=int(input())

for i in range(t):
 n=int(input())
 a=list(map(int,input().split()))
 d={}
 for i in range(n):
  if a[i]-1 not in d:
   d[a[i]-1]=[i]
  else:
   d[a[i
<PREDICTION>
:  in range(n(s)):
			 i[i] ==':
			L[append(L)
		 i in range(len(L)1):
		if.append(a[k+1]-a[k])
	for j in range(len(b)-):
		if b[l]==a:
			a(NO")
			return
	else:
		print("YES")
	 cook your dish here
t _ in range(int(input())):
	n =int(input())
	l=list(map(int,input().split()))
	b=[]
	for i in range(n(a)):
		if a[i]==1:
			pos.append(i)
	pos i in range(len,len(pos)):
		if pos[i]pos[i-1]==6:
			print("NO')
			break
	else:
		print('YES')# cook your dish here
for _ in range(int(input())):
	n =int(input())
	Ap=listst=listuple(map for i in range().split().split()) '))
	inx=lst=[]
	for(="NO'
	for i in range(0):
		if ininp_lst[i]=='1'):
			idx_lst.append(i)
	forelse
	for i in range(len,len(idx_lst)):
		if(idx_lst[i]idx_lst[i-1]<6):
			printStr='NO'
		elsebreak
	elseelse	print(idStr)
			 cook your dish here
forfor =int(input())
forfor i in range(t):
	=int(input())
 a=list(map(int,input().split()))
 b={}
 for j in range(n):
  d a[i]a in in d:
   d[a[i]-1]=[]i]
  else:
   d[a[i]-
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 87500
----------------------------------------------------------------------------------------------------
<INPUT>
: 					graph[edge[1]][edge[2]] = 3
				else:
					graph[edge[1]][edge[2]] = 4 
				
		
		alice_dset = Solution.DisjointSet(n)
		
		print(ans)
		
		for i in range(1, n+1):
			for (j, t) in list(graph[i].items()):
				if t == 3:
					if not alice_dset.is_connected(i, j):
						alice_dset.join(i, j)
					else:
						ans += 1
		bob_dset = copy.deepcopy(alice_dset)
		
		for i in range(1, n+1):
			for (j, t) in list(graph[i].items()):
				print((i, j, t))
				if t == 1 or t == 4:
					if not alice_dset.is_connected(i, j):
						alice_dset.join(i, j)
					else:
						ans += 1
				if t == 2 or t == 4:
					if not bob_dset.is_connected(i, j):
						bob_dset.join(i, j)
					else:
						ans += 1
						
		for i in range(1, n):
			if not bob_dset.is_connected(i, i + 1) or not alice_dset.is_connected(i, i + 1):
				# print(i, bob_dset.parent(i), bob_dset.parent(i + 1))
				# print(i, alice_dset.parent(i), alice
<PREDICTION>
: 					[i[0]].edge[2]] = edge
					:
					graph[edge[1]][edge[2]] = 1

										
ice =graphic = {}.findjointSet(graph)
		
		return(al)
		return		return edge in range(n, n):1):
			if ja, k) in graph(graph[i].items()):
				if t == 1:
					al not (ice_dset.union_same(i, j):
						alice_dset.union(i, j)
						:
						al += 1
		
ob_dset = Solution.deepcopy(alice_dset)
		
		return i in range(1, n):1):
			if jj, t) in list(graph[i].items()):
				if(i, j, t))
				
 t == 1: t == 2:
					if not alice_dset.is_connected(i, j):
						bice_dset.join(i, j)
					else:
						ans += 1
		
		 t == 2 or t == 5:
					if not bob_dset.is_connected(i, j):
						bob_dset.join(i, j)
					else:
						ans += 1
		
			
		return i in range(1, n+
			for al bob_dset.is_connected(i, i): 1): or not alice_dset.is_connected(i + i - 1):
				return print(i, i_dset.s)i + i_dset.parent(i + 1))
				return print(i, bobice_dset.parent(i + bobice_
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 88000
----------------------------------------------------------------------------------------------------
<INPUT>
: y=find(x),find(y)
			if x!=y:
				dp[x]=find(y)
				return False   
			return True
			
		n=len(p)
		dp=list(range(n))	

		pool=sorted((abs(p[i][0]-p[j][0])+abs(p[i][1]-p[j][1]),i,j) for i in range(n) for j in range(i+1,n))
		
		ct=res=0
		

		for dis,u,v in pool:
			if not uni(u,v):
				res+=dis
				ct+=1
				if ct==n-1:
					break
		return resclass Solution:
	def minCostConnectPoints(self, points: List[List[int]]) -> int:
		def find(x):
			if x != parent[x]:
				parent[x] = find(parent[x])
			return parent[x]
		
		parent = list(range(len(points)))
		g = []
		for i in range(len(points)):
			for j in range(i+1, len(points)):
				g.append((i, j, abs(points[j][1]-points[i][1]) + abs(points[j][0]-points[i][0])))
		
		cost = 0
		for u, v, w in sorted(g, key=lambda x:x[2]):
			ru, rv = find(u), find(v)
			if ru == rv:
				continue
			parent[ru] = rv
			cost += w
		
		return cost# Kruskal
class UnionFindSet:
	def __init__(self, n):
		self.parents = [i for i in range(n + 1)]
		
<PREDICTION>
: ]0(y)find(y)
		ifif x!=y:
				if[x]=min(y)
				return d



			return True 		res
		def=len(s)
		dp=[[(range(n))
			res=[]orted(p(p[i][0]-p[j][0])+abs(p[i][1]-p[j][1]),i,j) for i in range(n) for j in range(i+1,n))
		return		return=0=0
		for		for i,i,v in pool:
			if find di(u):v):
				res+=dis
				ct+=1
				
 ct==n:1:
					return
		return resclass Solution:
	def minCostConnectPoints(self, points: List[List[int]]) -> int:
		
 find(x):
			if x != parent[x]:
				parent[x] = find(parent[x])
			return parent[x]
		
		def = [(range(len(points)))
		
 = [[
		
 i in range(len(points)):
			for j in range(i+1, len(points)):
				dist.append((i, j, abs(points[i][0]points[i][1])+ abs(points[j][0]-points[i][0])))
					g = 0
		
 i, v, w in g(g, key=lambda x: x[1]):
			if, rv = find(u), find(v)
			if ru != rv:
				continue
			union[ru] = rv
			cost += w
					return cost
 classuskal's# SolutionFind::
	def __init__(self, n):
		self.parents = listi for i in range(n)] 1)]
		self
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 88500
----------------------------------------------------------------------------------------------------
<INPUT>
: 		else:
				return (dp(i, j-1) + dp(i-1, j-1)) % MOD

		return sum(dp(N, j) for j in range(N+1)) % MOD
class Solution:
	def maxSizeSlices(self, slices: List[int]) -> int:
		@lru_cache(None)
		def dp(i, k):
			if k == 0 or i > j:
				return 0
			return max(dp(i + 1, j, k), slices[i] + dp(i + 2, j, k - 1))
		n = len(slices)
		k = n // 3
		dp = collections.deque([[0] * (k + 1) for i in range(2)])
		for i in range(n - 2, -1, -1):
			new_dp = [0] * (k + 1)
			for j in range(1, k + 1):
				new_dp[j] = max(dp[0][j], slices[i] + dp[1][j - 1])
			dp.pop()
			dp.appendleft(new_dp)
		a = dp[0][k]
		dp.clear()
		dp.extend([[0] * (k + 1) for i in range(2)])
		for i in range(n - 1, 0, -1):
			new_dp = [0] * (k + 1)
			for j in range(1, k + 1):
				new_dp[j] = max(dp[0][j], slices[i] + dp[1][j - 1])
			dp.pop()
			dp.appendleft(new_dp)
		b = dp[0][k]
		return max(a, b)class Solution:
	def maxSizeSlices(self, slices: List[int]) -> int:
		n = len(slices)
<PREDICTION>
: 		:
					 False0[i, j,1, + dp(i-1, j-1) % mod
		return d(dp(n, j) for j in range(N))1)) % MODclassclass Solution:
	def knightSumSlices(self, slices: List[int]) -> int:
		nlru_cache(None)
		def dp(id, j):
			if k == 1: i == len:
				return 0
			if max(
(i + 1, k), k - d[i] + dp(i, 1, k, k - 1))
		n = len(slices)
		return = k // 3
		return = [[.defaultque()])-, * (k + 1) for _ in range(n)])
		for i in range(1): k, -1, -1):
			for =dp = [0] * (k + 1)
			for j in range(k, k + 1):
				new_dp[j] = d(s[j][j - d[i] - dp(1][j - 1])
				 =append()
		returndp.pop((new_dp)
		return = 0p[0][0]
		b =pop()
		return[appendend(dp0] * (k + 1) for i in range(2)])
		return i in range(1 - 2, -, -1):
			new_dp = [0] * (k + 1)
			for j in range(1, k + 1):
				new_dp[j] = max(dp[j][j], slices[i] + dp(1][j - 1])
			dp.append()
			dp.appendleft(new_dp)
		return = dp[0][k]
		dp a(a, b) % Solution:
	def maxSizeSlices(self, w: List[int]) -> int:
		n = len(slices)

----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 89000
----------------------------------------------------------------------------------------------------
<INPUT>
: 
	for i in range(n):
		if a[i]&1:
			ans.append(i+1)
	if len(ans)<k:
		print("NO")
	elif (k-len(ans))&1:
		print("NO")
	else:
		print("YES")
		ans[-1]=n
		print(*ans[len(ans)-k:])
from sys import *
for _ in range(int(stdin.readline())):
	a,b=list(map(int,stdin.readline().rstrip().split()))
	l=list(map(int,stdin.readline().split()))
	k=[]
	c=0
	for x in range(a):
		if l[x]&1!=0:
			k.append(x+1)
			c+=1
	j=c
	if j<b:
		print("NO")
	else:
		t=j-b
		if t&1==0:
			print("YES")
			for x in range(b-1):
				print(k[x],end=" ")
			print(a)
		else:
			print("NO")'''input
3
2 1
1 1
5 4
1 2 3 4 5
6 2
1 2 8 4 10 2
'''
from copy import deepcopy
from bisect import bisect_right
from itertools import combinations
from sys import stdin



def dis(first, second, remain):
	if second[0] > first[0]:
		first[0], second[0] = second[0], first[0]

	if remain > first[0] - second[0]:
		remain -= first[0] - second[0]
		second[0] = first[0]
		first[0] += remain // 2
		return first[0]
	else:
		return second[0] + remain


# main starts
q = int(stdin.readline().
<PREDICTION>
: 		 i in range(n):
		if i[i] ==1:
			a.append(i+1)
		 a(ans)===:
		print(-NO")
		if lenk-len(ans))%1:
		print("YES")
	else:
		print("YES")
		print.01]1,		for(ans):-(ans)-1:])
	 collections import std

 t in range(int(inputin.readline())):
	n,b,list(map(int,stdin.readline().splitstrip().split()))
	if=[](map(int,stdin.readline().r()))
	l=0
	for=0
	for i in l(len):
		if l[x]%1:=l:
			k.append(x+1)
			c+=1
	if=0
	if c==0:
		j("NO")
	else:
		print=0-b
		if t>1:0:
			print("YES")
		elseprint x in range(t-t):
				print(k[t],end=" ")
			for(k,
		else:
			print("NO")
'input
4
1 1
1 2
1 2
1 2


 62
 21 2 3 2 4 6
'''
from sys import deepcopy
from collectionsect import bisect_left
from collectionsertools import accumulate
from collections import stdin

defdef solve(a, last): third):
	if remain -0] > remain[0]
		return[0], second[0] = second[0], first[0]
	if second == second[0]: * first[0]:
		returnain = 1[0] - remain[0]
		first[0], = remain[0] -		rem[0] = 1
 2
		rem remain

0]

	else:
		return remain

1]
 remain //
def from starts
n = int(stdin.readline().strip
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 89500
----------------------------------------------------------------------------------------------------
<INPUT>
: 		if cur[0] == m - 1 and cur[1] == n - 1: return count
				for d in direction:
					r, c, tmpK = cur[0] + d[0], cur[1] + d[1], cur[2]
					if r >= 0 and c >= 0 and r < m and c < n:
						if grid[r][c] == 1: tmpK += 1
						
						if tmpK <= k and not visited[r][c][tmpK]:
							visited[r][c][tmpK] = True
							queue.append([r, c, tmpK])
					
			count += 1
		return -1
class Solution:
	def shortestPath(self, grid: List[List[int]], k: int) -> int:
		m, n = len(grid), len(grid[0])
		seen = set()
		q = collections.deque()
		q.append((0, 0, k))
		seen.add((0, 0, k))
		steps = 0
		direction = [(1, 0), (-1, 0), (0, 1), (0, -1)]
		
		if 0 == m - 1 and 0 == n - 1:
			return 0
		
		while q:
			for i in range(len(q)):
				r, c, k = q.popleft()

				for x, y in direction:
					R = r + x
					C = c + y

					if R >= 0 and R < m and C >= 0 and C < n:
						if k > 0 and grid[R][C] == 1 and (R, C, k - 1) not in seen:
							q.append((R, C, k - 1))
							seen.add((R, C,
<PREDICTION>
: 		 ir0] == cur: 1: cur[1] == n - 1:
 True
					 i in range:
					if1 c = t = = d[0] + d[0], cur[1] + d[1], cur[2] +					if 0 >= 0 and c >= 0 and r < m and c < n and
						if grid[r][c] == 0 and
K += 1
						if						if gridK == k and ( grid[r][c]:tmpK]:
							visited[r][c][tmpK] = True
							q.append((r, c, tmpK])
										 += 1
			 count1
	 Solution:
	def shortestPath(self, grid: List[List[int]], k: int) -> int:
		m, n = len(grid), len(grid[0])
		vis = [[()
		q = collections.deque()
		q.append((0, 0, k))
		seen.add((0, 0, k))
		
 = 0
		
 = [(1, 0), (-1, 0), (0, 1), (0, -1)]
		
		while ( < m - 1 and 0 == n - 1:
			return 0
		
		while q:
			for _ in range(len(q)):
				r, c, k = q.popleft()
				for d, y in direction:
					nr = r + x
					C = c + y
					if 0 < 0 and R < m and 0 >= 0 and C < n:
						if ( == 0 and ([R][C] == 0 and (R, C, k) 1) not in seen:
							seen.append((R, C, k - 1))
							seen.add((R, C, k
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 90000
----------------------------------------------------------------------------------------------------
<INPUT>
: 		if end!=n-1:
					for i in range(end+1,n):
						ans[i]=k
					end=n-1
	else:
		ans=[k//2]+[k]*(n-1)
	print(*ans[:end+1])

main()X = int(input())
K = int(input())
R = list(map(int,input().split()))
R.append(0)

A = [X for _ in range(K+1)]
B = [0 for _ in range(K+1)]
C = [X for _ in range(K+1)]
D = [0 for _ in range(K+1)]
state = -1
for i in range(K):
  dr = R[i] - R[i-1]
  if state == -1:
	C[i+1] = max(0, C[i]-dr)
	D[i+1] = max(0, D[i]-dr)
	B[i+1] = min(B[i] + (-min(0, D[i]-dr)), A[i])
	A[i+1] = A[i]
	
  else:
	C[i+1] = min(X, C[i]+dr)
	D[i+1] = min(X, D[i]+dr)
	A[i+1] = max(A[i] - max(0, C[i]+dr-X), B[i])
	B[i+1] = B[i]

  state *= -1
"""
print(A)
print(B)
print(C)
print(D)
"""

Q = int(input())
R.pop()
import bisect
for _ in range(Q):
  t, a = list(map(int,input().split()))
  j = bisect.bisect_right(R, t)
  if j == 0: r = 0
  else: r = R[j-1]
  pre_ans = (min(A[j],max(B
<PREDICTION>
: 		 i in=end:1:
						 i in range(end,1,n):
						if[i][max
						=i-1
		:
		for.0 for2]kk]
(k-1)
		(*ans)::n])1])
	def()
 = int(input())
K = int(input())

 = list(map(int, input().split()))

.sort(X)

for = [0] i in range(X)]1)]

 = [R for _ in range(K+1)]

 = [0 for _ in range(K+1)]

 = [0 for _ in range(K+1)]

 = [1

 i in range(K):
	 A = A[i]
 1[i]1]
  C dr == -1:
	if[i]1] = dr(0,R[i+1)
 state[i+1] = max(0, C[i]+dr)
 state[i+1] = max(0[i]- - dr1(R,C[i+1), C[i+
	C[i+1] = max[i] + B  else:
	C[i+1] = A(C, D[i]-D)
	D[i+1] = B(X, C[i]+dr)
	A[i+1] = A(X[i], + dr(0, C[i])dr),max)) A[i]+
	
[i+1] = B[i]
	  == 21
 
for(max)
print(B)
print(C)
print(D)
"""
print# = int(input())
for =append(
R heapect

 _ in range(Q):
	 x,a, list(map(int, input().split()))
  r = bisect.bisect_right(R,t)
  print j == len:
 = 0
  else: a = max[j-1] -  if =r = 0pre(pre[j- B(0[
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 90500
----------------------------------------------------------------------------------------------------
<INPUT>
: 
			amt = action[2]
			city = action[3]
			if int(amt) > 1000:
				res.append(transactions[i])
				
			for j in range(i+1, len(transactions)):
				act2 = transactions[j].split(',')
				if act2[0] == person and abs(int(act2[1]) - int(time)) <= 60 and city != act2[3]:
					res.extend([transactions[i], transactions[j]])
		return list(set(res))class Solution:
	def invalidTransactions(self, transactions: List[str]) -> List[str]:
		res = []
		records = []
		
		for t in transactions:
			rec = t.split(',')
			rec[1] = int(rec[1])
			rec[2] = int(rec[2])
			records.append(rec)
		for rec in records:
			if rec[2] > 1000:
				rec[1] = str(rec[1])
				rec[2] = str(rec[2])
				res.append(','.join(rec))
				continue
			for x in records:
				if rec[0] == x[0] and abs(rec[1] - int(x[1])) <=60 and rec[3] != x[3]:
					rec[1] = str(rec[1])
					rec[2] = str(rec[2])
					res.append(','.join(rec))
					break
		return resclass Solution:
	def invalidTransactions(self, transactions: List[str]) -> List[str]:
		
		temp=[]		
		for t in transactions:
			temp.append(t.split(','))
			
		res=[]  

<PREDICTION>
: 				t = 0.i]
			if = action[0]
			if am(amt) == 0:
				return.append(stractions[i])
				continue			for j in range(i+1, len(transactions)):
				if = = True[j]split(',')
				act int2[3] == '[ int(act(act2[1]) - int(act)) <= 60: city != city2[2]:
					res.appendend(transactions[i]] j[j]))
			 res(set(res))
 Solution:
	def invalidTransactions(self, transactions: List[str]) -> List[str]:
		
 = set
		
 = = set
		for		for i in transactions:
			nameords t.split(',')
			ifords0] = int(rec[2])
			records2] = int(rec[2])
			records.append(records
		
 t in sorted:
			if len in0] > rec:
				res =0] = rec(rec[1])
				records2] = str(rec[2])
				for.append(rec'.join(rec))
				rec
			
 i in range:
				if rec[0] == x[1] and rec(int[1]) - x(x[1])) <= 60: rec[3] != x[3]:
					rec[3] = x(rec[1])
					records2] = str(rec[2])
					res.append(','.join(rec))
					continue
			 resclass Solution:
	def invalidTransactions(self, transactions: List[str]) -> List[str]:
		
		if =[]
	
		for i in transactions:
			temp.append(t)split(',))
			
		temp=[]


	
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 91000
----------------------------------------------------------------------------------------------------
<INPUT>
:  = min(maximx, calcdiff(t[:i] + t[i+1:]))
print(maximx)
	
n = int(input())
a = list(map(int, input().split()))

def f(a):
	mm = float('-inf')
	for x in range(len(a)-1):
		mm = max(mm, a[x+1] - a[x])
	return mm

ans, ansx = -1, float('+inf')
for i in range(1, n-1):
	nn = f(a[:i]+a[i+1:])
	if nn < ansx:
		ans, ansx = i, nn
print(ansx)
def main():
	n = int(input())
	aa = list(map(int, input().split()))
	bb = [b - a for b, a in zip(aa[1:], aa)]
	print(max(min(a + b for a, b in zip(bb[1:], bb)), max(bb)))


def __starting_point():
	main()

__starting_point()n, p, m = input().split()
n = int(n)
p = int(p)
m = int(m)

ans = 0
curb = 0
curd = 1
for i in range(0, n):
	#print(curb)
	tday, tplus = input().split()
	tday = int(tday)
	tplus = int(tplus)
	if curb < 0:
		ans += (tday - curd)
		curb -= p * (tday - curd)
	elif curb - p * (tday - curd) < 0:
		curb -= p * (tday - curd)
		x = -curb
		xx = x // p
		if xx * p < x:
			xx += 1
		x = xx
		ans += x
	else:
		curb -= p * (tday - curd)
	curd = tday
<PREDICTION>
:  0(ans_,, max_()a,ii]))) t[i +1:))
	(maximx)
import
	 = int(input())
a = list(map(int, input().split()))

b f(x,
	return = 0(-inf')
	for i in a(n(a)1):
		mm = min(mm, a[x+1]- - a[x])
	return mm

def = c2 = 01, -('infinf')

 x in range(n, n):1):
	ans = a(a[ii]a[i+1:])
	if nn < ans::
		ans = ansx = n, 1n

(ans,)
n main():
	n = int(input())
	a = list(map(int, input().split()))
	ans = list0 - a for a, a in zip(aa,1:], aa[
	bb(max(bb(bb + b for a, b in zip(bb,1:], bb[ max(aa[

def __starting_point():
	main()

__starting_point()n = m = q = list().split()
n = int(n)
p = int(p)
m = int(m)

a = 0
for = = 0

000 = 0

 i in range(n, n):
	aprint(i0000,
	if = = num1 = input().split()
	tplus = int(tplus)
	ifplus = int(tplus)
	c t == p:
		c = ttplus - 167) *		c % = 1
 ttplus - curd)
		if t == t > (tplus - curd) < 0:
		ans % += p * (tday - curd)
		c = t1000
		if = t + t
		if xx < x > 0:
			ans = 1
		ans -= x
		if += x
	else:
		ans----- += p * (tday - curd)
		 % -= 0plus

----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 91500
----------------------------------------------------------------------------------------------------
<INPUT>
: i][1] for i in range(n))
deno = sum(a[i][0] for i in range(n))

if nume / deno > t:
	op1, op2, rev = gt, le, False
else:
	op1, op2, rev = lt, ge, True

a.sort(key=itemgetter(1), reverse=rev)

while len(a) > 1 and op1((nume - a[-1][0]*a[-1][1]) / (deno - a[-1][0]), t):
	nume -= a[-1][0] * a[-1][1]
	deno -= a[-1][0]
	a.pop()

nume -= a[-1][0] * a[-1][1]
deno -= a[-1][0]
ok, ng = 0.0, float(a[-1][0])

for _ in range(50):
	mid = (ok + ng) / 2
	if op2((nume + mid * a[-1][1]) / (deno + mid), t):
		ok = mid
	else:
		ng = mid

print(deno + ok)
MOD = 10**9+7
n = int(input())

notUsed = set(range(1, n+1))
chairs = set()
for i, a in enumerate(map(int, input().split()), 1):
	if a == -1:
		chairs.add(i)
	else:
		notUsed -= {a}
fixed = len(chairs & notUsed)

m = len(notUsed)
U = m
fact = [0]*(U+1)
fact[0] = 1
for i in range(1, U+1):
	fact[i] = fact[i-1]*i % MOD


invfact = [0]*(U+1)
invfact[U] = pow(fact[U], MOD-2, MOD)
for i in reversed(list(range(U))):
	invfact[i] = invfact[i
<PREDICTION>
: ]j] = i in range(n)]
	 = = [(a[i][1] for i in range(n))

for den == == deno > 0:
	print = = op2 = a1 0cd, a1 a
	:
	op1, op2, rev = gt, le
 False

if[sort()key=lambdagetter(0), reverse=True)

if a(a) > 0: a1 >a -, a[01][0])))2[-1][0] > 2ao - a[-1][0] ()
	opume += a[-1][0]* a[-1][1]
	opo -= a[-1][1] *
op.pop()

ifume = a[-1][0] * a[-1][1]

o -= a[-1][1] *
 = ng = 0,0, 0('1[-1][0]
whilewhile i in range(int):
	ng = (ng + ng) / 2
	if mid1(midume - mid) a[-1][0]) / 2deno - a * a):
		ok = mid
	else:
		ng = mid

print(oko) ok)
n = 10**9 +7
N = int(input())
aa_ = [()map(1, n+1))

 = [(

 i in j in enumerate(map(int, input().split())), 1):
	if a in 01:
		not.add(i)
	else:
		not]:. seti}

 = set(not) set):)

def = n(not()

 = len

 = [1] *(U+1)
fact[0] = 1
for i in range(1, U+1):
	fact[i] = fact[i-1]*i% MOD

deffact = [0]*(U+1)
invfact[U] = pow(fact[U], MOD-2, MOD)
for i in range(list(range(U))):
	invfact[i] = invfact[i+
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 92000
----------------------------------------------------------------------------------------------------
<INPUT>
: QcpEK1YdKLALxY8swZFZteeMMvujkMsVuarKF8GeYJ5ZV3TEz/YmKj4Y9DKE7FmClJGuPsh/Cdc9ygaqq0wW3f4RHYc2mXGk82vHCG/Q3SiMQRchb+M49XY+zjGXbYlJznh5O8DSwcC4z3h89ivgY9Q0mJ839HGaf8YMIz38d3pjkcpYjE2ocGEaUhmp2wSdcrCAVMKrinZ1w2A0W2Igya0s0eQyYwVdhtIZ3Mc8YgNvwHz6cU0KehfrCM7+mADseLwrFkOF+JIa9psv75csgF248HuaBDW70/OgXNpezcm5ceiGkTLIf08QJ7fEyUsnDv5T5nfNtcbY/WA7q6YnHJBcrJeT9VomRkO0dw4m3DKENSY4P3zGFeOH9A5IfzA2eH4qrxrhvC9WZ3TF3cSAnl1gRbplYO8sLztTOU4N6khodH/Z8wYGdLwaO1p2KUSBswRoGMEwIeDXe2AYdeJHPBGkZ1/0JcLTF38To+Ppc3+pAWd5FAQP1TN6x+0l6KhtV3KJnhKZGjjV2+FLneOQ4o2EqG3uegBzzM2GuKwLS14dZo9TuchPp7sWGIeuloj5S7YT5YK6sKwdKOFEfx8h1hizm9CVTcsCIlp80ylR28K/daY8TXJk+Uy9a6o6dzhBtuyT6QVR5JdXqf3
<PREDICTION>
: .[Q
,Y
22QKYdXY
YUXQZZZQ1ZzZZYYYyZzZZZZIZZ4YYzlYYYc
z54ZZJQYA84XA11g0b404b3QYZbGgkCJgYZZF2Q9YZWcBkW++Z5ZJZjZGQ6gRGyZYQXbZJZZyYYZd9bbZcbZuJGGEYGzzgZQbgz15W3wc2QWZJjjZ2f2zGZzZ00YW63ZZgbZbJZgZ6gW66bQGQ1uZ5b2Y2ZR2chgRWbZWJXcbZQQ3fJgKVgbJYQYkQQQWY5GZBBQYWyYYQZgB46jWbbCzZgbJbvf51zZzJZQbZybb6gbgZkoZf9Z80GoZQgg7OY74b47g+rG53K/X4Bb8ggZgCW4YRgRQQZc5b1v4BQ7gKzQQW56+22Z1QzQZyoZQ2/Ob5G2gbVZQXyQQZW+05QQH5QJNY4Z6y45Zg464Z5b1ZVz6p7/zX9g9Xkp0vQQQzcZW6b9/QQu55/64Qg5u8jZzQfZQZZoZbgVGQJbojJ/3IXvIQ0GBcZ54QzzxQY6GGG66Q6bzBb5ZZKQb
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 92500
----------------------------------------------------------------------------------------------------
<INPUT>
: rt(x))+1, 2):
  if x%i == 0: return False
 return True
 
for _ in range(int(inp())):
 n = int(inp())
 ml = [0]
 for i in range(1, n+1):
  for j in range(i):
   print(ml[-1],end=" ")
   if len(ml)==1:
	ml.append(ml[-1]+1)
   else:
	ml.append(ml[-1]+ml[-2])
  print()for i in range(int(input())):
 s=input()
 one=[0]*(len(s)+1) #number of ones from first place to i-th place
 for i in range(len(s)):
  if s[i]=='1':
   one[i+1]=one[i]+1
  else:
   one[i+1]=one[i]
 ans=0
 i=1
 r=2 #r for range in interval r=i+i**2
 while r<=len(s):
  r=i+i**2
  j=0
  while j<=len(s)-r:
   if one[j+r]-one[j]==i:
	ans+=1
	j+=1
   else:
	j+=abs(i-(one[j+r]-one[j]))
  i+=1
 print(ans)
cnt1_max = 315
arr_size = [None]*(cnt1_max)
for i in range(1, cnt1_max+1):
 arr_size[i-1] = (i*(i+1), i)

t = int(input())
for _t in range(t):
 s = input()
 n = len(s)
 tot1 = [0]*(n+1)
 for i in range(1, n + 1):
  if s[i - 1] == '1':
   tot1[i] = tot1[i - 1] + 1
  else:
   tot1[i] = tot1[i -
<PREDICTION>
: (n)
1
 (*
	 if x%y== 0:
 i
  True
def
def _ in range(int(inputp())):
 n, int(inp())
 x = 0int]* for i in range(n, n+1):
  x j in range(1+
   m(ml[j1], ml=" ")
   ml i(ml[ >0 and
	ml.append(ml[-1])1)
   if:
	ml.append(ml[-1])1[-2])
  (*
 _ in range(int(input())):
 n =input()
 n=0]
lenlen(s)+1)
0 of characters in left line
 i-th place
 for i in range(len(s)):
  if s[i]=='1':
   one[i+1]=one[i]+1
  else:
   one[i+1]=one[i]
 #=0
 for=0
 while=0
number= range( range i
i+1-2
 while i<lenlen(s):
  if=i+i**2
  ans=0
  while j<lenlen(s):r:
   if s[j+r]-one[j]==i:
	ans+=1
	j+=1
   else:
	j+=1(i-(one[j+r]-i[j]))
  i+=1
 print(ans)
fornt = =1 = int
c =size = [0] *c2nt1_max+
arr i in range(1, cnt1_max):1):
 arr_size[i]1] = (i*(i-1)) i)

def = int(input())
for i in in range(t):
 s = input().
 n = len(s)
 ans = = [0]*(n+1)
 tot i in range(n, n+ 1):
  tot s[i- 1] == '1':
   tot1[i] = tot1[i - 1] + 1
  else:
   tot1[i] = tot1[i - 1
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 93000
----------------------------------------------------------------------------------------------------
<INPUT>
:  = 10**9+7
ans = 0
l,h = 0,0
for x in range(1,n+2):
  l += x -1
  h += n -x +1
  if x >= k:
	ans += (h-l+1)
	ans = ans%mod
print(ans)def main():
	n,k = list(map(int,input().split()))
	mod = 10**9+7
	ans = 0
	for i in range(k,n+2):
		ans += (i*(n-i+1)+1) % mod
		ans = ans % mod
	print(ans)

def __starting_point():
	main()

__starting_point()from itertools import accumulate

# k個選んだ時の最小値と最大値が分かれば、個数が分かる？？
n,k = list(map(int, input().split()))
cumsum   = list(accumulate(range(n+1)))
cumsum_r = list(accumulate(range(n+1)[::-1]))

MOD = 10**9 + 7
ans = 0
for i in range(k, n+2):
	_min, _max = cumsum[i-1], cumsum_r[i-1]
	ans = (ans + _max - _min + 1) % MOD

print(ans)def main():
	n = int(input())
	a = list(map(int, input().split()))
	s = sum(a)
	
	if s % 3 != 0 or len(a) < 3:
		print(0)
		return

	_s = s // 3
	sums = [0] * (n+1)
	ss = 0
	for i in range(n-1, 1, -1):
		ss += a[i]
		sums[i] = sums[i+1] + int(ss == _s)

	res = 0
	ss
<PREDICTION>
:  0**9+7
	 = 0
for = r, [,0
for i in range(n,n+1):
	 if = x
 1
  h += x- x
 1
  ans x >= h:
	ans += 1h-l)*1)// h % ans%mod
 (ans)
 main():
	n, k = list(map(int,input().split()))
	mod = 9**9+7
	if = 0
	for i in range(1,n+2):
		ans += ii-(n-i+1)1)*% mod
		ans % ans % mod
	print(ans)

def __starting_point():
	main()

__starting_point()n sysertools import accumulate

n � =��選�だと�の最大�兀�
し�大値をk�からる�、k��数がk�から
��
��
#, k = map(map(int,input().split()))

 =um = = = (accumulate(list(1,1,

umsum sum = [(accumulate(range(n+1)))1-1]))

# = 10**9+ 7

 = 0
for i in range(k,n+2):
	ansans = _max = cumsum_i]1] cumsum_r[i]1]
	ans += (ans + _min) _min + _) % MOD
printprint((ans)
 main():
	n, int(input())
	a = list(map(int, input().split()))
	ans = sum(a)
	ans	ans s == 2 == 0: s(a) % 3:
		print((0)
		return
	ansmin = s // 3
	_ -= = [s] * (n +1)
	for = 0
	for i in range(n):1, -, -1):
		ss += a[i]
		ssums[i] = ss[i-1] + a(s/ as)
	ans = 0
	for =
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 93500
----------------------------------------------------------------------------------------------------
<INPUT>
:  M))

ans = 0
for i in range(N + 1):
	Ti = (modFacts[N] * invs[i] * invs[N - i]) % MOD
	Ti *= (modFacts[M] * invs[M - i]) % MOD
	Ti %= MOD
	Ti *= pow(modFacts[M - i] * invs[(M - i) - (N - i)], 2, MOD)
	Ti %= MOD
	ans += pow(-1, i) * Ti
	ans %= MOD

print(ans)from sys import stdin
import sys
import math
from functools import reduce
import functools
import itertools
from collections import deque,Counter
from operator import mul
from functools import reduce


N = 10**6
mod = 10**9+7

inv_t = [0] + [1]
for i in range(2, N):
	inv_t += [inv_t[mod % i] * (mod - int(mod / i)) % mod]

kai = [1, 1]
rev_kai = [1, inv_t[1]]
for i in range(2, N):
	kai.append(kai[-1] * i % mod)
	rev_kai.append(rev_kai[-1] * inv_t[i] % mod)

def cmb(n, r):
	return kai[n] * rev_kai[r] * rev_kai[n - r] % mod

def prm(n, r):
	return kai[n] * rev_kai[n - r] % mod

n,m = list(map(int, input().split()))

a = 0
for k in range(n+1):
	a += prm(m, k)*prm(m-k,n-k)**2*(-1)**k*cmb(n,k) % mod

print(a % mod)def prepare(n, MOD):
 
	# n! の計算
	f = 1
	fn=[1]*(n+1)
	for
<PREDICTION>
: :
	def = 0
for i in range(N): 1):
	ans = iA_[[i - * pow_[i]) % pows[N - i]) % MOD
	ans *= invMODFacts[N] * invs[M - i]) % MOD
	ans %= MOD
	ans *= inv(iFacts[M - i], * invs[MM - i)]) 1M - i)]) MOD) MOD)
	ans %= MOD
	ans += ((1, M,
 (
	ans %= MOD

print(ans)
 collections import stdin
input sys
import n
from functools import reduce
import functools
import itertools
from collections import deque,Counter,from operator import mul
import functools import reduce

sys, int **6+modF 9**9 +7

# =t = [0,* [0]
for i in range(2, N):
	inv_t. [inv_t[mod % i] * (mod - int(mod/ i)) % mod]

def = [1] 1]
for_kai = [1, inv_t[1]]
rev i in range(2, N):
	kai.append(kai[-1] * i % mod)
	rev_kai.append(rev_kai[-1] * inv_t[i] % mod)

ans nmb(n, r):
	if (ai[n] * rev_kai[r] * rev_kai[n- r] % mod

def solve((n, r):
	return kai[n] * rev_kai[n - r] % mod

def = m = map(map(int, input().split()))
aans = list
b i in range(m +1):
	a = cm(m- k)am(m-1, n-k)
2
(1)**(
revmb(n- k)*** mod

print(a% mod)
 c(n, MOD):
	
	# 1Cr^の計算
	_ = 1
	fact =1]*(n+1)
	f i
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 94000
----------------------------------------------------------------------------------------------------
<INPUT>
: +1][0] + dp[i][0]) % mod
			dp[i+1][1] = (dp[i+1][1] + dp[i][1]) % mod
			dp[i+1][2] = (dp[i+1][2] + dp[i][2]) % mod
			dp[i+1][3] = (dp[i+1][3] + dp[i][3]) % mod
			dp[i+1][3] = (dp[i+1][3] + dp[i][2]) % mod

	print((dp[n][3]))

def __starting_point():
	main()

__starting_point()S=input()
A=0 #Aの数
B=0 #ABの数
C=0 #ABCの数
n=1 #通り数
mod=10**9+7
for s in S:
	if s=="?":
		C=3*C+B
		B=3*B+A
		A=3*A+n
		n*=3
	elif s=="A":
		A+=n
	elif s=="B":
		B+=A
	else:
		C+=B
	A%=mod
	B%=mod
	C%=mod
	n%=mod
print(C)s = input()
MOD = 10 ** 9 + 7
dp = [1, 0, 0, 0]

for x in s:
	emp, a, b, c = dp
	if x == 'A':
		dp[1] += emp
	if x == 'B':
		dp[2] += a
	if x == 'C':
		dp[3] += b
	if x == '?':
		dp = [v * 3 for v in dp]
		dp[1] += emp
		dp[2] += a
		dp[3] += b

	dp = [v % MOD for v in dp]

print(dp[3])md=10
<PREDICTION>
: 1)j]
 1p[i-0] % MOD
				[i+1][1] = ddp[i][1][1] + dp[i][1]) % mod
			dp[i+1][2] = (dp[i+1][2] + dp[i][2]) % mod
			dp[i+1][3] = (dp[i+1][3] + dp[i][3]) % mod
			dp[i+1][4] = (dp[i+1][3] + dp[i][3]) % mod
	print(dp[n][3]))


def __starting_point():
	main()

__starting_point()import =input()
N=len
 (=��
B=0 #B
��
for=0 #Bの数

=len
B�り
�
mod=10**9+7

 i in S:
 if s=="":
		A+=1
(+1
	elA=1*C+A
		A=A*A+B
		A==2
		if s=="A":
		A=A
		if s=="B":
		B+=n
		:
		C+=B
		==mod
printB%=mod
printC%=mod
printA*=mod
print(A)S = input()

 = 10** 9 + 7

 = [[0] 1, 0, 0,
dpfor c in s:
	if = d, b = c = (p[	if ( == 'A':
		dp[0] = dp
		 x == 'B':
		dp[2] += a
	if x == 'C':
		dp[3] += a
	if x == 'A:
		dp[ [dp % 3 % v in dp]
	dpdp[4] % cp
	dpdp[2] += a
	dpdp[3] += b
	dp[ d0 * MOD] v in dp]

print((sum[3])S =10**
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 94500
----------------------------------------------------------------------------------------------------
<INPUT>
:  tree")
else:
	if not t in s:
		if len(s) > len(t):
			j = 0
			both = False
			for i in range(len(t)):
				while j < len(s) and s[j] != t[i]:
					j += 1
				if j >= len(s):
					both = True
				j+=1
			if both:
				print("both")
			else:
				print("automaton")
		else:
			print("array")
	else:
		print("automaton")		n = int(input())

board =[]

for i in range(n):
	board.append(list(input()))
	
f = 1
for i in range(n):
	for j in range(n):
		if board[i][j] == '.':
			if i < n - 2 and j < n - 1 and j > 0 and board[i+1][j] == '.' and board[i+2][j] == '.' and board[i+1][j-1] == '.' and board[i+1][j+1] == '.':
				board[i+1][j] = '#'
				board[i+2][j] = '#'
				board[i+1][j-1] = '#'
				board[i+1][j+1] = '#'
			else:
				f = 0
				break

if f == 1:
	print("YES")
else:
	print("NO") n = int(input())
arr = [[x for x in input()] for _ in range(n)]
move = [(1, -1), (1, 0), (1, 1), (2, 0)]
for i in range(n):
	for j in range(n):
		if arr[i][j] == '.':
	
<PREDICTION>
: .
	:
	print len tree: tree:
		print t(s) == len(t):
			print = 0
			while = t
			while i in range(len(t)):
				if j < len(t) and t[j] == t[i]:
					j += 1
				if j == len(t):
					both = True
					 +=1
				 not:
				t("YES")
			else:
				print("bothew")")
	elseelse:
			print("array")
	else:
		print("arrayomfor")


 = int(input())
fors = []
forfor i in range(n):
	board.append(input(map()))


for = True

 i in range(n):
	for j in range(n):
		if board[i][j] == '.':
			if f > n - 1 and board < n - 1: board < 0: board[i +1][j- == '.': board[i+1][j] == '.' and board[i+1][j+1] == '.' and board[i+2][j+1] == '.' and
				f[i][1][j] = 'a'
				board[i+1][j] = '#'
				f[i+1][j+1] = '#'
				board[i+2][j+1] = '#'
				:
				board = 0
				break
	if f == 0:
	print('array")
else:
	print("NO")
  = int(input())
a = []0 for x in input()] for _ in range(n)]

 = 01, 01), (0, 0), (-0, 0), (-0, -)]

 i in range(n):
	for j in range(n):
		if arr[i][j] == '.':
		
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 95000
----------------------------------------------------------------------------------------------------
<INPUT>
:  C[i, 1]

	for k in range(N):
		for i in range(N):
			for j in range(N):
				dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])

	ans = 0
	for i in range(H):
		for r in LI():
			if r != -1:
				ans += dist[r][1]
	print(ans)




def __starting_point():
	solve()


__starting_point()import heapq
H,W = map(int, input().split())
C = []
for i in range(10):
	C.append(list(map(int, input().split())))
INF = float("inf")

def dfs(x):
	memo = [INF]*10
	memo[x] = 0
	hq = [(0,x)]
	heapq.heapify(hq)
	while hq:
		cost,step = heapq.heappop(hq)
		if cost > memo[step]:
			continue
		for j,c in enumerate(C[step]):
			if memo[j] > memo[step] + c:
				memo[j] = memo[step] + c
				heapq.heappush(hq,(memo[j],j))
	return memo[1]

A = [0]*10
for h in range(H):
	for w in map(int, input().split()):
		if w == -1:
			continue
		else:
			A[w] += 1
ans = 0
for number, a in enumerate(A):
	ans += a*dfs(number)
print(ans)H,W = map(int,input().split())
c = [list(map(int,input().split())) for i in range(10)]
A = [list(map(int,input().split())) for i in range(H)]

<PREDICTION>
: [i] j]
		 i in range(2):
		if i in range(N):
			for j in range(N):
				if =i][j] = abs(dist[i][j], dist[i][k] + dist[k][j])

	ans = 0
	for i in range(N):
		for j in range:
			if r == -1:
				ans += dist[r][i]

	return(ans)



def __starting_point():
	mainolve()

__starting_point()import nq
h, W= map(int,input().split())
C = [
for i in range(H):
	c.append(list(map(int, input().split())))

F = 10('inf")

for difs(x,
	ifo = [[INF]*10
	memo[x] = 0
	for = = []0,x)]
	whileapq.heapify(hq)
	while hq:
		d,now = heapq.heappop(hq)
		if memo >mem[step]:
			continue
		for i,w in enumerate(C):step]):
			if c[j] > memo[step] + c:
				memo[j] = memo[step] + c
				heapq.heappush(hq,(costo[j]+j))
	return memo[x]

ans = d0]*10
for i in range(1):
	for w, range(int, input().split()):
		A h != 01:
			A
		A:
			A[h] += A

 = 0
for i in value in Aate(A):
	if += A
As(a)
print(ans)import, W = map(int,input().split())
C = [list(map(int,input().split())) for i in range(10)]

 = [0(map(int,input().split())) for i in range(H)]


----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 95500
----------------------------------------------------------------------------------------------------
<INPUT>
:  of beer on the wall, 46 bottles of beer.\nTake one down and pass it around, 45 bottles of beer on the wall.\n45 bottles of beer on the wall, 45 bottles of beer.\nTake one down and pass it around, 44 bottles of beer on the wall.\n44 bottles of beer on the wall, 44 bottles of beer.\nTake one down and pass it around, 43 bottles of beer on the wall.\n43 bottles of beer on the wall, 43 bottles of beer.\nTake one down and pass it around, 42 bottles of beer on the wall.\n42 bottles of beer on the wall, 42 bottles of beer.\nTake one down and pass it around, 41 bottles of beer on the wall.\n41 bottles of beer on the wall, 41 bottles of beer.\nTake one down and pass it around, 40 bottles of beer on the wall.\n40 bottles of beer on the wall, 40 bottles of beer.\nTake one down and pass it around, 39 bottles of beer on the wall.\n39 bottles of beer on the wall, 39 bottles of beer.\nTake one down and pass it around, 38 bottles of beer on the wall.\n38 bottles of beer on the wall, 38 bottles of beer.\nTake one down and pass it around, 37 bottles of beer on the wall.\n37 bottles of beer on the wall, 37 bottles of beer.\nTake one down and pass it around, 36 bottles of beer on the wall.\n36 bottles of beer on the wall, 36 bottles of beer.\nTake one down and pass it around, 35 bottles of beer on the wall.\n35 bottles of beer on the wall, 35 bottles of beer.\nTake one down and pass it around, 34 bottles of beer on the wall.\n34 bottles of beer on the wall, 34 bottles of beer.\nTake one down and pass it around, 33 bottles of beer on the wall.\n33 bottles of beer on the wall, 33 bottles of beer.\nTake one down and pass it around, 32 bottles of beer on the wall.\n32 bottles of beer on the wall, 32 bottles of beer.\nTake one down and pass it around, 31 bottles of beer on the wall.\n31 bottles of beer on the wall, 31 bottles of beer.\nTake one down and
<PREDICTION>
:  the. the wall, 3 bottles of beer.\nTake one down and pass it around, 45 bottles of beer on the wall.\n45 bottles of beer on the wall, 45 bottles of beer.\nTake one down and pass it around, 44 bottles of beer on the wall.\n44 bottles of beer on the wall, 44 bottles of beer.\nTake one down and pass it around, 43 bottles of beer on the wall.\n43 bottles of beer on the wall, 43 bottles of beer.\nTake one down and pass it around, 42 bottles of beer on the wall.\n42 bottles of beer on the wall, 42 bottles of beer.\nTake one down and pass it around, 41 bottles of beer on the wall.\n41 bottles of beer on the wall, 41 bottles of beer.\nTake one down and pass it around, 40 bottles of beer on the wall.\n40 bottles of beer on the wall, 40 bottles of beer.\nTake one down and pass it around, 39 bottles of beer on the wall.\n39 bottles of beer on the wall, 39 bottles of beer.\nTake one down and pass it around, 38 bottles of beer on the wall.\n38 bottles of beer on the wall, 38 bottles of beer.\nTake one down and pass it around, 37 bottles of beer on the wall.\n37 bottles of beer on the wall, 37 bottles of beer.\nTake one down and pass it around, 36 bottles of beer on the wall.\n36 bottles of beer on the wall, 36 bottles of beer.\nTake one down and pass it around, 35 bottles of beer on the wall.\n35 bottles of beer on the wall, 35 bottles of beer.\nTake one down and pass it around, 34 bottles of beer on the wall.\n34 bottles of beer on the wall, 34 bottles of beer.\nTake one down and pass it around, 33 bottles of beer on the wall.\n33 bottles of beer on the wall, 33 bottles of beer.\nTake one down and pass it around, 32 bottles of beer on the wall.\n32 bottles of beer on the wall, 32 bottles of beer.\nTake one down and pass it around, 31 bottles of beer on the wall.\n31 bottles of beer on the wall, 31 bottles of beer.\nTake one down and pass
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 96000
----------------------------------------------------------------------------------------------------
<INPUT>
:  \le k \le 30$) — number of cards and number of features.

Each of the following $n$ lines contains a card description: a string consisting of $k$ letters "S", "E", "T". The $i$-th character of this string decribes the $i$-th feature of that card. All cards are distinct.


-----Output-----

Output a single integer — the number of ways to choose three cards that form a set.


-----Examples-----
Input
3 3
SET
ETS
TSE

Output
1
Input
3 4
SETE
ETSE
TSES

Output
0
Input
5 4
SETT
TEST
EEET
ESTE
STES

Output
2


-----Note-----

In the third example test, these two triples of cards are sets:  "SETT", "TEST", "EEET"  "TEST", "ESTE", "STES"You are given a tree (a connected undirected graph without cycles) of $n$ vertices. Each of the $n - 1$ edges of the tree is colored in either black or red.

You are also given an integer $k$. Consider sequences of $k$ vertices. Let's call a sequence $[a_1, a_2, \ldots, a_k]$ good if it satisfies the following criterion:  We will walk a path (possibly visiting same edge/vertex multiple times) on the tree, starting from $a_1$ and ending at $a_k$.  Start at $a_1$, then go to $a_2$ using the shortest path between $a_1$ and $a_2$, then go to $a_3$ in a similar way, and so on, until you travel the shortest path between $a_{k-1}$ and $a_k$. If you walked over at least one black edge during this process, then the sequence is good.  [Image] 

Consider the tree on the picture. If $k=3$ then the following sequences are good: $[1, 4, 7]$, $[5, 5, 3]$ and $[2, 3, 7]$. The following sequences are not good: $[1, 4, 6]$, $[5,
<PREDICTION>
: leq \le 10$) —— the of elements in number of cards.

The of the next $k$ lines contains two string,: $ card $ of lowern$ characters 'a", "T" "W"
 $i$-th character of this string isoded is $i$-th card is the string.
 the are distinct.


-----Output-----

Print a single integer — the maximum of possible to choose the cards to are a valid of


-----Examples-----
Input
6 2
S






Output
2


4 3
((





E

Output
2
Input
5 4
(








T


T
Output
2

-----Note-----

In the first example, there there three cardsples are the are:: " T",". "SEST", "T"",  "TEST", "T",", "T"."  are given an string withan tree undirected graph without cycles) consisting $n$ vertices. The vertex the $n- 1$ vert is the tree is a red the $ or white.

You have given given a integer $n$ You the of vertn$ vertices $ The's denote a sequence ofbl_1, a_2, \dots, a_k]$ of if $ is the following conditions:

  can choose from pair fromi none a,)vistex $ times), and the path. and from thea$1$ to ending from $a_2$. 
 at thea_{1$ and it to thea_{2$; the path path, verta_1$ and $a_2$, then go to $a_3$ using this path way. and then on. the we walk to path path between $a_1-1}$ and $a_{1-  you travel at the $ one path path, the edge, you you shortest of good. 
Image] 

You the following $ the tree below The youk=2$ then you path graph are not: [1, 2, 6]$ $[1, 7, 6,$, and $[4, 4, 2]$
 sequence sequence are not good: $[1, 4] 6]$, $[1, 3
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 96500
----------------------------------------------------------------------------------------------------
<INPUT>
: heap, (0,0,0))
 while len(heap)!=0:
  item=heappop(heap);
  top=max(0,item[2]-k)
  bottom=min(n-1,item[2]+k)
  for y in range(top,bottom+1):
   c=k-abs(y-item[2]) 
   left=max(0,item[1]-c)
   right=min(m-1,item[1]+c)
   for x in range(left,right+1):
	if a[y][x]==0:
	 if mat[y][x]>(item[0]+1):
	  mat[y][x]=item[0]+1
	  heappush(heap, (mat[y][x],x,y))
def getDistancesBot2(a,n,m,mat,k):
 for i in range(n):
  mat.append([20000 for j in range(m)])
 heap = []
 mat[0][m-1]=0;
 heappush(heap, (0,m-1,0))
 while len(heap)!=0:
  item=heappop(heap);
  top=max(0,item[2]-k)
  bottom=min(n-1,item[2]+k)
  for y in range(top,bottom+1):
   c=k-abs(y-item[2]) 
   left=max(0,item[1]-c)
   right=min(m-1,item[1]+c)
   for x in range(left,right+1):
	if a[y][x]==0:
	 if mat[y][x]>(item[0]+1):
	  mat[y][x]=item[0]+1
	  heappush(heap, (mat[y][x],x,y))
 
t=int(input().strip())
for i in range(t):
 [n,m,k1,k2] = list(map(int,input().strip().split(' ')));
 arr=
<PREDICTION>
: apqhecur, 0)0,
	 i(heap)=0:
  x=heapop(heap)
  if=item(top,item[1]-top)
  if=max(len,1,top[2]-k)
  if i in range(top,0+1):
   if[0;y(x-i[0])

   if=max(0,x[2]-c);
   right=min(n-1,y[2]+c)
   for x in range(left,right+1):
	if x[x][x]>left:
	 a top[y][x]==k[0]k):
	  mat[y][x]=1[0]+1
	  matappush(heap,(item[y][x],item))y))
	 b_((((mat,b):k):k):n):
 for i in range(n):
  for[append([])001, j in range(m)])
 q []
 for[0][0]1]=0

 forappush(heap, (0,m-1,0))
 while len(heap)=0:
  item=heappop(heap)
  top=max(0,item[2]-k)
  for=min(m-1,item[2]+k)
  for y in range(top,bottom+1):
   c=k-abs(y-item[2])

   left=max(0,item[2]-c)
   right=min(n-1,item[2]+c)
   for x in range(left,right+1):
	if a[y][x]==0:
	 mat mat[y][x]!item[0]+1):
	  mat[y][x]=item[0]+1
	  heappush(heap, (a[y][x],x,y))
	  =int(input())strip())
for i in range(t):
 nn,m,k]=,n2]==( map(map(int,input().strip().split() ')))),
 mat1[]
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 97000
----------------------------------------------------------------------------------------------------
<INPUT>
: 			hours += math.ceil(pile/maxBananas)
	
				if hours > H:
					return False
			return True
		
		
		left = 1 # Slowest
		right = max(piles) # Fastest
		
		while left < right:
			mid = left + (right - left)//2
			
			if feasible(mid):
				right = mid
			else:
				left = mid + 1
				
		return leftclass Solution:
	def minEatingSpeed(self, piles: List[int], H: int) -> int:
		n = len(piles)
		if not n:
			return -1
		
		def binary_search(l, r):
			nonlocal piles, H 
			while l < r:
				mid = (l + r) // 2
				if num_hours(mid) <= H:
					r = mid
				else:
					l = mid + 1
			return l
			
		def num_hours(k):
			nonlocal n, piles
			res = 0
			for i in range(n):
				num = piles[i]
				if k >= num:
					res += 1
					continue
				res += (num // k)
				res += 1 if (num % k) else 0 
			return res
		
		return binary_search(1, max(piles))
class Solution:
	def maxProbability(self, n: int, edges: List[List[int]], prob: List[float], start: int, end: int) -> float:
		weights = list(map(lambda x:-math.log2(x), prob))
		g = defaultdict(list)
		
	
		for (u, v), w in
<PREDICTION>
: 			 = 1.ceil(piles[2_))
			returnif	
 hours > D:
					return False
				 True
		
		
		
 = 1
 min the
		right = max(pile)
 min

		
		while left <= right:
			mid = left + (right - left) //2
			
			if is(mid):
				right = mid
			else:
				left = mid + 1
				
		return left
 Solution:
	def minEatingSpeed(self, piles: List[int], H: int) -> int:
		
 = len(piles)
		
 n n:
			return -1
		
		l is_search(K, r,
			midlocal piles
 H

			
 l < r:
				mid = (l + r) // 2
				if piles_p(mid, <= H:
					l = mid
				else:
					l = mid + 1
			return l
		

		p binary_hours(x):
			hlocal piles
 H,			n = 0
			for i in range(k-
				res = num[i]
				res num >= num:
					res += 1
				elsek
				res += nump // k)
				res += (
 resnum // k) > 0

			return res
		
		p binary_search(0) max(piles))
	 Solution:
	def minCofitability(self, n: int, p: List[List[int]], t: List[float], start: int, end: int) -> float:
		
 = list(it(lambda x:x.log2(x), prob))
		
 = []dict(list)
		for				for iu, v), w in zip
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 97500
----------------------------------------------------------------------------------------------------
<INPUT>
: ��数
		return -self.parents[self.find(x)]

	def members(self, x):	   #xと同じグループの要素
		root = self.find(x)
		return {i for i in range(self.n) if self.find(i) == root}

	def roots(self):			#親の要素一覧
		return {i for i, x in enumerate(self.parents) if x < 0}

	def group_count(self):	  #グループの個数
		return len(self.roots())

	def all_group_members(self):	  #グループのメンバー一覧
		return {r: self.members(r) for r in self.roots()}

	def __str__(self):
		return '\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())

################

from collections import Counter

def main():
	N, K, L = map(int, input().split())
	ufK = UnionFind(N)
	ufL = UnionFind(N)
	for i in range(K):
		a,b = map(int,input().split())
		ufK.union(a-1, b-1)
	for i in range(L):
		a,b = map(int,input().split())
		ufL.union(a-1, b-1)

	ps=[(ufK.find(i),ufL.find(i)) for i in range(N)]
	cps = Counter(ps)
	ret = [0]*N
	for i in range(N):
		ret[i] =cps[ps[i]]
	print(*ret)

def __starting_point():
	main()
__starting_point()n,c=map(int,input().split())
imos=[[0 for i in range(c)] for j in range(10**5+1)]#1~10**5+
<PREDICTION>
: ��を			 selfself.parents[x.find(x)]

	def same(self, x):
# # # xの�い�じグループの要素�		root = self.find(x)
		return [i: i in range(self.n) if self.find(i) == root]

	def roots(self):
			雁とリ�素を親を		return [i for i,x in enumerate(self.parents) if x < 0]

	def group_count(self):		 #�ループの怋数
		return len(self.roots())

	def all_group_members(self):
# #グループの�ントリ
庁を		return {r: self.members(r) for r in self.roots()}

	def __str__(self):
		return '\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())

N########
# collections import default

N main():
	n, M, L = map(int, input().split())
	A = = UnionFind(N)
	forL = UnionFind(N)
	for _ in range(K):
		x, b = map(int, input().split())
		ufK.union(a-1, b-1)
	ans i in range(L):
		uf,b = map(int,input().split())
		ufK.union(a-1, b-1)
	ansumufufK.find(i), uL.find(i)) for i in range(N)]
		nt=[ Counter(ps)
	print = 0c]*N
	for i in range(N):
		ret[ps] = cps[uf[i]]
	print(*ret)

def __starting_point():
	main()
__starting_point()import,k =map(int,input().split())

os=[[]int] i in range(n)] for i in range(n)]5+1)]
�か10^5の1
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 98000
----------------------------------------------------------------------------------------------------
<INPUT>
:  number Max resets the calculator. Find the total number of segments printed on the calculator.

For example if a = 1 and b = 3 then at first the calculator will print 2 segments, then — 5 segments and at last it will print 5 segments. So the total number of printed segments is 12.


-----Input-----

The only line contains two integers a, b (1 ≤ a ≤ b ≤ 10^6) — the first and the last number typed by Max.


-----Output-----

Print the only integer a — the total number of printed segments.


-----Examples-----
Input
1 3

Output
12

Input
10 15

Output
39A permutation of length n is an integer sequence such that each integer from 0 to (n - 1) appears exactly once in it. For example, sequence [0, 2, 1] is a permutation of length 3 while both [0, 2, 2] and [1, 2, 3] are not.

A fixed point of a function is a point that is mapped to itself by the function. A permutation can be regarded as a bijective function. We'll get a definition of a fixed point in a permutation. An integer i is a fixed point of permutation a_0, a_1, ..., a_{n} - 1 if and only if a_{i} = i. For example, permutation [0, 2, 1] has 1 fixed point and permutation [0, 1, 2] has 3 fixed points.

You are given permutation a. You are allowed to swap two elements of the permutation at most once. Your task is to maximize the number of fixed points in the resulting permutation. Note that you are allowed to make at most one swap operation.


-----Input-----

The first line contains a single integer n (1 ≤ n ≤ 10^5). The second line contains n integers a_0, a_1, ..., a_{n} - 1 — the given permutation.


-----Output-----

Print a single integer — the maximum possible number of fixed points in the permutation after at most one swap operation.


-----Examples-----
Input
5
0 1 3 4 2

Output
3You wrote down all integers from $0$ to $10^n - 1$, padding them with leading zeroes so their lengths are exactly
<PREDICTION>
:  of

. sum can
 the maximum number of ways, on the end.

----- example, the, ", b = 2, the the step segment are be 3.. and the  segments, so second two will be 5 segments.
, total number of segments segments is 2.

-----Input-----

The first line of two integers n and b (1 ≤ a, 10 ≤ 10^9). — the number and the second one of by the.


-----Output-----

Print the total integer k — the number number of segments segments.


-----Examples-----
Input
1 1

Output
2

Input
2 3

Output
15
 isutation of a n is an integer k of that a integer is 1 to nn - 1) is exactly once in this. For example, the [1, 1, 3, is an permutation of length 3: 3 sequences0, 1, 3] is [1, 1, 3]. are not.

A perm sequence is length perm is a sequence of has a to be. the length. For permutation of be described if a sequence- of if. For can call a perm of a given point of the singleutation.
 example is is the positive point of autation j_{i < a_1, ..., a_{n} is i is and only if for_{i} > 1,
 example, autation [0, 1, 3, is a, point of theutation [1, 1, 1] has 2 fixed point.

A are given autation a. Find need allowed to choose elements distinct of a permutation a the once.
 task is to find the number of pairs perm. the perm permutation.

 that you can allowed to swap the most one pair..


-----Input-----

The first line contains a single integer n (1 ≤ n ≤ 10^5) The second line contains n space a_0, a_1, ..., a_{n} - 1 ( the perm permutation.


-----Output-----

Print the single integer — the number possible number of swap points in the resultingutation. that most n swap operation.


-----Examples-----
Input
4
1 1 2 2 5

Output
3
 are a the the from 11$ to $n^9$ 1$. where it. numbers zeroes. that sum are $ $
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 98500
----------------------------------------------------------------------------------------------------
<INPUT>
: er:

	def __init__(self, words: List[str]):
		self.d={}
		for i in words:
			if(i[-1] not in self.d):
				self.d[i[-1]]=[i[:-1]]
			else:
				self.d[i[-1]].append(i[:-1])
				
		self.s=''
	def query(self, letter: str) -> bool:
		self.s+=letter
		if letter in self.d:
			for i in self.d[letter]:
				word=i+letter
				if len(self.s)>=len(word) and word==self.s[-len(word):]:
					return True
		return False
		


# Your StreamChecker object will be instantiated and called as such:
# obj = StreamChecker(words)
# param_1 = obj.query(letter)
from collections import deque, defaultdict


class StreamChecker:

	def __init__(self, words: List[str]):
		words = sorted(words, key=len)
		self.words_by_len = defaultdict(set)
		for word in words:
			if all(word[-length:] not in words_set for length, words_set in list(self.words_by_len.items())):
				self.words_by_len[len(word)].add(word)
		
		self.search_history = deque(maxlen=max(self.words_by_len.keys()))

	def query(self, letter: str) -> bool:
		self.search_history.append(letter)
		history = ''.join(self.search_history)
		
		return any(history[-length:] in words_set for length, words_set in list(self.words_by_len.items()))
			


# Your StreamChecker object will be instantiated and called as such:
<PREDICTION>
: (
	def __init__(self, words: List[str]):
		self.tic}
		for word in words:
			self ilen not-1] not in self.d):
				self.d[i[-1]]=i[:-1]]
			else:
				self.d[i[-1]].append(i[:-1])
		selfif
		self.string=''
		 query(self, letter: str) -> bool:
		self.s+=letter
		if( in self.d:
			for i in self.d[letter]:
				if=''[i
				if self(self.s)>1len(self):// word==self.s[::1(word):]:
					return True
			 False
			
# Your StreamChecker object will be instantiated and called as such:
# obj = StreamChecker(words)
# param_1 = obj.query(letter)
class collections import defaultque
 defaultdict

class TChecker:

	def __init__(self, words: List[str]):
		self = set(words, key=len,
		self.t =dict_dict = lendict(list)
		for w in words:
			self len(word[-i: in in list forby[ word in length_len in self(words.words_by_len[items())):
				continue.words_by_len[word(word)].add(word)
					self.string_word = deque([wordslen=self(self.words_by_len.keys()))
	def query(self, letter: str) -> bool:
		self.search_history.appendleftletter)
		if = self'.join(self.words_history)
		if		for self(\"[lenk: for self_by for length in set_set in self(self.words_by_len.items()))
		



# Your StreamChecker object will be instantiated and called as such:

----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 99000
----------------------------------------------------------------------------------------------------
<INPUT>
: , 2*l]
bx = base + (l-1)
c = [-l, 2*l]
cx = bx + l
d = [-2*l, 0]
dx = cx + l
e = [-l, -2*l]
ex = dx + l
f = [l, -2*l]
fx = ex + l
ax = fx + l
daa = abs(n-base+1)
da = abs(n-ax)
db = abs(n-bx)
dc = abs(n-cx)
dd = abs(n-dx)
de = abs(n-ex)
df = abs(n-fx)

if (n <= bx):
	print(int((db*a[0]+daa*b[0])/(db+daa)), int((db*a[1]+daa*b[1])/(db+daa)))
	quit()
	
if (bx <= n <= cx):
	print(int((dc*b[0]+db*c[0])/(db+dc)), b[1])
	quit()
	
if (cx <= n <= dx):
	print(int((dd*c[0]+dc*d[0])/(dc+dd)), int((dd*c[1]+dc*d[1])/(dc+dd)))
	quit()
	
if (dx <= n <= ex):
	print(int((de*d[0]+dd*e[0])/(dd+de)), int((de*d[1]+dd*e[1])/(dd+de)))
	quit()
	
if (ex <= n <= fx):
	print(int((df*e[0]+de*f[0])/(de+df)), e[1])
	quit()
	
if (fx <= n <= ax):
	print(int((da*f[0]+df*a[0])/(df+da)), int((da*f[1]+df*a[1])/(df+da)))
	quit()
def sLayer(n):
	return 3*n*(n+1)

def getLayer(N):
	a = 0
	b =
<PREDICTION>
:  input,n[
	 = = [ + b1 -1)
bx base1 for -*l]
forx = basex
 (

 = bb*l, -]
for = 0 = dx
dy = -2, -2*l]

 = c - l

 = -2, 22*l]
for = dx - l
g = x[
 (
ay = = c(dx)f)1)
byb abs(n-base+
dbb abs(n-absx)+
da = abs(d-cx)
da = abs(d-c)
if = d(d-d)

 = de(d-dc) +forif dib- ddx)
	if(f(da-(*0]da**db[0])/2*dca*0((db*c[0]+daa*b[0])/(db+daa)))
elsereturn()


if (nx <= n): c):
	print(int((da*ax0]+daac[1])/(db+daa intx0])
	quit()
	
if (cx <= n <= cx):
	print(int((dc*c[0]+da*c[0])/(db+da))) b((dd*c[1]+dc*c[0])/(dc+dd)))
	quit()
	
if (c <= n <= dx):
	print(int((dx*c[0]+da*c[0])/(dx+da* int(((*d[0]+dd*e[0])/(dd+da*
	quit()
	
if (dx <= n <= dxx):
	print(int((f*f[0]+de*sx0])/(d+f* int[1])
	quit()
	
if (ex <= n <= ex):
	print(int((df*a[0]+da*f[0])/(dx+1* int((df*f[1]+df*a[0])/(df+da*
	quit()
	 main((n,
	if n*(*(n-1)

def s_(n):
	if, [
	b = 0
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 99500
----------------------------------------------------------------------------------------------------
<INPUT>
: (float,input().split())
def LI(): return list(map(int, input().split()))
def TI(): return tuple(map(int, input().split()))
def LF(): return list(map(float,input().split()))
def Init(H, W, num): return [[num for i in range(W)] for j in range(H)]
	
	
def main():
	N, X = MI()
	L = LI()
	L = [abs(i-X) for i in L]
	ans = L[0]
	for i in L:
		ans = math.gcd(ans, i)
	print(ans)
	
	
def __starting_point():
	main()
__starting_point()t = int(input())
for case_num in range(t):
	n = int(input())
	print((n - 1) // 2)
from collections import defaultdict
import sys
sys.setrecursionlimit(1000000)

n, m, s = list(map(int, input().split()))
s = s - 1


def read_graph():
	g = defaultdict(list)
	for _ in range(m):
		(u, v) = [int(x) - 1 for x in input().split()]
		# if v != s:
		g[u].append(v)
	return g


G = read_graph()
vis = defaultdict(lambda: False)
topo = []


def dfs(u):
	# print(u)
	for v in G[u]:
		if not vis[v]:
			vis[v] = True
			dfs(v)
	topo.append(u)


for i in range(n):
	if not vis[i]:
		vis[i] = True
		dfs(i)

vis.clear()
vis[s] = True
dfs(s)
ans = 0
for i in topo[::-1]:
	if not vis[i]:
		vis[i] = True
		ans += 1
		dfs(i)
<PREDICTION>
: n(' input().split()
	 LI(): return list(map(int, input().split()))
def LI(): return tuple(map(int, input().split()))
def LF(): return list(map(float,input().split()))
def Init(H, W, num): return [[num for i in range(W)] for j in range(H)]
	
	
def main():
	N, M = LI()
	L = LI()
	L. [X(i-X) for i in L]
	L = 0[0]
	for i in range:
		if = max.gcd(ans, i)
	print(ans)
def
def
def __starting_point():
	main()
__starting_point()import = int(input())
for _ innum in range(t):
	n = int(input())
	l(n + 1) // 2)
t math import defaultdict
import math
input.setrecursionlimit(10000000)
inputdef = x = * = list(map(int, input().split()))

 -= [ - 1

def d_data(
	non = defaultdict(list)
	for i in range(m):
		uu, v) = listint(x) for 1 for x in input().split()]
		g u u == -:
		g[u].append(v)
		 g


def = read_graph()
sited [dict(int: False)

 = = -

def dfs(u):
	vis print(u)
	if v in G[u]:
		if not vis[v]:
			vis[v] = True
			dfs(v)

	topo.append(u)

def i in range(n):
	if not vis[i]:
		vis[i] = True
		tops(i)

ans =clear()
top[s] = True
tops(s)
# = top
for i in topo:0-1]:
	if not vis[i]:
		ans[i] = True
		ans += 1
print	dfs(i)

----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 99500
----------------------------------------------------------------------------------------------------
<INPUT>
: ]== "C" and s[j-1]== 'C':
   count +=1
  elif s[j]== 'E':
   if s[j-1]== 'C' or s[j-1]== 'E':
	count += 1
  elif s[j]== 'S':
   if s[j-1]== 'E' or s[j-1]== 'C' or s[j-1]== 'S':
	count += 1
 if count== len(s)-1:
  print("yes")
 else:
  print('no')# cook your dish here
# from queue import PriorityQueue
# import bisect
def insort(l, v):
	s = 0
	e = len(l)
	while True:
		mid = (s+e)//2
		if s == e or mid > len(l):
			break
		if l[mid][0] < v[0]:
			s = mid+1
		elif l[mid][0] > v[0]:
			e = mid
		else:
			break
	l.insert(mid, v)
	
for _ in range(int(input())):
	n,l = map(int, input().split())
	a_l = list(map(int, input().split()))
	
	dic = {}
	dif = 0
	for i,v in enumerate(a_l, start=1):
		if v not in dic:
			dic[v] = [i, i]
		else:
			dic[v][0] = min(dic[v][0], i)
			dic[v][1] = max(dic[v][1], i)
			dif = max(dif, dic[v][1]-dic[v][0])
			
	ans = dif
	if l <= len(set(a_l)):
		i_l = [[v,i] for i,v in enumerate(a_l, start=
<PREDICTION>
: 
01": and s[i]1]== "C':
	  print+= 1
  if s[j-== "?''
   count s[j-1]== "E' and s[j-1]== 'E':
	count +=1
  if s[j]== 'S':
   if s[j-1]== 'E' or s[j-1]== 'C' or s[j-1]== 'E':
	count += 1
  count==1(s)1:
  print("YES")
 else:
  print("no')
 cook your dish here
for cook math import QueQueue
from import sysect
# solveort(s,r):
 #l = 0
	i = len(l)
	for s:
		if = ints +e)//2
		if l+ v: s == l(l):
			return
		if l[mid]0] == v:0]:
			s = l
1
		elseif l[mid][0] > v[0]:
			e = mid-		else:
			break
	return[sort(v, v)
	returnfor _ in range(int(input())):
	n, m = map(int, input().split())
	s =l = list(map(int, input().split()))
	a	a = = {}
	foric = {}
	for i in v in enumerate(a_l, start=1):
		if v not in dic:
			dic[v] = 1i, i]
		else:
			dic[v][0] = i(dic[v][0], i)
			dic[v][1] = max(dic[v][1], i)
			dif = max(dif, dif[v][1])dic[v][0])
			d		 = 0ic
	if d == 0(l(a_l)):
		print = = = bisd, i] for i,v in enumerate(a_l, start=1
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 99500
----------------------------------------------------------------------------------------------------
<INPUT>
: ,m=input().split()
n=int(n);m=int(m)
ans=m
if m>=n:
	print(n)
	return
high=10**20;low=1
dif=n-m
#print("dif",dif)
while high-low>5:
	mid=high+low>>1
	if (1+mid)*mid>>1>=dif:
		high=mid
	else:
		low=mid
mid=max(0,mid-10)
while (1+mid)*mid>>1<dif:mid+=1
#print('mid',mid)
ans+=mid
print(ans)# -*- coding: utf-8 -*-
"""
Created on Wed Mar 15 23:00:22 2017

@author: Anan
"""

n,m = map(int,input().split())

if n<=m :
	print(n)
else :
	
	ans = m
	L =0
	R = 123456789123456789123
	while R-L != 1 :
		mid = (L+R)//2
		if n-mid*(mid-1)//2 <= m+mid :
			R=mid
		else :
			L=mid
	print(ans + R)"""Codeforces Round #404 (Div. 2)

C. Anton and Fairy Tale
"""


def main():
	n, m = list(map(int, input().split()))

	if n <= m:
		print(n)
		return

	def func(k):
		return n + (k - m - 1) * m + ((m * (m + 1)) // 2) - ((k * (k + 1)) // 2)

	start, end = m + 1, n
	while start < end:
		middle = (start + end) // 2
		if func(middle) <= 0:
			end = middle
		else:
			start = middle + 1

	print(end)


def __starting_point():
	main()


<PREDICTION>
:  5=map().split()
	=int(n)m=int(m)
a=0
for n>=0:
	ans(ans)
elsefor
if=min**9;high=0
while==0-m<whileprint(dif:dif,
while(-low>1:
	#=(high-low
1
	# midmid<<d)mid>1<nnif:
		high=mid
	else:
		low=mid
print=(mid(mid,mid-1)
if midmid+mid)*mid>>1>=if:
-1
#print(mid:mid)
while=mid
print(ans)
 -*- coding: utf-8 -*-
"""
Created onin Sep  21:53:54 2020

@author: mm



n, m = map(int, input().split())

if m >mm:
	print(n)
	 :
	print	print = m
	
 = 1
	R = m45678901
6789
456	while R-L> 1:
		
 = (R+R)//2
		if ( <=mid-midmid-1)//2 <= n :1*
			ans =mid
		else:
			L =mid
	
(R) L)n
eforces Round #335 (Div. 2)

import. [ and the are are"""

def main():
	n, m = [(map(int, input().split()))
	if n <= m:
		print(n)
	elsereturn

	if calc(n):
		if k * mk - 1) 1) * (

 (n - (k - 1)) // 2) * kn - (m - 1)) // 2)
	print = end = 1, 1, n +	while start < end:
		mid = (start + end) // 2
		if func(middle) < n:
			start = middle
		else:
			start = middle + 1

	print(start)


def __starting_point():
	main()

__
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 100000
----------------------------------------------------------------------------------------------------
<INPUT>
: input())

for _ in range(t):
 n,x=(int(x) for x in input().split())
 s,l=input().split()
 if(s=='R'):
  x=(n-x)+1
 if(l=='E'):
  if(x%2==0):
   l='H'
  else:
   l='E'
 elif(l=='H'):
  if(x%2==0):
   l='E'
  else:
   l='H' 
 print(x,l)
   
for _ in range(int(input())):
 S=input()
 n=len(S)
 A=[0]*26
 for i in S:
  A[ord(i)-65]+=1
 A.sort()
 A=A[::-1]
 res=n
 for i in range(26):
  if(n%(i+1)==0):
   F=n//(i+1)
   y=0
   for j in range(i+1):
	y+=min(A[j],F)
   res=min(res,n-y)
 print(res)
t = int(input())
for i in range(t):
 s = input()
 d = {}
 min1 = len(s)+1
 for i in s:
  if i not in d:
   d[i] = 1
  else:
   d[i] += 1
 l = [[x,y] for x,y in d.items()]
 l.sort(key = lambda j: j[1],reverse = True)
 for i in range(1,26):
  f = len(s)//i
  c = 0
  if len(s)%i != 0:
   continue
  j = 0
  while j < i and j < len(l):
   if l[j][1] >= f:
	c += f
   else:
	c += l[j][1]
   j += 1
  c = len(s)-c
  if c<min1:
  
<PREDICTION>
: ().
	def _ in range(t):
	,m,int(x) for x in input().split())
 if=t=0().split()
 l sx=='1'):
  print=x-x)1
 else(x=='L'):
  x(x==2==0):
   print=R'
  else:
   l=E'
 printif(s=='H'):
  if(x%2==0):
   l='H'
  else:
   l='H'

 else(l,l)#   
  _ in range(int(input())):
 n,input()
 n=len(S)
 if=0]*n
 for i in range:
  A[ord(i)-ord]+=1
 for=sort()
 for.A[::-1]
 for=[]
 for i in range(26):
  if(A%22+1)==0):
   res=0//ii+1)
   F=n
   for j in range(i):1):
	y=A(A[j],A)
   A=min(res,n//y)
 print(res)
 = int(input())
for _ in range(t):
 s = input()
 n = {}
 for = = s(s)1
 for j in s:
  if i not in d:
   d[i] = 1
  else:
   d[i] += 1
 for = lenmin, y] for x,y in d.items()]
 l.sort()key = lambda x: j[1]) reverse = True)
 for i in range(len,len):
  if = 0(s)
i
  if = 0
  for f(s)%i != 0:
   c
  for = i
  while j < i: c < i(l):
   c l[j][1] < i:
	c += l
	  else:
	c += l[j][0]
   j += 1
  l += min(s)c
  if c >01:
   min
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 100000
----------------------------------------------------------------------------------------------------
<INPUT>
: umulate(cum))

ans_prev = ans_1
ans_min = ans_1
for x in range(1, m):
	ans_x = ans_prev
	if x in counter:
		ans_x += sum((x - a) % m - 1 for a in counter[x])
	ans_x -= cum[x]
	ans_min = min(ans_min, ans_x)
	ans_prev = ans_x
print(ans_min)
N, M = list(map(int, input().split()))
As = list(map(int, input().split()))

ans = 0
numSts, numEns, sumEns = [0]*(2*M), [0]*(2*M), [0]*(2*M)
for i in range(N-1):
	A, B = As[i]-1, As[i+1]-1
	if A > B:
		B += M
	ans += B-A
	if B-A > 1:
		numSts[A+2] += 1
		numEns[B+1] += 1
		sumEns[B+1] += B-A-1

nums = [0]*M
num = 0
k = 0
for i in range(2*M):
	k += numSts[i] - numEns[i]
	num += k
	num -= sumEns[i]
	nums[i%M] += num

print((ans - max(nums)))
_,m,*A=map(int,open(0).read().split());S=l=3*m;D=[0]*l
for a,b in zip(A,A[1:]):
 b+=m*(b<a);k=b-a;S+=k
 if k>1:D[a+2]+=1;D[b+1]-=k;D[b+2]+=k-1
exec("for i in range(l):D[i]+=D[i-1]\n"*2);print(S-l-max(D[a
<PREDICTION>
: [(a_
	def =list = 0
prev =
_prev = ans_min
ans i in range(1, n):
	ans_prev = ans_x
	ans x < cum:
		ans_x = 1(cum - counter) * m for 1 for a in A[x])
		_min % a[x]
	ans_min = min(ans_min, ans_x)


_prev = ans_x
	(ans_min)
n, M = map(map(int, input().split()))
A = list(map(int, input().split()))

As = float
for = = = numS = = numSum = 00] *(N*N+ 00]*(2*M+ 00]*(2*M)

 i in range(N):1):
	num, B = list[i],As, As[i+1]-1
	if A > B:
		num, A
		 += A
A
	if A <A > 0:
		numSts[A]1] += 1
		numSs[A-2] += num
		numEns[A-2] += num-A-1
	forums = [0]*(
forS 0
for = 0
for i in range(M*M):
	num += numSts[i]
 numSs[i]
	numS num
	nS numEns[i]
	numums[i]M] += num//	for(min- num(nums)))
n,* =*_=map(int,open(0).read().split())d=sum=r*m
D=0]*m;for i inb in zip(A,A[1:]):
	-m*(b-a);D+=b-a
D+=a; c b>=:D[a]=2]=+=1;D[b+1]-=k-D[a+1]+=k-1
for=s i in range(l-D[i*+=k[i-1] ;n"*2);print(S-max*b(D[l]+
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 100000
----------------------------------------------------------------------------------------------------
<INPUT>
: 1+1+1+1) = 7 so returns 7
etc..

Have fun =)You are given an array of non-negative integers, your task is to complete the series from 0 to the highest number in the array.

If the numbers in the sequence provided are not in order you should order them, but if a value repeats, then you must return a sequence with only one item, and the value of that item must be 0. like this:
```
inputs        outputs
[2,1]     ->  [0,1,2]
[1,4,4,6] ->  [0]
```
Notes: all numbers are positive integers.

This is set of example outputs based on the input sequence.
```
inputs        outputs
[0,1]   ->    [0,1]
[1,4,6] ->    [0,1,2,3,4,5,6]
[3,4,5] ->    [0,1,2,3,4,5]
[0,1,0] ->    [0]
```Complete the function which takes two arguments and returns all numbers which are divisible by the given divisor. First argument is an array of `numbers` and the second is the `divisor`.

## Example

```python
divisible_by([1, 2, 3, 4, 5, 6], 2) == [2, 4, 6]
```Given a natural number n, we want to know in how many ways we may express these numbers as product of other numbers.

For example the number
```python
 18 = 2 x 9 = 3 x 6 = 2 x 3 x 3 # (we do not consider the product 18 x 1), (3 ways) 
```

See this example a bit more complicated,
```python
60 = 2 x 30 = 3 x 20 =  4 x 15 = 5 x 12 = 6 x 10 = 2 x 2 x 15 = 2 x 3 x 10 = 2 x 5 x 6 =  3 x 4 x 5 = 2 x 2 x 3 x 5 (10 ways)
```
We need the function ```prod
<PREDICTION>
: ,1)1)1+
 1
 the 7.	 =
``# fun coding [
 are given a array of integers-negative integers, and task is to find the function of the to n first value of the array.

You you array in the array are is equal empty the to should return in in you you you number is the you you should return an string of the the element in and if sequence of the value is be a.
 this:

`python[: =         1, 3,      [ 1,1]0]
 1,2]3,5]
  [1,
```

:
 numbers in in and and

`` is a of numbers:: on the input array.

`
[s          2,1,    [ [ [ [1,1,
``1,2]6]   [ [ [1,1]2]3]4]6]6]
``1,5,6, ->  [ [ [0,1,1,3,4,5,
``1,1,2, ->  [ [ [0,
```
 the function that returns a parameters: returns the the in are theisible by the given numberisors of
 number is the integer of integersn``, and returns number argument the numbernisor.

The Example

```python
sis_div_1,2, 3, 4, 5, 6, 3) == [1, 3, 5]
div`
 a positive number,, return will to find if a many div are can have the n in you. n numbers.

For example, number ````python
div == 1 + 2 = 3 x 3 = 9 x 4 = 4 x the1 can the have the first)) 3) sowex to

```

The the for: number sequence than: but
`python
2 = 3 x 10 = 3 x 30 = 1 6 x 30 = 3 x 20 = 2 x 20 = 6 x 20 x = = 6 x 20
 = = 2 x = = = = 2 6 x 12 = 12 = 2 x 3 x 3
 3 =we^)
```

 can to following ```sumd_
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
iteration = 100000
----------------------------------------------------------------------------------------------------
<INPUT>
: 
			i -= 1

n = int(input())
snacks = map(int, input().split())
fall = [0] * (n + 1)
for snack in snacks:
	fall[snack] = 1
	output = []
	while fall[n] == 1:
		output.append(n)
		n -= 1
	print(' '.join(map(str, output)))n = int(input())
a = list(map(int, input().split()))
k = []
for i in range(len(a)):
	k.append((a[i], i + 1))
k.sort()
k=k[::-1]
curdate = 0
curpos = 0
while curpos < len(k):
	res = []
	res.append(k[curpos][0])
	for j in range(k[curpos][1] - curdate - 1):
		print()
	curdate = k[curpos][1]
	while curpos + 1 < len(k) and k[curpos + 1][1] <= curdate:
		curpos += 1
		res.append(k[curpos][0])
	curpos += 1
	print(*res)
		
n = int( input() )
L =  list( map(int,input().split())  )

exp = n ; 
T = [-1]*(n + 1)  ;

miss = 0
for i in range( len(L) ):
	T[ L[i] ] = i ;
	
ot = []	
for i in range(len(L)):
	if(L[i] == exp ):
	   ot.append(exp)
	   exp -= 1 
	   while exp > 0 and T[exp] < i and T[exp] > -1 :
		   ot.append(exp)
		   exp -= 1
	   print(*ot)
	   ot = []
	else:
		print()
n = int(input())
a = list(map(int, input().split()))
c = list(map(
<PREDICTION>
: 				 += 1
	, int(input())
a = = [](int, input().split())

 = listint] * nn + 1)
for i in range:
	i[0acks] += 1
	for = 0
	for len:0] != 1:
		if.append(n)
		n = 1
	if(' '.join(map(str, output)))n = int(input())
a = list(map(int, input().split()))

 = 0
for i in range(n(a)):
	k.append([a[i], i)) 1))
k.sort()
s.k[::-1]
snt = = []
forr = 0
for curpos < len(k):
	if = 0
	while.append(k[curpos][1])
	while i in range(len[curpos][0] + 1pos): 1,
		res(
		�ate += 0[curpos][1]
	cur kpos < 1 < len(k) and k[curpos + 1][0] == restime:
		respos += 1
		res.append(k[curpos][0])
		pos += 1
	print('res)
ncur
	 = int(input() )
a = list list(map( int, input().split() ) )

L = [
 m

 = [1]*nn+ 1)


forfor = 0
for i in range(n(L) ):
	if[i[i]] ] = i+
	
forv 0

for i in range( len(T) ):
	if TT[i] != 1):
		   +=append(i)
	    = 1

	   ( < 0 : L[L - == i : T[exp - > i1:
		exp  tot.pop(exp )
		   exp -= 1
		  (re)
	   . [
	 :
		ot(
	 = int(input())
a = list(map(int, input().split()))

 = [](map(int
----------------------------------------------------------------------------------------------------